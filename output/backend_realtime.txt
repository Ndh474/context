{
  "metadata": {
    "codebase": "backend",
    "category": "realtime",
    "generated_at": "2025-11-24T20:05:13.452572",
    "total_files": 1,
    "total_lines": 152,
    "total_bytes": 6064
  },
  "files": [
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\realtime\\SseHub.java",
      "relative_path": "src/main/java/com/fuacs/backend/realtime/SseHub.java",
      "filename": "SseHub.java",
      "size_bytes": 6064,
      "lines": 152,
      "last_modified": "2025-11-24T19:58:26.129094",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.realtime;\n\nimport com.fuacs.backend.dto.realtime.AttendanceUpdateEvent;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.MediaType;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.servlet.mvc.method.annotation.SseEmitter;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.*;\n\n@Component\npublic class SseHub {\n    private static final Logger log = LoggerFactory.getLogger(SseHub.class);\n\n    private final ConcurrentMap<Integer, CopyOnWriteArraySet<SseEmitter>> slotEmitters = new ConcurrentHashMap<>();\n    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(r -> {\n        Thread t = new Thread(r, \"sse-heartbeat\");\n        t.setDaemon(true);\n        return t;\n    });\n\n    public SseHub() {\n        scheduler.scheduleAtFixedRate(this::broadcastHeartbeat, 15, 25, TimeUnit.SECONDS);\n    }\n\n    public SseEmitter subscribe(Integer slotId) {\n        SseEmitter emitter = new SseEmitter(60L * 60L * 1000L); // 1 hour timeout\n\n        slotEmitters.computeIfAbsent(slotId, k -> new CopyOnWriteArraySet<>()).add(emitter);\n\n        emitter.onCompletion(() -> removeEmitter(slotId, emitter));\n        emitter.onTimeout(() -> removeEmitter(slotId, emitter));\n        emitter.onError(e -> removeEmitter(slotId, emitter));\n\n        try {\n            SseEmitter.SseEventBuilder event = SseEmitter.event()\n                    .name(\"connected\")\n                    .data(\"ok\")\n                    .reconnectTime(5000);\n            emitter.send(event);\n        } catch (IOException e) {\n            removeEmitter(slotId, emitter);\n        }\n\n        return emitter;\n    }\n\n    public void publishAttendanceUpdate(Integer slotId, AttendanceUpdateEvent payload) {\n        Set<SseEmitter> emitters = slotEmitters.get(slotId);\n        if (emitters == null || emitters.isEmpty()) return;\n\n        for (SseEmitter emitter : emitters) {\n            try {\n                SseEmitter.SseEventBuilder event = SseEmitter.event()\n                        .name(\"attendance.update\")\n                        .data(payload, MediaType.APPLICATION_JSON);\n                emitter.send(event);\n            } catch (IOException e) {\n                // Client disconnected - complete emitter with error and remove\n                try {\n                    emitter.completeWithError(e);\n                } catch (Exception ignored) {\n                    // Emitter might already be completed/closed\n                }\n                removeEmitter(slotId, emitter);\n            } catch (Exception e) {\n                // Unexpected error\n                log.warn(\"Unexpected error during attendance update for slot {}: {}\", slotId, e.getMessage());\n                try {\n                    emitter.completeWithError(e);\n                } catch (Exception ignored) {\n                    // Emitter might already be completed/closed\n                }\n                removeEmitter(slotId, emitter);\n            }\n        }\n    }\n\n    public void publishSlotClosed(Integer slotId) {\n        Set<SseEmitter> emitters = slotEmitters.get(slotId);\n        if (emitters == null || emitters.isEmpty()) return;\n\n        for (SseEmitter emitter : emitters) {\n            try {\n                emitter.send(SseEmitter.event().name(\"slot.closed\").data(\"bye\"));\n                emitter.complete();\n            } catch (IOException e) {\n                // Client disconnected - complete emitter with error and remove\n                try {\n                    emitter.completeWithError(e);\n                } catch (Exception ignored) {\n                    // Emitter might already be completed/closed\n                }\n                removeEmitter(slotId, emitter);\n            } catch (Exception e) {\n                // Unexpected error\n                log.warn(\"Unexpected error during slot close for slot {}: {}\", slotId, e.getMessage());\n                try {\n                    emitter.completeWithError(e);\n                } catch (Exception ignored) {\n                    // Emitter might already be completed/closed\n                }\n                removeEmitter(slotId, emitter);\n            }\n        }\n        slotEmitters.remove(slotId);\n    }\n\n    private void broadcastHeartbeat() {\n        for (Map.Entry<Integer, CopyOnWriteArraySet<SseEmitter>> entry : slotEmitters.entrySet()) {\n            Integer slotId = entry.getKey();\n            for (SseEmitter emitter : entry.getValue()) {\n                try {\n                    emitter.send(SseEmitter.event().name(\"heartbeat\").data(Instant.now().toString()));\n                } catch (IOException e) {\n                    // Client disconnected - complete emitter with error and remove\n                    try {\n                        emitter.completeWithError(e);\n                    } catch (Exception ignored) {\n                        // Emitter might already be completed/closed\n                    }\n                    removeEmitter(slotId, emitter);\n                } catch (Exception e) {\n                    // Unexpected error\n                    log.warn(\"Unexpected error during heartbeat for slot {}: {}\", slotId, e.getMessage());\n                    try {\n                        emitter.completeWithError(e);\n                    } catch (Exception ignored) {\n                        // Emitter might already be completed/closed\n                    }\n                    removeEmitter(slotId, emitter);\n                }\n            }\n        }\n    }\n\n    private void removeEmitter(Integer slotId, SseEmitter emitter) {\n        CopyOnWriteArraySet<SseEmitter> set = slotEmitters.get(slotId);\n        if (set != null) {\n            set.remove(emitter);\n            if (set.isEmpty()) {\n                slotEmitters.remove(slotId);\n            }\n        }\n    }\n}\n\n"
    }
  ]
}