{
  "metadata": {
    "codebase": "backend",
    "category": "exception",
    "generated_at": "2025-11-24T20:05:13.451068",
    "total_files": 6,
    "total_lines": 413,
    "total_bytes": 21761
  },
  "files": [
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\exception\\BadRequestException.java",
      "relative_path": "src/main/java/com/fuacs/backend/exception/BadRequestException.java",
      "filename": "BadRequestException.java",
      "size_bytes": 352,
      "lines": 14,
      "last_modified": "2025-10-29T20:56:54.597134",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.exception;\n\npublic class BadRequestException extends RuntimeException {\n    private final String errorCode;\n\n    public BadRequestException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    public String getErrorCode() {\n        return errorCode;\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\exception\\GlobalExceptionHandler.java",
      "relative_path": "src/main/java/com/fuacs/backend/exception/GlobalExceptionHandler.java",
      "filename": "GlobalExceptionHandler.java",
      "size_bytes": 20350,
      "lines": 367,
      "last_modified": "2025-11-16T12:35:47.566164",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.exception;\n\nimport com.fuacs.backend.dto.response.Response;\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.http.converter.HttpMessageNotReadableException;\nimport org.springframework.security.access.AccessDeniedException;\nimport org.springframework.security.authentication.BadCredentialsException;\nimport org.springframework.security.authentication.InsufficientAuthenticationException;\nimport org.springframework.security.oauth2.core.OAuth2AuthenticationException;\nimport org.springframework.security.oauth2.server.resource.InvalidBearerTokenException;\nimport org.springframework.validation.FieldError;\nimport org.springframework.web.bind.MethodArgumentNotValidException;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;\n\nimport java.time.Instant;\nimport java.time.format.DateTimeParseException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<Response<Void>> handleResourceNotFoundException(ResourceNotFoundException ex) {\n        Response<Void> res = Response.notFound(ex.getMessage());\n        res.setCode(ex.getErrorCode());\n        return new ResponseEntity<>(res, HttpStatus.NOT_FOUND);\n    }\n\n    @ExceptionHandler(InsufficientAuthenticationException.class)\n    public ResponseEntity<Response<Void>> handleInsufficientAuthenticationException(InsufficientAuthenticationException ex) {\n        return new ResponseEntity<>(Response.unauthorized(ex.getMessage()), HttpStatus.UNAUTHORIZED);\n    }\n\n    @ExceptionHandler(InvalidBearerTokenException.class)\n    public ResponseEntity<Response<Void>> handleInvalidBearerTokenException(InvalidBearerTokenException ex) {\n        return new ResponseEntity<>(Response.unauthorized(ex.getMessage()), HttpStatus.UNAUTHORIZED);\n    }\n\n    @ExceptionHandler(OAuth2AuthenticationException.class)\n    public ResponseEntity<Response<Void>> handleOAuth2AuthenticationException(OAuth2AuthenticationException ex) {\n        return new ResponseEntity<>(Response.unauthorized(ex.getMessage()), HttpStatus.UNAUTHORIZED);\n    }\n\n    @ExceptionHandler(DataIntegrityViolationException.class)\n    public ResponseEntity<Response<Void>> handleDataIntegrityViolationException(DataIntegrityViolationException ex) {\n        return new ResponseEntity<>(Response.conflict(ex.getMessage()), HttpStatus.CONFLICT);\n    }\n\n    @ExceptionHandler(IllegalArgumentException.class)\n    public ResponseEntity<Response<Void>> handleIllegalArgumentException(IllegalArgumentException ex) {\n        return new ResponseEntity<>(Response.badRequest(ex.getMessage()), HttpStatus.BAD_REQUEST);\n    }\n\n    @ExceptionHandler(BadCredentialsException.class)\n    public ResponseEntity<Response<Void>> handleBadCredentialsException(BadCredentialsException ex) {\n        return new ResponseEntity<>(Response.unauthorized(ex.getMessage()), HttpStatus.UNAUTHORIZED);\n    }\n\n    @ExceptionHandler(AccessDeniedException.class)\n    public ResponseEntity<Response<Void>> handleAccessDeniedException(AccessDeniedException ex) {\n        Response<Void> res = Response.forbidden(ex.getMessage());\n        res.setCode(com.fuacs.backend.constant.ErrorCode.FORBIDDEN);\n        return new ResponseEntity<>(res, HttpStatus.FORBIDDEN);\n    }\n\n    @ExceptionHandler(BadRequestException.class)\n    public ResponseEntity<Response<Void>> handleBadRequestException(BadRequestException ex) {\n        Response<Void> res = Response.badRequest(ex.getMessage());\n        res.setCode(ex.getErrorCode());\n        return new ResponseEntity<>(res, HttpStatus.BAD_REQUEST);\n    }\n\n    @ExceptionHandler(OperationNotAllowedException.class)\n    public ResponseEntity<Response<Void>> handleOperationNotAllowedException(OperationNotAllowedException ex) {\n        return new ResponseEntity<>(Response.forbidden(ex.getMessage()), HttpStatus.FORBIDDEN);\n    }\n\n    @ExceptionHandler(DateTimeParseException.class)\n    public ResponseEntity<Response<Void>> handleDateTimeParseException(DateTimeParseException ex) {\n        return new ResponseEntity<>(Response.badRequest(ex.getMessage()), HttpStatus.BAD_REQUEST);\n    }\n\n    @ExceptionHandler(HttpMessageNotReadableException.class)\n    public ResponseEntity<Response<Void>> handleHttpMessageNotReadableException(HttpMessageNotReadableException ex) {\n        String message = ex.getMessage();\n        Response<Void> response;\n\n        // Detect enum parsing errors for AttendanceStatus\n        if (message != null && message.contains(\"Cannot construct instance of\") &&\n            message.contains(\"AttendanceStatus\")) {\n            response = Response.badRequest(\"Invalid value for 'status'. Allowed values: not_yet, present, absent\");\n            response.setCode(com.fuacs.backend.constant.ErrorCode.INVALID_STATUS_VALUE);\n        }\n        // Detect LocalDate parsing errors and set appropriate error code\n        else if (message != null && message.contains(\"LocalDate\") && message.contains(\"could not be parsed\")) {\n            // Extract field name if possible (startDate or endDate)\n            String errorMessage;\n            String errorCode;\n\n            if (message.contains(\"startDate\")) {\n                errorMessage = \"Invalid date format for field 'startDate'. Expected 'YYYY-MM-DD'\";\n                errorCode = com.fuacs.backend.constant.ErrorCode.INVALID_START_DATE_FORMAT;\n            } else if (message.contains(\"endDate\")) {\n                errorMessage = \"Invalid date format for field 'endDate'. Expected 'YYYY-MM-DD'\";\n                errorCode = com.fuacs.backend.constant.ErrorCode.INVALID_END_DATE_FORMAT;\n            } else {\n                // Generic date format error\n                errorMessage = \"Invalid date format. Expected 'YYYY-MM-DD'\";\n                errorCode = com.fuacs.backend.constant.ErrorCode.INVALID_START_DATE_FORMAT;\n            }\n\n            response = Response.badRequest(errorMessage);\n            response.setCode(errorCode);\n        } else if (message != null && message.contains(\"Cannot deserialize value of type\")) {\n            // Handle JSON deserialization type conversion errors\n            String errorMessage;\n            String targetType = \"\";\n\n            if (message.contains(\"java.lang.Short\")) {\n                targetType = \"java.lang.Short\";\n            } else if (message.contains(\"java.lang.Integer\")) {\n                targetType = \"java.lang.Integer\";\n            } else if (message.contains(\"java.lang.Boolean\")) {\n                targetType = \"java.lang.Boolean\";\n            }\n\n            if (!targetType.isEmpty()) {\n                errorMessage = \"Failed to convert value of type 'java.lang.String' to required type '\" + targetType + \"'\";\n            } else {\n                errorMessage = message;\n            }\n\n            response = Response.badRequest(errorMessage);\n            response.setCode(com.fuacs.backend.constant.ErrorCode.INVALID_FIELD_TYPE);\n        } else {\n            // Generic JSON parsing error\n            response = Response.badRequest(message);\n        }\n\n        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);\n    }\n\n    @ExceptionHandler(Exception.class)\n    public Object handleGeneric(Exception ex, HttpServletRequest request) {\n        log.error(ex.getMessage(), ex);\n\n        // Check if this is an SSE endpoint (Server-Sent Events)\n        // SSE endpoints have Content-Type: text/event-stream and cannot return HashMap\n        String acceptHeader = request.getHeader(\"Accept\");\n        if (acceptHeader != null && acceptHeader.contains(MediaType.TEXT_EVENT_STREAM_VALUE)) {\n            // For SSE endpoints: return empty ResponseEntity without body\n            // This prevents HttpMessageNotWritableException (cannot convert HashMap to text/event-stream)\n            log.error(\"SSE endpoint error - returning empty response with HTTP 500\");\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\n        }\n\n        // For regular REST endpoints: return HashMap error response as usual\n        String message = ex.getMessage() != null ? ex.getMessage() : ex.getClass().getSimpleName();\n        return buildResponse(HttpStatus.INTERNAL_SERVER_ERROR, message);\n    }\n\n    private ResponseEntity<Map<String, Object>> buildResponse(HttpStatus status, String message) {\n        Map<String, Object> body = new HashMap<>();\n        body.put(\"timestamp\", Instant.now());\n        body.put(\"status\", status.value());\n        body.put(\"error\", status.getReasonPhrase());\n        body.put(\"message\", message);\n        return ResponseEntity.status(status).body(body);\n    }\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<Response<Void>> handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) {\n        StringBuilder errorMessages = new StringBuilder();\n        String code = null;\n\n        // First pass: check for \"blank\" validation errors (highest priority)\n        for (FieldError error : ex.getBindingResult().getFieldErrors()) {\n            String field = error.getField();\n            String message = error.getDefaultMessage();\n            String objectName = error.getObjectName();\n\n            if (message != null && message.contains(\"must not be blank\")) {\n                // Found a blank error - map to REQUIRED error code\n                switch (field) {\n                    case \"fullName\" -> code = com.fuacs.backend.constant.ErrorCode.FULL_NAME_REQUIRED;\n                    case \"email\" -> code = com.fuacs.backend.constant.ErrorCode.EMAIL_REQUIRED;\n                    case \"rollNumber\" -> code = com.fuacs.backend.constant.ErrorCode.ROLL_NUMBER_REQUIRED;\n                    case \"code\" -> {\n                        if (objectName.toLowerCase().contains(\"class\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.CLASS_CODE_REQUIRED;\n                        }\n                    }\n                }\n                if (code != null) break; // Found our blank error, stop looking\n            }\n        }\n\n        // Second pass: if no blank error found, check for format validation errors\n        if (code == null) {\n            for (FieldError error : ex.getBindingResult().getFieldErrors()) {\n                String field = error.getField();\n                String message = error.getDefaultMessage();\n                String objectName = error.getObjectName();\n\n                if (message != null) {\n                    if (message.contains(\"must be a well-formed email address\")) {\n                        code = com.fuacs.backend.constant.ErrorCode.INVALID_EMAIL_FORMAT;\n                        break;\n                    } else if (message.contains(\"Roll number must be 2 uppercase letters followed by 6 digits\")) {\n                        code = com.fuacs.backend.constant.ErrorCode.INVALID_ROLL_NUMBER_FORMAT;\n                        break;\n                    } else if (field.equals(\"staffCode\") && message.contains(\"must contain only letters and digits\")) {\n                        code = com.fuacs.backend.constant.ErrorCode.STAFF_CODE_REQUIRED;\n                        break;\n                    } else if (objectName.toLowerCase().contains(\"major\") && field.equals(\"name\") && message.contains(\"Name allows letters, digits, spaces, &, -\")) {\n                        code = com.fuacs.backend.constant.ErrorCode.MAJOR_NAME_REQUIRED;\n                        break;\n                    } else if (objectName.toLowerCase().contains(\"major\") && field.equals(\"code\") && message.contains(\"Code allows letters and digits only\")) {\n                        code = com.fuacs.backend.constant.ErrorCode.MAJOR_CODE_REQUIRED;\n                        break;\n                    } else if (field.equals(\"code\") && message.contains(\"Code allows letters/digits only\")) {\n                        code = com.fuacs.backend.constant.ErrorCode.SEMESTER_CODE_REQUIRED;\n                        break;\n                    } else if (objectName.toLowerCase().contains(\"class\") && field.equals(\"code\") && message.contains(\"Code must contain only uppercase letters and digits\")) {\n                        code = com.fuacs.backend.constant.ErrorCode.CLASS_CODE_REQUIRED;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Third pass: if still no code found, map based on field name\n        if (code == null) {\n            for (FieldError error : ex.getBindingResult().getFieldErrors()) {\n                String field = error.getField();\n                String objectName = error.getObjectName();\n                switch (field) {\n                    // Pagination fields\n                    case \"page\" -> code = com.fuacs.backend.constant.ErrorCode.INVALID_PAGE;\n                    case \"pageSize\" -> code = com.fuacs.backend.constant.ErrorCode.INVALID_PAGE_SIZE;\n                    case \"sort\" -> code = com.fuacs.backend.constant.ErrorCode.INVALID_SORT;\n                    case \"sortBy\" -> code = com.fuacs.backend.constant.ErrorCode.INVALID_SORT_BY;\n                    // Student Profile fields\n                    case \"fullName\" -> code = com.fuacs.backend.constant.ErrorCode.FULL_NAME_REQUIRED;\n                    case \"email\" -> code = com.fuacs.backend.constant.ErrorCode.EMAIL_REQUIRED;\n                    case \"rollNumber\" -> code = com.fuacs.backend.constant.ErrorCode.ROLL_NUMBER_REQUIRED;\n                    case \"majorId\" -> code = com.fuacs.backend.constant.ErrorCode.MAJOR_ID_REQUIRED;\n                    // Major, Semester, Room, or Camera fields (differentiate by objectName)\n                    case \"name\" -> {\n                        if (objectName.toLowerCase().contains(\"major\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.MAJOR_NAME_REQUIRED;\n                        } else if (objectName.toLowerCase().contains(\"room\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.ROOM_NAME_REQUIRED;\n                        } else if (objectName.toLowerCase().contains(\"camera\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.CAMERA_NAME_REQUIRED;\n                        } else if (objectName.toLowerCase().contains(\"role\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.ROLE_NAME_REQUIRED;\n                        } else if (objectName.toLowerCase().contains(\"permission\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.PERMISSION_NAME_REQUIRED;\n                        } else {\n                            code = com.fuacs.backend.constant.ErrorCode.SEMESTER_NAME_REQUIRED;\n                        }\n                    }\n                    case \"code\" -> {\n                        if (objectName.toLowerCase().contains(\"major\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.MAJOR_CODE_REQUIRED;\n                        } else {\n                            code = com.fuacs.backend.constant.ErrorCode.SEMESTER_CODE_REQUIRED;\n                        }\n                    }\n                    case \"startDate\" -> code = com.fuacs.backend.constant.ErrorCode.SEMESTER_START_DATE_REQUIRED;\n                    case \"endDate\" -> code = com.fuacs.backend.constant.ErrorCode.SEMESTER_END_DATE_REQUIRED;\n                    // Camera-specific fields\n                    case \"rtspUrl\" -> code = com.fuacs.backend.constant.ErrorCode.RTSP_URL_REQUIRED;\n                    case \"roomId\" -> {\n                        if (objectName.toLowerCase().contains(\"camera\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.ROOM_ID_REQUIRED;\n                        }\n                    }\n                    // Class-specific fields\n                    case \"subjectId\" -> {\n                        if (objectName.toLowerCase().contains(\"class\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.CLASS_SUBJECT_ID_REQUIRED;\n                        }\n                    }\n                    case \"semesterId\" -> {\n                        if (objectName.toLowerCase().contains(\"class\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.CLASS_SEMESTER_ID_REQUIRED;\n                        }\n                    }\n                    // Remark fields are now optional - no special error code mapping needed\n                    // Size validation errors will be handled generically\n                    // Status field (for attendance records)\n                    case \"status\" -> {\n                        if (objectName.toLowerCase().contains(\"attendancerecord\") ||\n                            objectName.toLowerCase().contains(\"examattendance\")) {\n                            code = com.fuacs.backend.constant.ErrorCode.STATUS_REQUIRED;\n                        }\n                    }\n                }\n                if (code != null) break;\n            }\n        }\n\n        // Build combined error message\n        for (FieldError error : ex.getBindingResult().getFieldErrors()) {\n            errorMessages.append(error.getDefaultMessage())\n                    .append(System.lineSeparator());\n        }\n\n        log.error(ex.getMessage());\n        Response<Void> res = Response.badRequest(errorMessages.toString());\n        if (code != null) res.setCode(code);\n        return new ResponseEntity<>(res, HttpStatus.BAD_REQUEST);\n    }\n\n    @ExceptionHandler(MethodArgumentTypeMismatchException.class)\n    public ResponseEntity<Response<Void>> handleTypeMismatch(MethodArgumentTypeMismatchException ex) {\n        String message;\n        String errorCode;\n\n        // Check if this is an AttendanceStatus enum conversion error\n        if (ex.getRequiredType() != null &&\n            ex.getRequiredType().getName().equals(\"com.fuacs.backend.constant.enums.AttendanceStatus\") &&\n            \"status\".equals(ex.getName())) {\n            message = String.format(\n                \"Failed to convert property value of type 'java.lang.String' to required type '%s' for property '%s'; \" +\n                \"Failed to convert from type [java.lang.String] to type [%s] for value [%s]\",\n                ex.getRequiredType().getSimpleName(),\n                ex.getName(),\n                ex.getRequiredType().getSimpleName(),\n                ex.getValue()\n            );\n            errorCode = com.fuacs.backend.constant.ErrorCode.STATUS_REQUIRED;\n        }\n        // Build appropriate error message matching API documentation format\n        else if (ex.getCause() instanceof NumberFormatException) {\n            message = String.format(\n                \"Failed to convert value of type 'java.lang.String' to required type '%s'\",\n                ex.getRequiredType() != null ? ex.getRequiredType().getName() : \"java.lang.Integer\"\n            );\n            errorCode = com.fuacs.backend.constant.ErrorCode.INVALID_FIELD_TYPE;\n        } else {\n            message = String.format(\n                \"Failed to convert value of type 'java.lang.String' to required type '%s'\",\n                ex.getRequiredType() != null ? ex.getRequiredType().getName() : \"unknown\"\n            );\n            errorCode = com.fuacs.backend.constant.ErrorCode.INVALID_FIELD_TYPE;\n        }\n\n        // Use standard Response format with error code (matches documented API format)\n        Response<Void> response = Response.badRequest(message);\n        response.setCode(errorCode);\n\n        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\exception\\InvalidDateException.java",
      "relative_path": "src/main/java/com/fuacs/backend/exception/InvalidDateException.java",
      "filename": "InvalidDateException.java",
      "size_bytes": 220,
      "lines": 7,
      "last_modified": "2025-10-29T20:56:54.598133",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.exception;\n\npublic class InvalidDateException extends BadRequestException {\n    public InvalidDateException(String message, String errorCode) {\n        super(message, errorCode);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\exception\\OperationNotAllowedException.java",
      "relative_path": "src/main/java/com/fuacs/backend/exception/OperationNotAllowedException.java",
      "filename": "OperationNotAllowedException.java",
      "size_bytes": 235,
      "lines": 7,
      "last_modified": "2025-10-29T20:56:54.598133",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.exception;\n\npublic class OperationNotAllowedException extends BadRequestException{\n    public OperationNotAllowedException(String message, String errorCode) {\n        super(message, errorCode);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\exception\\ResourceExistsException.java",
      "relative_path": "src/main/java/com/fuacs/backend/exception/ResourceExistsException.java",
      "filename": "ResourceExistsException.java",
      "size_bytes": 226,
      "lines": 7,
      "last_modified": "2025-10-29T20:56:54.598133",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.exception;\n\npublic class ResourceExistsException extends BadRequestException {\n    public ResourceExistsException(String message, String errorCode) {\n        super(message, errorCode);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\exception\\ResourceNotFoundException.java",
      "relative_path": "src/main/java/com/fuacs/backend/exception/ResourceNotFoundException.java",
      "filename": "ResourceNotFoundException.java",
      "size_bytes": 378,
      "lines": 11,
      "last_modified": "2025-10-29T20:56:54.599134",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.exception;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.ResponseStatus;\n\n@ResponseStatus(HttpStatus.NOT_FOUND)\npublic class ResourceNotFoundException extends BadRequestException {\n    public ResourceNotFoundException(String message, String errorCode) {\n        super(message, errorCode);\n    }\n}"
    }
  ]
}