{
  "metadata": {
    "codebase": "backend",
    "category": "service",
    "generated_at": "2025-11-24T20:05:13.456085",
    "total_files": 37,
    "total_lines": 14389,
    "total_bytes": 661570
  },
  "files": [
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\scheduler\\AttendanceFinalizeService.java",
      "relative_path": "src/main/java/com/fuacs/backend/scheduler/AttendanceFinalizeService.java",
      "filename": "AttendanceFinalizeService.java",
      "size_bytes": 6629,
      "lines": 159,
      "last_modified": "2025-11-24T19:58:29.641855",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.scheduler;\n\nimport com.fuacs.backend.entity.Slot;\nimport com.fuacs.backend.constant.enums.AttendanceMethod;\nimport com.fuacs.backend.constant.enums.AttendanceStatus;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.repository.AttendanceRecordRepository;\nimport com.fuacs.backend.repository.ExamAttendanceRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.util.Arrays;\nimport java.util.List;\n\n@Service\npublic class AttendanceFinalizeService {\n\n    private static final Logger log = LoggerFactory.getLogger(AttendanceFinalizeService.class);\n\n    private final SlotRepository slotRepository;\n    private final AttendanceRecordRepository attendanceRecordRepository;\n    private final ExamAttendanceRepository examAttendanceRepository;\n\n    public AttendanceFinalizeService(SlotRepository slotRepository,\n                                    AttendanceRecordRepository attendanceRecordRepository,\n                                    ExamAttendanceRepository examAttendanceRepository) {\n        this.slotRepository = slotRepository;\n        this.attendanceRecordRepository = attendanceRecordRepository;\n        this.examAttendanceRepository = examAttendanceRepository;\n    }\n\n    private static final ZoneId VIETNAM_ZONE = ZoneId.of(\"Asia/Ho_Chi_Minh\");\n    private static final int EXAM_GRACE_PERIOD_MINUTES = 10;\n\n    /**\n     * Finalize attendance for LECTURE and LECTURE_WITH_PT slots that ended today.\n     * Changes all NOT_YET status to ABSENT using SYSTEM_FINALIZE method.\n     * This method is called daily at 23:59.\n     */\n    @Transactional\n    public void finalizeLectureAttendance() {\n        log.info(\"Starting daily lecture attendance finalization...\");\n\n        LocalDateTime startOfDay = LocalDate.now(VIETNAM_ZONE).atStartOfDay();\n        LocalDateTime endOfDay = startOfDay.plusDays(1).minusSeconds(1);\n\n        // Find active slots that ended today (LECTURE and LECTURE_WITH_PT)\n        List<Slot> slotsToFinalize = slotRepository.findActiveSlotsByCategoriesTodayEnded(\n            Arrays.asList(SlotCategory.LECTURE, SlotCategory.LECTURE_WITH_PT),\n            startOfDay,\n            endOfDay\n        );\n\n        log.info(\"Found {} active slots to finalize for today\", slotsToFinalize.size());\n\n        int totalRegularUpdated = 0;\n        int totalExamUpdated = 0;\n\n        for (Slot slot : slotsToFinalize) {\n            try {\n                // Update regular attendance records (for both LECTURE and LECTURE_WITH_PT)\n                int regularUpdated = attendanceRecordRepository.bulkUpdateStatus(\n                    slot.getId(),\n                    AttendanceStatus.NOT_YET,\n                    AttendanceStatus.ABSENT,\n                    AttendanceMethod.SYSTEM_FINALIZE,\n                    Instant.now()\n                );\n                totalRegularUpdated += regularUpdated;\n\n                // Update exam attendance if it's LECTURE_WITH_PT\n                int examUpdated = 0;\n                if (slot.getSlotCategory() == SlotCategory.LECTURE_WITH_PT) {\n                    examUpdated = examAttendanceRepository.bulkUpdateExamStatus(\n                        slot.getId(),\n                        AttendanceStatus.NOT_YET,\n                        AttendanceStatus.ABSENT,\n                        AttendanceMethod.SYSTEM_FINALIZE,\n                        Instant.now()\n                    );\n                    totalExamUpdated += examUpdated;\n                }\n\n                if (regularUpdated > 0 || examUpdated > 0) {\n                    log.info(\"Finalized attendance for slot [ID: {}, Title: {}]: {} regular, {} exam records updated\",\n                        slot.getId(), slot.getTitle(), regularUpdated, examUpdated);\n                }\n\n            } catch (Exception e) {\n                log.error(\"Error finalizing attendance for slot [ID: {}, Title: {}]\",\n                    slot.getId(), slot.getTitle(), e);\n            }\n        }\n\n        log.info(\"Daily lecture attendance finalization completed. Total updated: {} regular, {} exam records\",\n            totalRegularUpdated, totalExamUpdated);\n    }\n\n    /**\n     * Finalize attendance for FINAL_EXAM slots that ended more than 10 minutes ago.\n     * Changes all NOT_YET status to ABSENT using SYSTEM_FINALIZE method.\n     * This method is called every minute to check for expired exam slots.\n     */\n    @Transactional\n    public void finalizeExamAttendance() {\n        // Calculate cutoff time (current time - 10 minutes)\n        LocalDateTime cutoffTime = LocalDateTime.now(VIETNAM_ZONE)\n            .minusMinutes(EXAM_GRACE_PERIOD_MINUTES);\n\n        // Find active FINAL_EXAM slots that ended more than 10 minutes ago\n        List<Slot> expiredExamSlots = slotRepository.findActiveExpiredExamSlotsWithPendingAttendance(\n            SlotCategory.FINAL_EXAM,\n            cutoffTime,\n            AttendanceStatus.NOT_YET\n        );\n\n        if (expiredExamSlots.isEmpty()) {\n            return;\n        }\n\n        log.info(\"Found {} expired exam slots to finalize\", expiredExamSlots.size());\n\n        int totalUpdated = 0;\n\n        for (Slot slot : expiredExamSlots) {\n            try {\n                // Update exam attendance records\n                int updated = examAttendanceRepository.bulkUpdateExamStatus(\n                    slot.getId(),\n                    AttendanceStatus.NOT_YET,\n                    AttendanceStatus.ABSENT,\n                    AttendanceMethod.SYSTEM_FINALIZE,\n                    Instant.now()\n                );\n                totalUpdated += updated;\n\n                if (updated > 0) {\n                    log.info(\"Finalized exam attendance for slot [ID: {}, Title: {}, EndTime: {}]: {} records updated\",\n                        slot.getId(), slot.getTitle(), slot.getEndTime(), updated);\n                }\n\n            } catch (Exception e) {\n                log.error(\"Error finalizing exam attendance for slot [ID: {}, Title: {}]\",\n                    slot.getId(), slot.getTitle(), e);\n            }\n        }\n\n        if (totalUpdated > 0) {\n            log.info(\"Exam attendance finalization completed. Total {} records updated\", totalUpdated);\n        }\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\AttendanceHistoryService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/AttendanceHistoryService.java",
      "filename": "AttendanceHistoryService.java",
      "size_bytes": 5253,
      "lines": 114,
      "last_modified": "2025-11-13T19:32:28.858339",
      "encoding": "utf-8",
      "language": "java",
      "content": "// src/main/java/com/fuacs/backend/service/AttendanceHistoryService.java\npackage com.fuacs.backend.service;\n\nimport com.fuacs.backend.config.UserAuthentication;\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.dto.request.AttendanceHistorySearchRequest;\nimport com.fuacs.backend.dto.response.AttendanceHistoryDTO;\nimport com.fuacs.backend.dto.response.AttendanceHistoryWithSummaryDTO;\nimport com.fuacs.backend.dto.response.AttendanceSummaryDTO;\nimport com.fuacs.backend.dto.response.AttendanceSummaryDetailsDTO;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport com.fuacs.backend.repository.custom.CustomAttendanceHistoryRepository;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.List;\n\n@Service\npublic class AttendanceHistoryService {\n    private final CustomAttendanceHistoryRepository attendanceHistoryRepository;\n    private final StudentProfileRepository studentProfileRepository;\n    private final SemesterService semesterService;\n\n    public AttendanceHistoryService(\n            CustomAttendanceHistoryRepository attendanceHistoryRepository,\n            StudentProfileRepository studentProfileRepository,\n            SemesterService semesterService) {\n        this.attendanceHistoryRepository = attendanceHistoryRepository;\n        this.studentProfileRepository = studentProfileRepository;\n        this.semesterService = semesterService;\n    }\n\n    @Transactional(readOnly = true)\n    public AttendanceHistoryWithSummaryDTO getAttendanceHistory(Integer studentId,\n            AttendanceHistorySearchRequest request) {\n        // Check authorization\n        checkAuthorization(studentId);\n\n        // Validate student exists\n        studentProfileRepository.findById(studentId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Student profile not found: \" + studentId,\n                        ErrorCode.STUDENT_PROFILE_NOT_FOUND));\n\n        // Validate semester if provided\n        if (request.getSemesterId() != null) {\n            semesterService.findById(request.getSemesterId());\n        }\n\n        // Get attendance history\n        List<AttendanceHistoryDTO> items = attendanceHistoryRepository.searchByStudentId(studentId, request);\n        AttendanceSummaryDTO summary = attendanceHistoryRepository.getAttendanceSummary(studentId, request);\n\n        return new AttendanceHistoryWithSummaryDTO(items, summary);\n    }\n\n    @Transactional(readOnly = true)\n    public AttendanceSummaryDetailsDTO getDetailedSummary(Integer studentId, AttendanceHistorySearchRequest request) {\n        // Check authorization\n        checkAuthorization(studentId);\n\n        // Validate student exists\n        studentProfileRepository.findById(studentId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Student profile not found: \" + studentId,\n                        ErrorCode.STUDENT_PROFILE_NOT_FOUND));\n\n        // Validate semester if provided\n        if (request.getSemesterId() != null) {\n            semesterService.findById(request.getSemesterId());\n        }\n\n        return attendanceHistoryRepository.getDetailedSummary(studentId, request);\n    }\n\n    @Transactional(readOnly = true)\n    public Long countAttendanceHistory(Integer studentId, AttendanceHistorySearchRequest request) {\n        // Check authorization\n        checkAuthorization(studentId);\n\n        // Validate student exists\n        studentProfileRepository.findById(studentId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Student profile not found: \" + studentId,\n                        ErrorCode.STUDENT_PROFILE_NOT_FOUND));\n\n        // Validate semester if provided\n        if (request.getSemesterId() != null) {\n            semesterService.findById(request.getSemesterId());\n        }\n\n        return attendanceHistoryRepository.countByStudentId(studentId, request);\n    }\n\n    private void checkAuthorization(Integer studentId) {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n\n        if (authentication instanceof UserAuthentication userAuth) {\n            // Students can only view their own attendance history\n            if (userAuth.hasRole(\"STUDENT\")) {\n                Integer currentUserId = userAuth.getUserId();\n                if (!currentUserId.equals(studentId)) {\n                    throw new OperationNotAllowedException(\n                            \"You are not authorized to view this student's attendance history\", ErrorCode.FORBIDDEN);\n                }\n            }\n            // Data Operators can view any student's attendance history\n            // This permission is checked via @PreAuthorize in the controller\n        } else {\n            throw new OperationNotAllowedException(\"Invalid authentication\", ErrorCode.UN_AUTHENTICATION);\n        }\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\AttendanceRecordService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/AttendanceRecordService.java",
      "filename": "AttendanceRecordService.java",
      "size_bytes": 45707,
      "lines": 914,
      "last_modified": "2025-11-11T13:24:54.494160",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.enums.AttendanceMethod;\nimport com.fuacs.backend.constant.enums.AttendanceStatus;\nimport com.fuacs.backend.constant.enums.ScanMode;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.dto.mapper.AttendanceRecordMapper;\nimport com.fuacs.backend.dto.request.AttendanceRecordSearchRequest;\nimport com.fuacs.backend.dto.request.AttendanceRecordUpdateRequest;\nimport com.fuacs.backend.dto.request.RecognitionResultRequest;\nimport com.fuacs.backend.dto.response.AttendanceRecordDTO;\nimport com.fuacs.backend.entity.AttendanceRecord;\nimport com.fuacs.backend.entity.RegularAttendanceEvidence;\nimport com.fuacs.backend.entity.ExamAttendanceEvidence;\nimport com.fuacs.backend.entity.ExamAttendance;\nimport com.fuacs.backend.entity.Slot;\nimport com.fuacs.backend.entity.StudentProfile;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.AttendanceRecordRepository;\nimport com.fuacs.backend.repository.ExamAttendanceRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport com.fuacs.backend.repository.UserRepository;\nimport com.fuacs.backend.repository.EnrollmentRepository;\nimport com.fuacs.backend.entity.EnrollmentId;\nimport com.fuacs.backend.repository.RegularAttendanceEvidenceRepository;\nimport com.fuacs.backend.repository.ExamAttendanceEvidenceRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.fuacs.backend.realtime.SseHub;\nimport com.fuacs.backend.dto.realtime.AttendanceUpdateEvent;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n@Service\npublic class AttendanceRecordService {\n\n    private static final Logger logger = LoggerFactory.getLogger(AttendanceRecordService.class);\n\n    private final AttendanceRecordRepository attendanceRecordRepository;\n    private final ExamAttendanceRepository examAttendanceRepository;\n    private final SlotRepository slotRepository;\n    private final UserRepository userRepository;\n    private final AttendanceRecordMapper attendanceRecordMapper;\n    private final StudentProfileRepository studentProfileRepository;\n    private final EnrollmentRepository enrollmentRepository;\n    private final RegularAttendanceEvidenceRepository regularAttendanceEvidenceRepository;\n    private final ExamAttendanceEvidenceRepository examAttendanceEvidenceRepository;\n    private final SseHub sseHub;\n    private final EvidenceStorageService evidenceStorageService;\n\n    public AttendanceRecordService(AttendanceRecordRepository attendanceRecordRepository,\n            ExamAttendanceRepository examAttendanceRepository,\n            SlotRepository slotRepository,\n            UserRepository userRepository,\n            AttendanceRecordMapper attendanceRecordMapper,\n            StudentProfileRepository studentProfileRepository,\n            EnrollmentRepository enrollmentRepository,\n            RegularAttendanceEvidenceRepository regularAttendanceEvidenceRepository,\n            ExamAttendanceEvidenceRepository examAttendanceEvidenceRepository,\n            SseHub sseHub,\n            EvidenceStorageService evidenceStorageService) {\n        this.attendanceRecordRepository = attendanceRecordRepository;\n        this.examAttendanceRepository = examAttendanceRepository;\n        this.slotRepository = slotRepository;\n        this.userRepository = userRepository;\n        this.attendanceRecordMapper = attendanceRecordMapper;\n        this.studentProfileRepository = studentProfileRepository;\n        this.enrollmentRepository = enrollmentRepository;\n        this.regularAttendanceEvidenceRepository = regularAttendanceEvidenceRepository;\n        this.examAttendanceEvidenceRepository = examAttendanceEvidenceRepository;\n        this.sseHub = sseHub;\n        this.evidenceStorageService = evidenceStorageService;\n    }\n\n    @Transactional(readOnly = true)\n    public List<AttendanceRecordDTO> findAll(AttendanceRecordSearchRequest request) {\n        return attendanceRecordRepository.search(request);\n    }\n\n    @Transactional(readOnly = true)\n    public Long count(AttendanceRecordSearchRequest request) {\n        return attendanceRecordRepository.count(request);\n    }\n\n    @Transactional(readOnly = true)\n    public AttendanceRecordDTO findById(Long id) {\n        // Use custom query to fetch all nested data\n        AttendanceRecordDTO dto = attendanceRecordRepository.findByIdWithDetails(id);\n\n        if (dto == null) {\n            throw new ResourceNotFoundException(\"Attendance record not found: \" + id,\n                    ErrorCode.ATTENDANCE_RECORD_NOT_FOUND);\n        }\n\n        return dto;\n    }\n\n    @Transactional\n    public AttendanceRecordDTO updateStatus(Long id, AttendanceRecordUpdateRequest request, Integer currentUserId) {\n        AttendanceRecord attendanceRecord = attendanceRecordRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Attendance record not found: \" + id,\n                        ErrorCode.ATTENDANCE_RECORD_NOT_FOUND));\n\n        Slot slot = attendanceRecord.getSlot();\n\n        // Check if slot is active\n        if (!slot.getActive()) {\n            throw new BadRequestException(\n                    \"Cannot update attendance for inactive slot\",\n                    ErrorCode.INACTIVE_SLOT_NOT_ALLOWED);\n        }\n\n        // Check authorization: either assigned staff OR Data Operator (after cutoff)\n        boolean isAssignedStaff = slot.getStaff().getId().equals(currentUserId);\n        boolean hasManualPermission = com.fuacs.backend.util.SecurityUtil.getUserAuthentication()\n                .map(com.fuacs.backend.config.UserAuthentication::getPermissions)\n                .map(p -> p.contains(\"ATTENDANCE_STATUS_UPDATE_MANUAL\"))\n                .orElse(false);\n\n        if (!isAssignedStaff && !hasManualPermission) {\n            throw new OperationNotAllowedException(\n                    \"You are not assigned to this slot and do not have permission to edit attendance\",\n                    ErrorCode.NOT_ASSIGNED_TO_SLOT);\n        }\n\n        // Validate edit window (enforces time restrictions based on role)\n        validateEditWindow(slot, isAssignedStaff, hasManualPermission);\n\n        // Validate status transition\n        AttendanceStatus currentStatus = attendanceRecord.getStatus();\n        AttendanceStatus newStatus = request.getStatus();\n\n        if (!isValidStatusTransition(currentStatus, newStatus)) {\n            throw new BadRequestException(\"Invalid status transition\", ErrorCode.SLOT_FINALIZATION_RULE_INVALID);\n        }\n\n        // Optional guard: ensure student is enrolled in this class if the slot is\n        // class-based\n        if (slot.getAcademicClass() != null) {\n            Short classId = slot.getAcademicClass().getId();\n            EnrollmentId enrollmentId = new EnrollmentId(classId, attendanceRecord.getStudent().getId());\n            boolean enrolled = enrollmentRepository.existsByIdAndIsEnrolled(enrollmentId, true);\n            if (!enrolled) {\n                throw new OperationNotAllowedException(\"Student is not enrolled in this class\",\n                        ErrorCode.STUDENT_NOT_ENROLLED_IN_CLASS);\n            }\n        }\n\n        // Update attendance record\n        attendanceRecord.setStatus(newStatus);\n        attendanceRecord.setMethod(AttendanceMethod.MANUAL);\n        attendanceRecord.setRecordedAt(Instant.now());\n\n        // Set remark inline (overwrites existing remark)\n        if (request.getRemark() != null && !request.getRemark().trim().isEmpty()) {\n            attendanceRecord.setRemark(request.getRemark().trim());\n        }\n\n        // Save the updated record\n        attendanceRecord = attendanceRecordRepository.save(attendanceRecord);\n\n        // Return full nested data using findById\n        return findById(attendanceRecord.getId());\n    }\n\n    @Transactional\n    public Map<String, Object> processRecognitionResults(RecognitionResultRequest request) {\n        Integer slotId = request.getSlotId();\n        Slot slot = slotRepository.findById(slotId)\n                .orElseThrow(\n                        () -> new ResourceNotFoundException(\"Slot not found: \" + slotId, ErrorCode.SLOT_NOT_FOUND));\n\n        // Check if slot is active\n        if (!slot.getActive()) {\n            throw new BadRequestException(\n                    \"Cannot process attendance for inactive slot\",\n                    ErrorCode.INACTIVE_SLOT_NOT_ALLOWED);\n        }\n\n        ScanMode mode = request.getMode() != null ? request.getMode() : ScanMode.INITIAL;\n\n        // Delegate to appropriate handler based on mode\n        if (mode == ScanMode.RESCAN) {\n            return processRescanRecognitionResults(request, slot);\n        } else {\n            return processInitialRecognitionResults(request, slot);\n        }\n    }\n\n    /**\n     * Process recognition results for INITIAL mode (first scan)\n     * Auto-updates status to PRESENT when student is detected\n     */\n    private Map<String, Object> processInitialRecognitionResults(RecognitionResultRequest request, Slot slot) {\n        SlotCategory slotCategory = slot.getSlotCategory();\n        List<RecognitionResultRequest.RecognitionItem> recognitions = request.getRecognitions();\n\n        // Get callbackType from request (default to \"REGULAR\" for backward compatibility)\n        String callbackType = request.getCallbackType() != null ? request.getCallbackType() : \"REGULAR\";\n\n        int totalRecognitions = recognitions.size();\n        int successCount = 0;\n        int skippedCount = 0;\n        List<Map<String, Object>> results = new ArrayList<>();\n\n        for (RecognitionResultRequest.RecognitionItem recognition : recognitions) {\n            Map<String, Object> result = processRecognition(recognition, slot, slotCategory, callbackType);\n            results.add(result);\n\n            if (\"updated\".equals(result.get(\"status\"))) {\n                successCount++;\n            } else {\n                skippedCount++;\n            }\n        }\n\n        return Map.of(\n                \"slotId\", slot.getId(),\n                \"mode\", \"INITIAL\",\n                \"totalRecognitions\", totalRecognitions,\n                \"successCount\", successCount,\n                \"skippedCount\", skippedCount,\n                \"results\", results);\n    }\n    private Map<String, Object> processRescanRecognitionResults(RecognitionResultRequest request, Slot slot) {\n        SlotCategory slotCategory = slot.getSlotCategory();\n        List<RecognitionResultRequest.RecognitionItem> recognitions = request.getRecognitions();\n\n        // Get callbackType from request (default to \"REGULAR\" for backward compatibility)\n        String callbackType = request.getCallbackType() != null ? request.getCallbackType() : \"REGULAR\";\n\n        // Extract student IDs detected in this rescan\n        Set<Integer> detectedStudentIds = recognitions.stream()\n                .map(RecognitionResultRequest.RecognitionItem::getStudentUserId)\n                .collect(Collectors.toSet());\n\n        int evidenceUpdatedCount = 0;\n\n        // Determine if we should process regular attendance based on callbackType\n        boolean shouldProcessRegular = \"REGULAR\".equalsIgnoreCase(callbackType) &&\n                (slotCategory == SlotCategory.LECTURE || slotCategory == SlotCategory.LECTURE_WITH_PT);\n\n        // Process regular attendance (LECTURE / LECTURE_WITH_PT)\n        if (shouldProcessRegular) {\n            List<AttendanceRecord> allRecords = attendanceRecordRepository.findBySlotId(slot.getId());\n            List<AttendanceRecord> changedRecords = new java.util.ArrayList<>();\n\n            for (AttendanceRecord record : allRecords) {\n                Integer studentId = record.getStudent().getId();\n                boolean wasDetected = detectedStudentIds.contains(studentId);\n                boolean changed = false;\n\n                // RESCAN LOGIC: Only update evidence for detected students\n                // needsReview flags will be set in stopSession() after collecting all recognized students\n\n                // Update evidence for PRESENT students who are detected again\n                if (record.getStatus() == AttendanceStatus.PRESENT && wasDetected) {\n                    RecognitionResultRequest.RecognitionItem recognition = findRecognitionForStudent(recognitions,\n                            studentId);\n                    if (recognition != null && recognition.getEvidence() != null\n                            && recognition.getEvidence().getRegularImageUrl() != null) {\n                        updateRegularAttendanceEvidence(record, recognition.getEvidence().getRegularImageUrl());\n                        evidenceUpdatedCount++;\n                        changed = true;\n                    }\n                }\n                // Update evidence for ABSENT students who are detected (will be flagged in stopSession)\n                else if (record.getStatus() == AttendanceStatus.ABSENT && wasDetected) {\n                    RecognitionResultRequest.RecognitionItem recognition = findRecognitionForStudent(recognitions,\n                            studentId);\n                    if (recognition != null && recognition.getEvidence() != null\n                            && recognition.getEvidence().getRegularImageUrl() != null) {\n                        updateRegularAttendanceEvidence(record, recognition.getEvidence().getRegularImageUrl());\n                        evidenceUpdatedCount++;\n                        changed = true;\n                    }\n                }\n                // Skip NOT_YET cases (rare - should be finalized in INITIAL)\n\n                if (changed) {\n                    changedRecords.add(record);\n                }\n            }\n\n            attendanceRecordRepository.saveAll(allRecords);\n\n            // Publish SSE updates for changed records\n            for (AttendanceRecord record : changedRecords) {\n                RegularAttendanceEvidence evidence = regularAttendanceEvidenceRepository\n                        .findByAttendanceRecordId(record.getId());\n                String evidenceUrl = evidence != null ? evidence.getImageUrl() : null;\n\n                tryPublishWithReview(\n                    slot.getId(),\n                    record.getStudent().getId(),\n                    \"regular\",\n                    record.getId(),\n                    record.getStatus().name().toLowerCase(),\n                    record.getMethod().name().toLowerCase(),\n                    record.getRecordedAt() != null ? record.getRecordedAt().toString() : null,\n                    evidenceUrl,\n                    record.getNeedsReview()\n                );\n            }\n        }\n\n        // Determine if we should process exam attendance based on callbackType\n        boolean shouldProcessExam = \"EXAM\".equalsIgnoreCase(callbackType) &&\n                (slotCategory == SlotCategory.LECTURE_WITH_PT || slotCategory == SlotCategory.FINAL_EXAM);\n\n        // Process exam attendance (LECTURE_WITH_PT / FINAL_EXAM)\n        if (shouldProcessExam) {\n            List<ExamAttendance> allExamRecords = examAttendanceRepository.findBySlotId(slot.getId());\n            List<ExamAttendance> changedExamRecords = new java.util.ArrayList<>();\n\n            for (ExamAttendance record : allExamRecords) {\n                Integer studentId = record.getStudent().getId();\n                boolean wasDetected = detectedStudentIds.contains(studentId);\n                boolean changed = false;\n\n                // EXAM RESCAN LOGIC:\n                // Case 1: PRESENT but NOT detected → Keep status, needsReview flag set on stop\n                if (record.getStatus() == AttendanceStatus.PRESENT && !wasDetected) {\n                    // Keep PRESENT status, no changes needed\n                    // Evidence is preserved automatically\n                }\n                // Case 2: PRESENT and IS detected → Keep PRESENT, update evidence\n                else if (record.getStatus() == AttendanceStatus.PRESENT && wasDetected) {\n                    RecognitionResultRequest.RecognitionItem recognition = findRecognitionForStudent(recognitions,\n                            studentId);\n                    if (recognition != null && recognition.getEvidence() != null\n                            && recognition.getEvidence().getExamImageUrl() != null) {\n                        updateExamAttendanceEvidence(record, recognition.getEvidence().getExamImageUrl());\n                        evidenceUpdatedCount++;\n                        changed = true;\n                    }\n                }\n                // Case 3: NOT_YET and IS detected → Keep NOT_YET, save new image\n                else if (record.getStatus() == AttendanceStatus.NOT_YET && wasDetected) {\n                    RecognitionResultRequest.RecognitionItem recognition = findRecognitionForStudent(recognitions,\n                            studentId);\n                    if (recognition != null && recognition.getEvidence() != null\n                            && recognition.getEvidence().getExamImageUrl() != null) {\n                        updateExamAttendanceEvidence(record, recognition.getEvidence().getExamImageUrl());\n                        evidenceUpdatedCount++;\n                        changed = true;\n                    }\n                    // Status stays NOT_YET\n                }\n                // Case 4: ABSENT → Protected (no changes)\n\n                if (changed) {\n                    changedExamRecords.add(record);\n                }\n            }\n\n            examAttendanceRepository.saveAll(allExamRecords);\n\n            // Publish SSE updates for changed exam records\n            for (ExamAttendance record : changedExamRecords) {\n                ExamAttendanceEvidence evidence = examAttendanceEvidenceRepository\n                        .findByExamAttendanceId(record.getId());\n                String evidenceUrl = evidence != null ? evidence.getImageUrl() : null;\n\n                tryPublishWithReview(\n                    slot.getId(),\n                    record.getStudent().getId(),\n                    \"exam\",\n                    record.getId(),\n                    record.getStatus().name().toLowerCase(),\n                    record.getMethod().name().toLowerCase(),\n                    record.getRecordedAt() != null ? record.getRecordedAt().toString() : null,\n                    evidenceUrl,\n                    record.getNeedsReview()\n                );\n            }\n        }\n\n        return Map.of(\n                \"slotId\", slot.getId(),\n                \"mode\", \"RESCAN\",\n                \"totalDetected\", detectedStudentIds.size(),\n                \"evidenceUpdatedCount\", evidenceUpdatedCount);\n    }\n\n\n    /**\n     * Find recognition item for a specific student\n     */\n    private RecognitionResultRequest.RecognitionItem findRecognitionForStudent(\n            List<RecognitionResultRequest.RecognitionItem> recognitions, Integer studentId) {\n        return recognitions.stream()\n                .filter(r -> r.getStudentUserId().equals(studentId))\n                .findFirst()\n                .orElse(null);\n    }\n\n    /**\n     * Update regular attendance evidence with new image\n     * Downloads image from recognition-service and saves locally\n     */\n    private void updateRegularAttendanceEvidence(AttendanceRecord record, String sourceImageUrl) {\n        // Download image from recognition-service\n        String filename = evidenceStorageService.extractFilenameFromUrl(sourceImageUrl);\n        String localImagePath = evidenceStorageService.downloadAndSaveEvidence(\n            sourceImageUrl, \n            record.getSlot().getId(), \n            filename\n        );\n        \n        if (localImagePath == null) {\n            logger.error(\"Failed to download evidence image from: {}\", sourceImageUrl);\n            return;\n        }\n\n        RegularAttendanceEvidence evidence = regularAttendanceEvidenceRepository\n                .findByAttendanceRecordId(record.getId());\n\n        if (evidence != null) {\n            // Delete old image if exists\n            if (evidence.getImageUrl() != null) {\n                evidenceStorageService.deleteEvidence(evidence.getImageUrl());\n            }\n            // Update with new local path\n            evidence.setImageUrl(localImagePath);\n            regularAttendanceEvidenceRepository.save(evidence);\n        } else {\n            // Create new evidence with local path\n            RegularAttendanceEvidence newEvidence = new RegularAttendanceEvidence();\n            newEvidence.setAttendanceRecord(record);\n            newEvidence.setImageUrl(localImagePath);\n            regularAttendanceEvidenceRepository.save(newEvidence);\n        }\n    }\n\n    /**\n     * Update exam attendance evidence with new image\n     * Downloads image from recognition-service and saves locally\n     */\n    private void updateExamAttendanceEvidence(ExamAttendance record, String sourceImageUrl) {\n        // Download image from recognition-service\n        String filename = evidenceStorageService.extractFilenameFromUrl(sourceImageUrl);\n        String localImagePath = evidenceStorageService.downloadAndSaveEvidence(\n            sourceImageUrl, \n            record.getSlot().getId(), \n            filename\n        );\n        \n        if (localImagePath == null) {\n            logger.error(\"Failed to download evidence image from: {}\", sourceImageUrl);\n            return;\n        }\n\n        ExamAttendanceEvidence evidence = examAttendanceEvidenceRepository\n                .findByExamAttendanceId(record.getId());\n\n        if (evidence != null) {\n            // Delete old image if exists\n            if (evidence.getImageUrl() != null) {\n                evidenceStorageService.deleteEvidence(evidence.getImageUrl());\n            }\n            // Update with new local path\n            evidence.setImageUrl(localImagePath);\n            examAttendanceEvidenceRepository.save(evidence);\n        } else {\n            // Create new evidence with local path\n            ExamAttendanceEvidence newEvidence = new ExamAttendanceEvidence();\n            newEvidence.setExamAttendance(record);\n            newEvidence.setImageUrl(localImagePath);\n            examAttendanceEvidenceRepository.save(newEvidence);\n        }\n    }\n\n    private Map<String, Object> processRecognition(RecognitionResultRequest.RecognitionItem recognition, Slot slot,\n            SlotCategory slotCategory, String callbackType) {\n        Integer studentUserId = recognition.getStudentUserId();\n        Instant timestamp = recognition.getTimestamp();\n        Short cameraId = recognition.getCameraId();\n\n        // Check if student exists and is enrolled in the slot's class\n        StudentProfile student = studentProfileRepository.findById(studentUserId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Student not found: \" + studentUserId,\n                        ErrorCode.USER_NOT_FOUND));\n\n        // TODO: Verify student is enrolled in the slot's class\n\n        Map<String, Object> result = new java.util.HashMap<>();\n        result.put(\"studentUserId\", studentUserId);\n\n        // Determine if we should process regular attendance based on callbackType\n        // For LECTURE_WITH_PT, only process regular if callbackType is \"REGULAR\"\n        boolean shouldProcessRegular = \"REGULAR\".equalsIgnoreCase(callbackType) &&\n                (slotCategory == SlotCategory.LECTURE || slotCategory == SlotCategory.LECTURE_WITH_PT);\n\n        // Process regular attendance\n        if (shouldProcessRegular) {\n            AttendanceRecord attendanceRecord = attendanceRecordRepository.findBySlotIdAndStudentUserId(slot.getId(),\n                    studentUserId);\n\n            if (attendanceRecord != null) {\n                // Defensive check: Skip if already marked present by face recognition\n                if (attendanceRecord.getStatus() == AttendanceStatus.PRESENT &&\n                        attendanceRecord.getMethod() == AttendanceMethod.AUTO) {\n                    result.put(\"status\", \"skipped\");\n                    result.put(\"reason\", \"Already marked present by face recognition\");\n                    result.put(\"currentStatus\", AttendanceStatus.PRESENT);\n                    result.put(\"details\", \"Regular attendance already present (AUTO)\");\n                } else {\n                    // ALWAYS override to PRESENT (including manual ABSENT)\n                    // This allows face recognition to override manual marks in INITIAL scan\n                    AttendanceStatus previousStatus = attendanceRecord.getStatus();\n                    attendanceRecord.setStatus(AttendanceStatus.PRESENT);\n                    attendanceRecord.setMethod(AttendanceMethod.AUTO);\n                    attendanceRecord.setRecordedAt(timestamp);\n                    attendanceRecord.setNeedsReview(false); // Clear any existing review flags\n\n                    attendanceRecordRepository.save(attendanceRecord);\n                    // Publish SSE for regular attendance\n                    tryPublish(slot.getId(), studentUserId, \"regular\", attendanceRecord.getId(),\n                            AttendanceStatus.PRESENT.name().toLowerCase(),\n                            AttendanceMethod.AUTO.name().toLowerCase(),\n                            timestamp != null ? timestamp.toString() : null, null);\n\n                    result.put(\"status\", \"updated\");\n                    result.put(\"previousStatus\", previousStatus);\n                    result.put(\"newStatus\", AttendanceStatus.PRESENT);\n                    result.put(\"details\", \"Updated regular attendance (override from \" + previousStatus + \")\");\n                }\n            } else {\n                // Create new attendance record\n                AttendanceRecord newAttendanceRecord = new AttendanceRecord();\n                newAttendanceRecord.setStudent(student.getUser());\n                newAttendanceRecord.setSlot(slot);\n                newAttendanceRecord.setStatus(AttendanceStatus.PRESENT);\n                newAttendanceRecord.setMethod(AttendanceMethod.AUTO);\n                newAttendanceRecord.setRecordedAt(timestamp);\n                newAttendanceRecord.setNeedsReview(false);\n\n                attendanceRecordRepository.save(newAttendanceRecord);\n                // Publish SSE for new regular attendance\n                tryPublish(slot.getId(), studentUserId, \"regular\", newAttendanceRecord.getId(),\n                        AttendanceStatus.PRESENT.name().toLowerCase(),\n                        AttendanceMethod.AUTO.name().toLowerCase(),\n                        timestamp != null ? timestamp.toString() : null, null);\n\n                result.put(\"status\", \"updated\");\n                result.put(\"previousStatus\", null);\n                result.put(\"newStatus\", AttendanceStatus.PRESENT);\n                result.put(\"details\", \"Created new regular attendance record\");\n            }\n        }\n\n        // Determine if we should process exam attendance based on callbackType\n        // For LECTURE_WITH_PT, only process exam if callbackType is \"EXAM\"\n        boolean shouldProcessExam = \"EXAM\".equalsIgnoreCase(callbackType) &&\n                (slotCategory == SlotCategory.LECTURE_WITH_PT || slotCategory == SlotCategory.FINAL_EXAM);\n\n        // Process exam attendance\n        if (shouldProcessExam) {\n            ExamAttendance examAttendance = examAttendanceRepository.findBySlotIdAndStudentUserId(slot.getId(),\n                    studentUserId);\n\n            if (examAttendance != null && examAttendance.getStatus() != AttendanceStatus.ABSENT) {\n                // Defensive check: Skip if already marked present by face recognition\n                if (examAttendance.getStatus() == AttendanceStatus.PRESENT &&\n                        examAttendance.getMethod() == AttendanceMethod.AUTO) {\n                    if (!result.containsKey(\"status\")) {\n                        result.put(\"status\", \"skipped\");\n                        result.put(\"reason\", \"Already marked present by face recognition\");\n                        result.put(\"currentStatus\", AttendanceStatus.PRESENT);\n                        result.put(\"details\", \"Exam attendance already present (AUTO)\");\n                    } else {\n                        // Regular attendance already processed, just note exam is also skipped\n                        String details = (String) result.get(\"details\");\n                        result.put(\"details\", details + \" (exam attendance already present)\");\n                    }\n                } else {\n                    // Update the exam attendance record\n                    AttendanceStatus previousStatus = examAttendance.getStatus();\n                    examAttendance.setStatus(AttendanceStatus.PRESENT);\n                    examAttendance.setMethod(AttendanceMethod.AUTO);\n                    examAttendance.setRecordedAt(timestamp);\n\n                    examAttendanceRepository.save(examAttendance);\n                    // Publish SSE for exam attendance update\n                    tryPublish(slot.getId(), studentUserId, \"exam\", examAttendance.getId(),\n                            AttendanceStatus.PRESENT.name().toLowerCase(),\n                            AttendanceMethod.AUTO.name().toLowerCase(),\n                            timestamp != null ? timestamp.toString() : null, null);\n\n                    if (!result.containsKey(\"status\")) {\n                        result.put(\"status\", \"updated\");\n                        result.put(\"previousStatus\", previousStatus);\n                        result.put(\"newStatus\", AttendanceStatus.PRESENT);\n                        result.put(\"details\", \"Updated exam attendance\");\n                    } else {\n                        String details = (String) result.get(\"details\");\n                        result.put(\"details\", details + \" and exam attendance\");\n                    }\n                }\n            } else if (examAttendance != null && examAttendance.getStatus() == AttendanceStatus.ABSENT) {\n                // Skip if status is already absent (manual override)\n                if (!result.containsKey(\"status\")) {\n                    result.put(\"status\", \"skipped\");\n                    result.put(\"reason\", \"Current exam status is 'absent', manual override detected\");\n                }\n            } else {\n                // Create new exam attendance record\n                ExamAttendance newExamAttendance = new ExamAttendance();\n                newExamAttendance.setStudent(student.getUser());\n                newExamAttendance.setSlot(slot);\n                newExamAttendance.setStatus(AttendanceStatus.PRESENT);\n                newExamAttendance.setMethod(AttendanceMethod.AUTO);\n                newExamAttendance.setRecordedAt(timestamp);\n\n                examAttendanceRepository.save(newExamAttendance);\n                // Publish SSE for new exam attendance\n                tryPublish(slot.getId(), studentUserId, \"exam\", newExamAttendance.getId(),\n                        AttendanceStatus.PRESENT.name().toLowerCase(),\n                        AttendanceMethod.AUTO.name().toLowerCase(),\n                        timestamp != null ? timestamp.toString() : null, null);\n\n                if (!result.containsKey(\"status\")) {\n                    result.put(\"status\", \"updated\");\n                    result.put(\"previousStatus\", null);\n                    result.put(\"newStatus\", AttendanceStatus.PRESENT);\n                    result.put(\"details\", \"Created new exam attendance record\");\n                } else {\n                    String details = (String) result.get(\"details\");\n                    result.put(\"details\", details + \" and created new exam attendance record\");\n                }\n            }\n        }\n\n        // Store evidence images if provided - download from recognition-service\n        RecognitionResultRequest.Evidence evidence = recognition.getEvidence();\n        if (evidence != null) {\n            // Store regular evidence only if processing regular attendance\n            if (shouldProcessRegular) {\n                String sourceImageUrl = evidence.getRegularImageUrl();\n                if (sourceImageUrl != null && !sourceImageUrl.isBlank()) {\n                    AttendanceRecord ar = attendanceRecordRepository.findBySlotIdAndStudentUserId(slot.getId(),\n                            studentUserId);\n                    if (ar != null && ar.getId() != null) {\n                        // Download image from recognition-service\n                        String filename = evidenceStorageService.extractFilenameFromUrl(sourceImageUrl);\n                        String localImagePath = evidenceStorageService.downloadAndSaveEvidence(\n                            sourceImageUrl, \n                            slot.getId(), \n                            filename\n                        );\n                        \n                        if (localImagePath != null) {\n                            RegularAttendanceEvidence ev = regularAttendanceEvidenceRepository\n                                    .findByAttendanceRecordId(ar.getId());\n                            if (ev == null) {\n                                ev = new RegularAttendanceEvidence();\n                                ev.setAttendanceRecord(ar);\n                            } else {\n                                // Delete old image if exists\n                                if (ev.getImageUrl() != null) {\n                                    evidenceStorageService.deleteEvidence(ev.getImageUrl());\n                                }\n                            }\n                            ev.setImageUrl(localImagePath);\n                            regularAttendanceEvidenceRepository.save(ev);\n                            // publish evidence update for regular\n                            tryPublish(slot.getId(), studentUserId, \"regular\", ar.getId(),\n                                    ar.getStatus().name().toLowerCase(),\n                                    ar.getMethod() != null ? ar.getMethod().name().toLowerCase() : null,\n                                    ar.getRecordedAt() != null ? ar.getRecordedAt().toString() : null,\n                                    localImagePath);\n                        } else {\n                            logger.error(\"Failed to download regular evidence image from: {}\", sourceImageUrl);\n                        }\n                    }\n                }\n            }\n            // Store exam evidence only if processing exam attendance\n            if (shouldProcessExam) {\n                String sourceImageUrl = evidence.getExamImageUrl();\n                if (sourceImageUrl != null && !sourceImageUrl.isBlank()) {\n                    ExamAttendance ea = examAttendanceRepository.findBySlotIdAndStudentUserId(slot.getId(),\n                            studentUserId);\n                    if (ea != null && ea.getId() != null) {\n                        // Download image from recognition-service\n                        String filename = evidenceStorageService.extractFilenameFromUrl(sourceImageUrl);\n                        String localImagePath = evidenceStorageService.downloadAndSaveEvidence(\n                            sourceImageUrl, \n                            slot.getId(), \n                            filename\n                        );\n                        \n                        if (localImagePath != null) {\n                            ExamAttendanceEvidence ev2 = examAttendanceEvidenceRepository\n                                    .findByExamAttendanceId(ea.getId());\n                            if (ev2 == null) {\n                                ev2 = new ExamAttendanceEvidence();\n                                ev2.setExamAttendance(ea);\n                            } else {\n                                // Delete old image if exists\n                                if (ev2.getImageUrl() != null) {\n                                    evidenceStorageService.deleteEvidence(ev2.getImageUrl());\n                                }\n                            }\n                            ev2.setImageUrl(localImagePath);\n                            examAttendanceEvidenceRepository.save(ev2);\n                            // publish evidence update for exam\n                            tryPublish(slot.getId(), studentUserId, \"exam\", ea.getId(),\n                                    ea.getStatus().name().toLowerCase(),\n                                    ea.getMethod() != null ? ea.getMethod().name().toLowerCase() : null,\n                                    ea.getRecordedAt() != null ? ea.getRecordedAt().toString() : null,\n                                    localImagePath);\n                        } else {\n                            logger.error(\"Failed to download exam evidence image from: {}\", sourceImageUrl);\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private void validateEditWindow(Slot slot, boolean isAssignedStaff, boolean hasManualPermission) {\n        // Convert LocalDateTime to ZonedDateTime with Vietnam timezone\n        LocalDateTime slotStartTime = slot.getStartTime();\n        ZonedDateTime slotStartTimeVN = slotStartTime.atZone(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        LocalDate slotDateVN = slotStartTimeVN.toLocalDate();\n\n        // Create cutoff at 23:59:59 Vietnam time on the slot date\n        ZonedDateTime cutoffVN = slotDateVN.atTime(23, 59, 59).atZone(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        ZonedDateTime nowVN = ZonedDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n\n        if (nowVN.isBefore(slotStartTimeVN)) {\n            throw new OperationNotAllowedException(\n                    \"Cannot edit attendance before slot start time\",\n                    ErrorCode.EDIT_BEFORE_SLOT_START);\n        }\n\n        if (nowVN.isAfter(cutoffVN)) {\n            // After cutoff: only Data Operator can edit\n            if (!hasManualPermission) {\n                throw new OperationNotAllowedException(\n                        \"Edit window has expired. Only Data Operator can edit attendance after 23:59:59 Vietnam time of slot date\",\n                        ErrorCode.EDIT_WINDOW_EXPIRED);\n            }\n        } else {\n            // Before cutoff: only assigned staff can edit\n            if (!isAssignedStaff) {\n                throw new OperationNotAllowedException(\n                        \"You are not assigned to this slot. Only assigned staff can edit attendance before the cutoff\",\n                        ErrorCode.NOT_ASSIGNED_TO_SLOT);\n            }\n        }\n    }\n\n    private boolean isValidStatusTransition(AttendanceStatus current, AttendanceStatus newStatus) {\n        // Allow any transition for manual updates\n        return true;\n    }\n\n    private void tryPublish(Integer slotId,\n                            Integer studentUserId,\n                            String kind,\n                            Long recordId,\n                            String status,\n                            String method,\n                            String recordedAt,\n                            String evidenceImageUrl) {\n        try {\n            AttendanceUpdateEvent evt = new AttendanceUpdateEvent(\n                    slotId,\n                    studentUserId,\n                    kind,\n                    recordId,\n                    status,\n                    method,\n                    recordedAt,\n                    evidenceImageUrl\n            );\n            sseHub.publishAttendanceUpdate(slotId, evt);\n        } catch (Exception e) {\n            logger.warn(\"Failed to publish SSE attendance.update: {}\", e.getMessage());\n        }\n    }\n\n    /**\n     * Publish SSE update with needsReview field (for RESCAN mode)\n     */\n    private void tryPublishWithReview(Integer slotId,\n                                      Integer studentUserId,\n                                      String kind,\n                                      Long recordId,\n                                      String status,\n                                      String method,\n                                      String recordedAt,\n                                      String evidenceImageUrl,\n                                      Boolean needsReview) {\n        try {\n            AttendanceUpdateEvent evt = new AttendanceUpdateEvent(\n                    slotId,\n                    studentUserId,\n                    kind,\n                    recordId,\n                    status,\n                    method,\n                    recordedAt,\n                    evidenceImageUrl,\n                    needsReview\n            );\n            sseHub.publishAttendanceUpdate(slotId, evt);\n        } catch (Exception e) {\n            logger.warn(\"Failed to publish SSE attendance.update with needsReview: {}\", e.getMessage());\n        }\n    }\n\n    /**\n     * Apply review flags after RESCAN session stops\n     * Called from SlotSessionService.stopSession() with recognized student IDs from Python response\n     *\n     * @param slot The slot being rescanned\n     * @param detectedStudentIds Set of student IDs detected during RESCAN\n     * @return Map with statistics (presentNotDetected, absentDetected)\n     */\n    public Map<String, Object> applyRescanReviewFlags(Slot slot, Set<Integer> detectedStudentIds) {\n        logger.info(\"Applying RESCAN review flags: slotId={}, detectedCount={}\", slot.getId(), detectedStudentIds.size());\n\n        List<AttendanceRecord> allRecords = attendanceRecordRepository.findBySlotId(slot.getId());\n\n        int presentNotDetectedCount = 0;\n        int absentDetectedCount = 0;\n        int presentConfirmedCount = 0;\n\n        for (AttendanceRecord record : allRecords) {\n            Integer studentId = record.getStudent().getId();\n            boolean wasDetected = detectedStudentIds.contains(studentId);\n            boolean changed = false;\n\n            // Case 1: PRESENT but NOT detected → Set needsReview=TRUE\n            if (record.getStatus() == AttendanceStatus.PRESENT && !wasDetected) {\n                if (!Boolean.TRUE.equals(record.getNeedsReview())) {\n                    record.setNeedsReview(true);\n                    presentNotDetectedCount++;\n                    changed = true;\n                }\n            }\n            // Case 2: PRESENT and detected → Clear needsReview\n            else if (record.getStatus() == AttendanceStatus.PRESENT && wasDetected) {\n                if (Boolean.TRUE.equals(record.getNeedsReview())) {\n                    record.setNeedsReview(false);\n                    changed = true;\n                }\n                presentConfirmedCount++;\n            }\n            // Case 3: ABSENT but detected → Set needsReview=TRUE\n            else if (record.getStatus() == AttendanceStatus.ABSENT && wasDetected) {\n                if (!Boolean.TRUE.equals(record.getNeedsReview())) {\n                    record.setNeedsReview(true);\n                    absentDetectedCount++;\n                    changed = true;\n                }\n            }\n\n            // Publish SSE update if changed\n            if (changed) {\n                RegularAttendanceEvidence evidence = regularAttendanceEvidenceRepository\n                        .findByAttendanceRecordId(record.getId());\n                String evidenceUrl = evidence != null ? evidence.getImageUrl() : null;\n\n                tryPublishWithReview(\n                    slot.getId(),\n                    record.getStudent().getId(),\n                    \"regular\",\n                    record.getId(),\n                    record.getStatus().name().toLowerCase(),\n                    record.getMethod().name().toLowerCase(),\n                    record.getRecordedAt() != null ? record.getRecordedAt().toString() : null,\n                    evidenceUrl,\n                    record.getNeedsReview()\n                );\n            }\n        }\n\n        attendanceRecordRepository.saveAll(allRecords);\n\n        Map<String, Object> result = new java.util.HashMap<>();\n        result.put(\"presentNotDetected\", presentNotDetectedCount);\n        result.put(\"absentDetected\", absentDetectedCount);\n        result.put(\"presentConfirmed\", presentConfirmedCount);\n        result.put(\"totalProcessed\", allRecords.size());\n\n        logger.info(\"RESCAN review flags applied: {}\", result);\n\n        return result;\n    }\n\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\AuthenticationService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/AuthenticationService.java",
      "filename": "AuthenticationService.java",
      "size_bytes": 10060,
      "lines": 205,
      "last_modified": "2025-11-11T23:19:47.935943",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.Constant;\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.dto.request.LoginGoogleRequest;\nimport com.fuacs.backend.dto.request.LoginRequest;\nimport com.fuacs.backend.dto.request.PasswordForgotRequest;\nimport com.fuacs.backend.dto.request.PasswordResetRequest;\nimport com.fuacs.backend.dto.request.PasswordUpdateRequest;\nimport com.fuacs.backend.dto.request.RefreshTokenRequest;\nimport com.fuacs.backend.dto.response.TokenResponse;\nimport com.fuacs.backend.entity.PasswordResetToken;\nimport com.fuacs.backend.entity.Permission;\nimport com.fuacs.backend.entity.Role;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.PasswordResetTokenRepository;\nimport com.fuacs.backend.repository.PermissionRepository;\nimport com.fuacs.backend.repository.RoleRepository;\nimport com.fuacs.backend.repository.UserRepository;\nimport com.fuacs.backend.util.TokenProviderUtil;\nimport com.google.api.client.googleapis.auth.oauth2.GoogleIdToken;\nimport com.google.api.client.googleapis.auth.oauth2.GoogleIdTokenVerifier;\nimport com.google.api.client.http.javanet.NetHttpTransport;\nimport com.google.api.client.json.gson.GsonFactory;\nimport com.nimbusds.jwt.JWTClaimsSet;\nimport com.nimbusds.jwt.SignedJWT;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.security.access.AccessDeniedException;\nimport org.springframework.security.authentication.BadCredentialsException;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.oauth2.server.resource.InvalidBearerTokenException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.text.ParseException;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n@Service\npublic class AuthenticationService {\n    private final RoleRepository roleRepository;\n    private final UserRepository userRepository;\n    private final TokenProviderUtil tokenProvider;\n    private final PasswordEncoder passwordEncoder;\n    private final PermissionRepository permissionRepository;\n    private final EmailService emailService;\n    private final PasswordResetTokenRepository passwordResetTokenRepository;\n\n    @Value(\"${google.client-id}\")\n    private String googleClientId;\n\n    public AuthenticationService(RoleRepository roleRepository,\n                                 UserRepository userRepository,\n                                 TokenProviderUtil tokenProvider,\n                                 PasswordEncoder passwordEncoder,\n                                 PermissionRepository permissionRepository,\n                                 EmailService emailService,\n                                 PasswordResetTokenRepository passwordResetTokenRepository) {\n        this.roleRepository = roleRepository;\n        this.userRepository = userRepository;\n        this.tokenProvider = tokenProvider;\n        this.passwordEncoder = passwordEncoder;\n        this.permissionRepository = permissionRepository;\n        this.emailService = emailService;\n        this.passwordResetTokenRepository = passwordResetTokenRepository;\n    }\n\n    @Transactional\n    public TokenResponse login(LoginRequest request) {\n        //TODO: login only for student and lecturer\n        User user = userRepository.findByUsername(request.getUsername())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Username not found: \" + request.getUsername(), ErrorCode.USERNAME_NOT_FOUND));\n        validateUserActive(user);\n        if (!passwordEncoder.matches(request.getPassword(), user.getPasswordHash())) {\n            throw new BadCredentialsException(\"Invalid password\");\n        }\n        return buildTokenResponse(user);\n    }\n\n    @Transactional\n    public TokenResponse googleLogin(LoginGoogleRequest request) {\n        try {\n            GoogleIdTokenVerifier verifier = new GoogleIdTokenVerifier.Builder(\n                    new NetHttpTransport(),\n                    GsonFactory.getDefaultInstance())\n                    .setAudience(Collections.singletonList(googleClientId))\n                    .build();\n\n            GoogleIdToken idToken = verifier.verify(request.getToken());\n            if (idToken == null) {\n                throw new InvalidBearerTokenException(\"Invalid or expired Google token\");\n            }\n            String email = idToken.getPayload().getEmail();\n            if (email == null || email.isBlank()) {\n                // Trả về 404 nếu email không có trong token\n                throw new ResourceNotFoundException(\"Email not found in Google token payload\", ErrorCode.EMAIL_NOT_FOUND);\n            }\n            //    Nếu không tìm thấy -> ResourceNotFoundException (Mapped to 404)\n            User user = userRepository.findByEmail(email)\n                    .orElseThrow(() -> new ResourceNotFoundException(\"User not found with email: \" + email, ErrorCode.EMAIL_NOT_FOUND));\n            //    Nếu không hoạt động -> Exception (Mapped to 403)\n            validateUserActive(user);\n            // Trả về token cho người dùng đã xác thực và đang hoạt động\n            return buildTokenResponse(user);\n        } catch (GeneralSecurityException | IOException ex) {\n            throw new InvalidBearerTokenException(\"Failed to verify Google token: \" + ex.getMessage());\n        }\n    }\n\n    @Transactional\n    public TokenResponse refreshToken(RefreshTokenRequest request) {\n        try {\n            SignedJWT signedJWT = SignedJWT.parse(request.getRefreshToken());\n\n            if (!tokenProvider.isValidRefreshToken(signedJWT)) {\n                throw new IllegalArgumentException(\"Invalid refresh token\");\n            }\n\n            JWTClaimsSet claims = signedJWT.getJWTClaimsSet();\n            int userId = Integer.parseInt(String.valueOf(claims.getClaim(Constant.USER_ID)));\n\n            User user = userRepository.findById(userId)\n                    .orElseThrow(() -> new ResourceNotFoundException(\"User ID not found: \" + userId, ErrorCode.USER_ID_NOT_FOUND));\n\n            validateUserActive(user);\n            return buildTokenResponse(user);\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(\"Malformed refresh token \" + e.getMessage());\n        }\n    }\n\n    public String forgotPassword(PasswordForgotRequest request) {\n        User user = userRepository.findByEmail(request.getEmail())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Email not found: \" + request.getEmail(), ErrorCode.EMAIL_NOT_FOUND));\n        validateUserActive(user);\n        String email = user.getEmail();\n        String token = tokenProvider.createResetPasswordToken(email);\n        emailService.sendPasswordResetEmail(email, token);\n        return \"If the email exists, a password reset link has been sent.\";\n    }\n\n    @Transactional\n    public String resetPassword(PasswordResetRequest request) {\n        if (!request.newPasswordsMatch()) {\n            throw new IllegalArgumentException(\"New password and confirm password do not match\");\n        }\n        PasswordResetToken resetToken = passwordResetTokenRepository.findByTokenHash(request.getToken())\n                .orElseThrow(() -> new IllegalArgumentException(\"Invalid or expired reset token\"));\n        String email = resetToken.getEmail();\n        User user = userRepository.findByEmail(email)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Email not found: \" + email, ErrorCode.EMAIL_NOT_FOUND));\n        validateUserActive(user);\n        user.setPasswordHash(passwordEncoder.encode(request.getNewPassword()));\n        userRepository.save(user);\n        passwordResetTokenRepository.delete(resetToken);\n        return \"Reset password successfully.\";\n    }\n\n    @Transactional\n    public String updatePassword(Integer id, PasswordUpdateRequest request) {\n        if (!request.newPasswordsMatch()) {\n            throw new IllegalArgumentException(\"New password and confirm password do not match\");\n        }\n        User user = userRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"User id not found: \" + id, ErrorCode.USER_ID_NOT_FOUND));\n        validateUserActive(user);\n        if (!passwordEncoder.matches(request.getOldPassword(), user.getPasswordHash())) {\n            throw new BadCredentialsException(\"Invalid current password\");\n        }\n        user.setPasswordHash(passwordEncoder.encode(request.getNewPassword()));\n        userRepository.save(user);\n        return \"Update password successfully.\";\n    }\n\n    private TokenResponse buildTokenResponse(User user) {\n        Set<Role> roles = user.getRoles() != null ? user.getRoles() : Set.of();\n        Set<Permission> permissions = roles.stream()\n                .flatMap(role -> role.getPermissions().stream())\n                .collect(Collectors.toSet());\n        Set<String> roleNames = roles.stream()\n                .map(Role::getName)\n                .collect(Collectors.toSet());\n        String accessToken = tokenProvider.createAccessToken(user, permissions);\n        String refreshToken = tokenProvider.createRefreshToken(user.getId());\n        return new TokenResponse(\n                accessToken,\n                refreshToken,\n                Constant.BEARER,\n                user.getFullName(),\n                user.getUsername(),\n                roleNames,\n                user.getId()\n        );\n    }\n\n    private void validateUserActive(User user) {\n        if (!Boolean.TRUE.equals(user.getActive())) {\n            throw new AccessDeniedException(\"User account is inactive\");\n        }\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\BulkPhotoUploadService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/BulkPhotoUploadService.java",
      "filename": "BulkPhotoUploadService.java",
      "size_bytes": 11151,
      "lines": 291,
      "last_modified": "2025-11-11T18:02:59.210974",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.dto.request.BulkPhotoUploadCsvRow;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.dto.response.PythonEmbeddingResponse;\nimport com.fuacs.backend.entity.StudentProfile;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.nio.file.Path;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n@Service\npublic class BulkPhotoUploadService {\n\n    private static final Logger logger = LoggerFactory.getLogger(BulkPhotoUploadService.class);\n\n    private final ZipFileService zipFileService;\n    private final CsvParserService csvParserService;\n    private final StudentPhotoService studentPhotoService;\n    private final PythonBackendClient pythonBackendClient;\n    private final FaceEmbeddingService faceEmbeddingService;\n    private final StudentProfileRepository studentProfileRepository;\n\n    // Thread pool cho parallel processing\n    private final ExecutorService executorService;\n\n    public BulkPhotoUploadService(\n            ZipFileService zipFileService,\n            CsvParserService csvParserService,\n            StudentPhotoService studentPhotoService,\n            PythonBackendClient pythonBackendClient,\n            FaceEmbeddingService faceEmbeddingService,\n            StudentProfileRepository studentProfileRepository) {\n        this.zipFileService = zipFileService;\n        this.csvParserService = csvParserService;\n        this.studentPhotoService = studentPhotoService;\n        this.pythonBackendClient = pythonBackendClient;\n        this.faceEmbeddingService = faceEmbeddingService;\n        this.studentProfileRepository = studentProfileRepository;\n\n        // Thread pool: 10 concurrent tasks\n        this.executorService = Executors.newFixedThreadPool(10);\n    }\n\n    /**\n     * Main orchestration method - NO @Transactional để partial success work\n     */\n    public ImportResultDTO processBulkUpload(\n            MultipartFile csvFile,\n            MultipartFile zipFile,\n            String modeStr) {\n\n        logger.info(\"Starting bulk photo upload with mode: {}\", modeStr);\n\n        // Parse mode\n        ImportMode mode;\n        try {\n            mode = ImportMode.fromString(modeStr);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), ErrorCode.INVALID_IMPORT_MODE);\n        }\n\n        Path tempDir = null;\n\n        try {\n            // 1. Extract ZIP to temp\n            tempDir = zipFileService.extractZipToTemp(zipFile);\n            Map<String, Path> imageFiles = zipFileService.listImageFiles(tempDir);\n\n            // 2. Parse CSV\n            List<BulkPhotoUploadCsvRow> csvRows = csvParserService.parseBulkPhotoCsv(csvFile);\n\n            // 3. Deduplicate CSV rows by roll_number\n            Map<String, BulkPhotoUploadCsvRow> uniqueRows = deduplicateRows(csvRows);\n\n            logger.info(\"Processing {} unique students\", uniqueRows.size());\n\n            // 4. Process in parallel với CompletableFuture\n            List<CompletableFuture<ProcessResult>> futures = new ArrayList<>();\n\n            for (Map.Entry<String, BulkPhotoUploadCsvRow> entry : uniqueRows.entrySet()) {\n                BulkPhotoUploadCsvRow row = entry.getValue();\n\n                CompletableFuture<ProcessResult> future = CompletableFuture.supplyAsync(\n                    () -> processOneStudentSafe(row, imageFiles, mode),\n                    executorService\n                );\n\n                futures.add(future);\n            }\n\n            // 5. Wait for all tasks to complete\n            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();\n\n            // 6. Aggregate results\n            int successCount = 0;\n            List<ImportErrorDTO> errors = new ArrayList<>();\n\n            for (CompletableFuture<ProcessResult> future : futures) {\n                try {\n                    ProcessResult result = future.get();\n                    if (result.success) {\n                        successCount++;\n                    } else {\n                        errors.add(new ImportErrorDTO(\n                            result.rowNumber,\n                            result.errorCode,\n                            result.errorMessage\n                        ));\n                    }\n                } catch (Exception e) {\n                    logger.error(\"Unexpected error getting result\", e);\n                }\n            }\n\n            logger.info(\"Bulk upload completed: {} successful, {} failed\", successCount, errors.size());\n\n            return new ImportResultDTO(successCount, errors.size(), errors);\n\n        } catch (Exception e) {\n            logger.error(\"Bulk upload failed\", e);\n            throw new RuntimeException(\"Bulk upload failed: \" + e.getMessage());\n\n        } finally {\n            // 7. Cleanup temp directory\n            if (tempDir != null) {\n                zipFileService.cleanupTempDirectory(tempDir);\n            }\n        }\n    }\n\n    /**\n     * Deduplicate CSV rows by roll_number\n     * Keep first occurrence of each roll_number\n     */\n    private Map<String, BulkPhotoUploadCsvRow> deduplicateRows(\n            List<BulkPhotoUploadCsvRow> csvRows) {\n\n        Map<String, BulkPhotoUploadCsvRow> uniqueRows = new LinkedHashMap<>();\n\n        for (BulkPhotoUploadCsvRow row : csvRows) {\n            // Keep first occurrence (putIfAbsent)\n            uniqueRows.putIfAbsent(row.getRollNumber(), row);\n        }\n\n        return uniqueRows;\n    }\n\n    /**\n     * Wrapper để catch exceptions và return ProcessResult\n     */\n    private ProcessResult processOneStudentSafe(\n            BulkPhotoUploadCsvRow row,\n            Map<String, Path> imageFiles,\n            ImportMode mode) {\n        try {\n            processOneStudent(row, imageFiles, mode);\n            return ProcessResult.success(row.getRowNumber());\n\n        } catch (ResourceNotFoundException e) {\n            logger.warn(\"Student not found: {}\", row.getRollNumber());\n            return ProcessResult.failure(\n                row.getRowNumber(),\n                ErrorCode.STUDENT_NOT_FOUND,\n                \"Student not found: \" + row.getRollNumber()\n            );\n\n        } catch (BadRequestException e) {\n            logger.warn(\"Validation failed for {}: {}\", row.getRollNumber(), e.getMessage());\n            return ProcessResult.failure(\n                row.getRowNumber(),\n                e.getErrorCode() != null ? e.getErrorCode().toString() : \"VALIDATION_ERROR\",\n                e.getMessage()\n            );\n\n        } catch (Exception e) {\n            logger.error(\"Unexpected error processing {}: {}\", row.getRollNumber(), e.getMessage(), e);\n            return ProcessResult.failure(\n                row.getRowNumber(),\n                \"PROCESSING_ERROR\",\n                \"Unexpected error: \" + e.getMessage()\n            );\n        }\n    }\n\n    /**\n     * Process single student - separate transaction\n     * Flow: Find student → Validate image → Check mode → Save photo → Generate embedding → Update DB\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneStudent(\n            BulkPhotoUploadCsvRow row,\n            Map<String, Path> imageFiles,\n            ImportMode mode) throws Exception {\n\n        String rollNumber = row.getRollNumber();\n        String imageFilename = row.getImageFilename();\n\n        // 1. Find student by roll_number (check student exists first)\n        StudentProfile student = studentProfileRepository.findByRollNumber(rollNumber);\n        if (student == null) {\n            throw new ResourceNotFoundException(\n                \"Student not found: \" + rollNumber,\n                ErrorCode.STUDENT_NOT_FOUND\n            );\n        }\n\n        Integer userId = student.getUserId();\n\n        // 2. Validate image file exists in ZIP\n        Path imagePath = imageFiles.get(imageFilename);\n        if (imagePath == null) {\n            throw new BadRequestException(\n                \"Image file not found in ZIP: \" + imageFilename,\n                ErrorCode.IMAGE_FILE_NOT_FOUND_IN_ZIP\n            );\n        }\n\n        // 3. Check mode: AddOnly → skip nếu đã có photo\n        if (mode == ImportMode.ADD_ONLY && studentPhotoService.hasExistingPhoto(userId)) {\n            throw new BadRequestException(\n                \"Student already has photo (AddOnly mode): \" + rollNumber,\n                ErrorCode.STUDENT_ALREADY_HAS_PHOTO\n            );\n        }\n\n        // 4. Save photo to user folder\n        String baseUrl = studentPhotoService.savePhotoToUserFolder(imagePath, userId, rollNumber);\n\n        // 5. Update student_profiles.base_url\n        studentPhotoService.updateStudentProfilePhoto(userId, baseUrl);\n\n        // 6. Generate embedding via Python service\n        // submissionId = userId (for logging purpose)\n        PythonEmbeddingResponse embeddingResp = pythonBackendClient.generateEmbedding(\n            imagePath,\n            userId\n        );\n\n        if (embeddingResp.getData() == null || embeddingResp.getData().getEmbeddingVector() == null) {\n            throw new BadRequestException(\n                \"Failed to generate embedding for \" + rollNumber,\n                ErrorCode.EMBEDDING_GENERATION_FAILED\n            );\n        }\n\n        // 7. Save embedding to face_embeddings table\n        float[] embeddingVector = embeddingResp.getData().getEmbeddingVector();\n        faceEmbeddingService.saveEmbedding(userId, embeddingVector);\n\n        logger.info(\"Successfully processed student: {} (userId={})\", rollNumber, userId);\n    }\n\n    /**\n     * Helper class để store processing result\n     */\n    private static class ProcessResult {\n        boolean success;\n        int rowNumber;\n        String errorCode;\n        String errorMessage;\n\n        static ProcessResult success(int rowNumber) {\n            ProcessResult r = new ProcessResult();\n            r.success = true;\n            r.rowNumber = rowNumber;\n            return r;\n        }\n\n        static ProcessResult failure(int rowNumber, String errorCode, String errorMessage) {\n            ProcessResult r = new ProcessResult();\n            r.success = false;\n            r.rowNumber = rowNumber;\n            r.errorCode = errorCode;\n            r.errorMessage = errorMessage;\n            return r;\n        }\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\CameraService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/CameraService.java",
      "filename": "CameraService.java",
      "size_bytes": 16944,
      "lines": 370,
      "last_modified": "2025-11-21T19:16:59.613405",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.dto.mapper.CameraMapper;\nimport com.fuacs.backend.dto.mapper.RoomMapper;\nimport com.fuacs.backend.dto.request.CameraCreateRequest;\nimport com.fuacs.backend.dto.request.CameraSearchBaseRequest;\nimport com.fuacs.backend.dto.request.CameraUpdateRequest;\nimport com.fuacs.backend.dto.request.CameraCsvRow;\nimport com.fuacs.backend.dto.response.CameraDTO;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.entity.Camera;\nimport com.fuacs.backend.entity.Room;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.CameraRepository;\nimport com.fuacs.backend.repository.RoomRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Service xử lý business logic cho Camera (camera IP trong phòng).\n * Cung cấp các chức năng:\n * - Search: Lấy danh sách camera với filters như search keyword, isActive, roomId\n * - CRUD: Tạo, đọc, cập nhật, xóa camera với validation đầy đủ\n * - CSV Import: Nhập camera hàng loạt với chiến lược thành công một phần\n *\n * Tất cả thao tác thay đổi dữ liệu đều chạy trong transaction để đảm bảo tính nhất quán.\n *\n * @see Camera\n * @see CameraDTO\n * @see CameraRepository\n */\n@Service\npublic class CameraService {\n\n    private static final Logger log = LoggerFactory.getLogger(CameraService.class);\n\n    private final CameraRepository cameraRepository;\n    private final RoomRepository roomRepository;\n    private final CameraMapper cameraMapper;\n    private final RoomMapper roomMapper;\n    private final CsvParserService csvParserService;\n\n    public CameraService(CameraRepository cameraRepository,\n                         RoomRepository roomRepository,\n                         CameraMapper cameraMapper,\n                         RoomMapper roomMapper,\n                         CsvParserService csvParserService) {\n        this.cameraRepository = cameraRepository;\n        this.roomRepository = roomRepository;\n        this.cameraMapper = cameraMapper;\n        this.roomMapper = roomMapper;\n        this.csvParserService = csvParserService;\n    }\n\n    /**\n     * Tìm kiếm camera với filters (search keyword, isActive, roomId, pagination, sorting).\n     *\n     * @param request Chứa filters và pagination\n     * @return Danh sách CameraDTO kèm thông tin phòng\n     */\n    public List<CameraDTO> search(CameraSearchBaseRequest request) {\n        // Gọi repository search - hỗ trợ filters: keyword (name/rtspUrl), isActive, roomId, sorting\n        // Vd: search=\"301\", isActive=true → CAM-301-Front, CAM-301-Back\n        return new ArrayList<>(cameraRepository.search(request));\n    }\n\n    /**\n     * Đếm tổng số camera thỏa filters (dùng tính total pages cho pagination).\n     *\n     * @param request Chứa filters (không bao gồm pagination)\n     * @return Tổng số camera\n     */\n    public Long count(CameraSearchBaseRequest request) {\n        // Vd: 25 cameras active, pageSize=10 → totalPages = 3\n        return cameraRepository.count(request);\n    }\n\n    /**\n     * Tìm camera theo ID kèm thông tin phòng.\n     *\n     * @param id ID camera\n     * @return CameraDTO với room info\n     * @throws ResourceNotFoundException nếu không tìm thấy\n     */\n    @Transactional(readOnly = true)\n    public CameraDTO findById(Short id) {\n        Camera camera = cameraRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Camera not found: \" + id, ErrorCode.CAMERA_NOT_FOUND));\n\n        // Map entity → DTO và set room info\n        // Vd: camera ID=1 → {id:1, name:\"CAM-301-Front\", room:{id:5, name:\"301\"}}\n        CameraDTO cameraDTO = cameraMapper.toDTO(camera);\n        cameraDTO.setRoom(roomMapper.toDTO(camera.getRoom()));\n        return cameraDTO;\n    }\n\n    /**\n     * Lấy tất cả camera trong một phòng cụ thể.\n     *\n     * @param roomId ID phòng\n     * @return Danh sách CameraDTO trong phòng (có thể rỗng)\n     */\n    public List<CameraDTO> findByRoomId(Short roomId) {\n        // Vd: phòng 301 (roomId=5) có 3 cameras → CAM-301-Front, CAM-301-Back, CAM-301-Side\n        List<Camera> cameras = cameraRepository.findByRoom_Id(roomId);\n        return cameraMapper.toDTO(cameras);\n    }\n\n    /**\n     * Tạo camera mới (kiểm tra room tồn tại, name unique, rtspUrl unique).\n     *\n     * @param request Chứa name, rtspUrl, roomId\n     * @return CameraDTO mới với ID\n     * @throws ResourceNotFoundException nếu room không tồn tại\n     * @throws ResourceExistsException nếu name hoặc rtspUrl trùng\n     */\n    @Transactional\n    public CameraDTO create(CameraCreateRequest request) {\n        // Kiểm tra room tồn tại - vd: roomId=999 không tồn tại → throw\n        Room room = roomRepository.findById(request.getRoomId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Room not found: \" + request.getRoomId(), ErrorCode.ROOM_NOT_FOUND));\n\n        // Kiểm tra name unique - vd: \"CAM-301-Front\" đã có → throw\n        if (cameraRepository.existsByName(request.getName())) {\n            throw new ResourceExistsException(\"Camera name exists: \" + request.getName(), ErrorCode.CAMERA_NAME_EXISTS);\n        }\n\n        // Kiểm tra rtspUrl unique - vd: \"rtsp://192.168.1.100:554/stream1\" đã có → throw\n        if (cameraRepository.existsByRtspUrl(request.getRtspUrl())) {\n            throw new ResourceExistsException(\"RTSP URL exists: \" + request.getRtspUrl(), ErrorCode.RTSP_URL_EXISTS);\n        }\n\n        Camera camera = cameraMapper.toEntity(request);\n        camera.setRoom(room);\n        Camera savedCamera = cameraRepository.save(camera);\n\n        CameraDTO cameraDTO = cameraMapper.toDTO(savedCamera);\n        cameraDTO.setRoom(roomMapper.toDTO(room));\n        return cameraDTO;\n    }\n\n    /**\n     * Cập nhật camera (kiểm tra name/rtspUrl unique khi đổi).\n     *\n     * @param id ID camera\n     * @param request Chứa name, rtspUrl, roomId, isActive\n     * @return CameraDTO đã cập nhật\n     * @throws ResourceNotFoundException nếu camera hoặc room không tìm thấy\n     * @throws ResourceExistsException nếu name/rtspUrl mới trùng camera khác\n     */\n    @Transactional\n    public CameraDTO update(Short id, CameraUpdateRequest request) {\n        Camera existing = cameraRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Camera not found: \" + id, ErrorCode.CAMERA_NOT_FOUND));\n\n        // Nếu đổi name → kiểm tra unique (vd: CAM-301→CAM-302, check CAM-302 chưa tồn tại)\n        if (!existing.getName().equals(request.getName())) {\n            if (cameraRepository.existsByNameAndIdNot(request.getName(), id)) {\n                throw new ResourceExistsException(\"Camera name already exists: \" + request.getName(), ErrorCode.CAMERA_NAME_EXISTS);\n            }\n        }\n\n        // Nếu đổi rtspUrl → kiểm tra unique\n        if (!existing.getRtspUrl().equals(request.getRtspUrl())) {\n            if (cameraRepository.existsByRtspUrlAndIdNot(request.getRtspUrl(), id)) {\n                throw new ResourceExistsException(\"RTSP URL already exists: \" + request.getRtspUrl(), ErrorCode.RTSP_URL_EXISTS);\n            }\n        }\n\n        // Kiểm tra room mới tồn tại\n        Room room = roomRepository.findById(request.getRoomId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Room not found: \" + request.getRoomId(), ErrorCode.ROOM_NOT_FOUND));\n\n        cameraMapper.updateCameraFromRequest(request, existing);\n        existing.setRoom(room);\n        Camera savedCamera = cameraRepository.save(existing);\n\n        CameraDTO cameraDTO = cameraMapper.toDTO(savedCamera);\n        cameraDTO.setRoom(roomMapper.toDTO(room));\n        return cameraDTO;\n    }\n\n    /**\n     * Xóa camera (hard delete - kiểm tra không có active slot, FK constraints).\n     *\n     * @param id ID camera\n     * @throws ResourceNotFoundException nếu không tìm thấy\n     * @throws OperationNotAllowedException nếu có active slot hoặc FK violation\n     */\n    @Transactional\n    public void delete(Short id) {\n        if (!cameraRepository.existsById(id)) {\n            throw new ResourceNotFoundException(\"Camera not found: \" + id, ErrorCode.CAMERA_NOT_FOUND);\n        }\n\n        // Không cho xóa nếu phòng có active slot - vd: phòng 301 có slot 21/12 → phải xóa slot trước\n        long activeSlots = cameraRepository.countActiveSlotsByCameraId(id, LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\")));\n        if (activeSlots > 0) {\n            throw new OperationNotAllowedException(\"Cannot delete camera with active slots\", ErrorCode.CAMERA_HAS_ACTIVE_SLOTS);\n        }\n\n        // Xóa - nếu bị FK constraint (vd: camera bị tham chiếu) → throw exception\n        try {\n            cameraRepository.deleteById(id);\n        } catch (DataIntegrityViolationException e) {\n            throw new OperationNotAllowedException(\"Cannot delete camera. It is currently in use by other records.\", ErrorCode.FOREIGN_KEY_CONSTRAINT_VIOLATION);\n        }\n    }\n\n    /**\n     * Import camera từ CSV hàng loạt (partial success strategy).\n     * Modes: ADD_ONLY (bỏ qua trùng) | ADD_AND_UPDATE (upsert).\n     *\n     * @param file CSV file (format: name, rtspUrl, room_name)\n     * @param modeStr \"add_only\" hoặc \"add_and_update\"\n     * @return ImportResultDTO với successCount, failureCount, errors\n     * @throws BadRequestException nếu mode invalid hoặc file lỗi\n     */\n    public ImportResultDTO importFromCsv(MultipartFile file, String modeStr) {\n        // Parse mode string → ImportMode enum\n        ImportMode mode = ImportMode.fromString(modeStr);\n\n        // Parse CSV file → List<CameraCsvRow>\n        List<CameraCsvRow> rows;\n        try {\n            rows = csvParserService.parseCameraCsv(file);\n        } catch (Exception e) {\n            log.error(\"Failed to parse Camera CSV file\", e);\n            throw new BadRequestException(\"Failed to parse CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n        // Deduplicate theo name (giữ dòng đầu, bỏ dòng sau) - vd: dòng 5,12,45 cùng \"CAM-301\" → giữ dòng 5\n        Map<String, CameraCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (CameraCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getUniqueKey(), row);\n        }\n        // Xử lý từng dòng riêng biệt (partial success: lỗi dòng này không ảnh hưởng dòng khác)\n        // Vd: 10 dòng → 7 thành công, 3 lỗi → result: successCount=7, errors=[3 lỗi chi tiết]\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (CameraCsvRow row : uniqueRows.values()) {\n            try {\n                // processOneCameraRow chạy trong transaction riêng (REQUIRES_NEW)\n                processOneCameraRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()));\n            }\n        }\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Xử lý 1 dòng CSV trong transaction riêng (REQUIRES_NEW).\n     * Logic: ADD_ONLY (skip existing) | ADD_AND_UPDATE (upsert).\n     *\n     * @param row CameraCsvRow (name, rtspUrl, room_name)\n     * @param mode ADD_ONLY hoặc ADD_AND_UPDATE\n     * @throws BadRequestException nếu row invalid hoặc room không tồn tại\n     * @throws ResourceExistsException nếu ADD_ONLY và name đã tồn tại, hoặc rtspUrl trùng\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneCameraRow(CameraCsvRow row, ImportMode mode) {\n        // Validate row - vd: name rỗng → throw BadRequestException\n        if (!row.isValid()) {\n            throw new BadRequestException(\"Invalid row data at row \" + row.getRowNumber(),\n                    ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Lookup room by name - vd: room_name=\"301\" → tìm room có name=\"301\"\n        Room room = roomRepository.findByName(row.getRoomName());\n        if (room == null) {\n            throw new ResourceNotFoundException(\"Room not found: \" + row.getRoomName(),\n                    ErrorCode.ROOM_NOT_FOUND);\n        }\n\n        // Check camera đã tồn tại chưa (dựa vào name)\n        Camera existing = cameraRepository.findByName(row.getName());\n\n        if (existing != null) {\n            // Đã tồn tại → kiểm tra mode\n            if (mode == ImportMode.ADD_ONLY) {\n                // ADD_ONLY: skip existing - vd: CAM-302-Front đã có → throw để bỏ qua dòng này\n                throw new ResourceExistsException(\n                        \"Camera name already exists: \" + row.getName(),\n                        ErrorCode.CAMERA_NAME_EXISTS);\n            }\n\n            // ADD_AND_UPDATE: update existing\n            // Kiểm tra rtspUrl unique nếu thay đổi\n            if (!existing.getRtspUrl().equals(row.getRtspUrl())) {\n                if (cameraRepository.existsByRtspUrlAndIdNot(row.getRtspUrl(), existing.getId())) {\n                    throw new ResourceExistsException(\n                            \"RTSP URL already exists: \" + row.getRtspUrl(),\n                            ErrorCode.RTSP_URL_EXISTS);\n                }\n            }\n\n            // Update - vd: CAM-302 có rtspUrl=\"rtsp://old\" → update thành rtspUrl mới từ CSV\n            existing.setRtspUrl(row.getRtspUrl());\n            existing.setRoom(room);\n            if (row.getIsActive() != null) {\n                existing.setActive(row.getIsActive());\n            }\n            existing.setUpdatedAt(Instant.now());\n            cameraRepository.save(existing);\n        } else {\n            // Chưa tồn tại → tạo mới\n            // Kiểm tra rtspUrl unique\n            if (cameraRepository.existsByRtspUrl(row.getRtspUrl())) {\n                throw new ResourceExistsException(\n                        \"RTSP URL already exists: \" + row.getRtspUrl(),\n                        ErrorCode.RTSP_URL_EXISTS);\n            }\n\n            // Tạo mới - vd: CAM-305-Front chưa có → tạo mới\n            Camera camera = new Camera();\n            camera.setName(row.getName());\n            camera.setRtspUrl(row.getRtspUrl());\n            camera.setRoom(room);\n            // If status provided → use it; else default to true on create\n            camera.setActive(row.getIsActive() != null ? row.getIsActive() : true);\n            camera.setCreatedAt(Instant.now());\n            camera.setUpdatedAt(Instant.now());\n            cameraRepository.save(camera);\n        }\n    }\n\n    /**\n     * Trích xuất error code từ exception (dùng cho ImportErrorDTO).\n     *\n     * @param e Exception\n     * @return Error code string (vd: \"CAMERA_NAME_EXISTS\", \"UNKNOWN_ERROR\")\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\ClassService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/ClassService.java",
      "filename": "ClassService.java",
      "size_bytes": 20940,
      "lines": 452,
      "last_modified": "2025-11-21T20:30:09.311395",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.dto.mapper.ClassMapper;\nimport com.fuacs.backend.dto.mapper.SemesterMapper;\nimport com.fuacs.backend.dto.mapper.SubjectMapper;\nimport com.fuacs.backend.dto.request.ClassCsvRow;\nimport com.fuacs.backend.dto.request.ClassCreateRequest;\nimport com.fuacs.backend.dto.request.ClassSearchRequest;\nimport com.fuacs.backend.dto.request.ClassUpdateRequest;\nimport com.fuacs.backend.dto.response.ClassDTO;\nimport com.fuacs.backend.dto.response.ClassRosterDTO;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.dto.response.MajorDTO;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.dto.response.SubjectDTO;\nimport com.fuacs.backend.entity.AcademicClass;\nimport com.fuacs.backend.entity.Semester;\nimport com.fuacs.backend.entity.Subject;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.ClassRepository;\nimport com.fuacs.backend.repository.SemesterRepository;\nimport com.fuacs.backend.repository.StaffProfileRepository;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport com.fuacs.backend.repository.SubjectRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n@Service\npublic class ClassService {\n\n    private static final Logger log = LoggerFactory.getLogger(ClassService.class);\n\n    private final ClassRepository classRepository;\n    private final SubjectRepository subjectRepository;\n    private final SemesterRepository semesterRepository;\n    private final StudentProfileRepository studentRepository;\n    private final StaffProfileRepository staffRepository;\n    private final ClassMapper classMapper;\n    private final SemesterMapper semesterMapper;\n    private final SubjectMapper subjectMapper;\n    private final CsvParserService csvParserService;\n\n    public ClassService(ClassRepository classRepository,\n                        SubjectRepository subjectRepository,\n                        SemesterRepository semesterRepository,\n                        StudentProfileRepository studentRepository,\n                        StaffProfileRepository staffRepository,\n                        ClassMapper classMapper,\n                        SemesterMapper semesterMapper,\n                        SubjectMapper subjectMapper,\n                        CsvParserService csvParserService) {\n        this.classRepository = classRepository;\n        this.subjectRepository = subjectRepository;\n        this.semesterRepository = semesterRepository;\n        this.studentRepository = studentRepository;\n        this.staffRepository = staffRepository;\n        this.classMapper = classMapper;\n        this.semesterMapper = semesterMapper;\n        this.subjectMapper = subjectMapper;\n        this.csvParserService = csvParserService;\n    }\n\n    public List<ClassDTO> search(ClassSearchRequest request) {\n        return new ArrayList<>(classRepository.search(request));\n    }\n\n    public Long count(ClassSearchRequest request) {\n        return classRepository.count(request);\n    }\n\n    @Transactional(readOnly = true)\n    public ClassDTO findById(Short id) {\n        AcademicClass academicClass = classRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Class not found: \" + id, ErrorCode.CLASS_NOT_FOUND));\n\n        ClassDTO classDTO = classMapper.toDTO(academicClass);\n\n        // Create SemesterDTO with all required fields including dates\n        Semester semester = academicClass.getSemester();\n        SemesterDTO semesterDTO = new SemesterDTO(\n                semester.getId(),\n                semester.getName(),\n                semester.getCode(),\n                semester.getStartDate(),\n                semester.getEndDate(),\n                semester.getActive()\n        );\n        classDTO.setSemester(semesterDTO);\n\n        // Create SubjectDTO with majors for enrollment filtering\n        SubjectDTO subjectDTO = new SubjectDTO();\n        subjectDTO.setId(academicClass.getSubject().getId());\n        subjectDTO.setName(academicClass.getSubject().getName());\n        subjectDTO.setCode(academicClass.getSubject().getCode());\n        subjectDTO.setActive(academicClass.getSubject().getActive());\n        // Include majors for frontend to filter students by eligible majors\n        List<MajorDTO> majorDTOs = academicClass.getSubject().getMajors().stream()\n                .map(m -> new MajorDTO(m.getId(), m.getName(), m.getCode(), m.getActive()))\n                .collect(Collectors.toList());\n        subjectDTO.setMajors(majorDTOs);\n        classDTO.setSubject(subjectDTO);\n\n        // Set counts\n        classDTO.setTotalStudent((int) classRepository.countAllStudentsByClassId(id));\n        classDTO.setTotalEnrolledStudent((int) classRepository.countEnrolledStudentsByClassId(id));\n        classDTO.setTotalSlot((int) classRepository.countAllSlotsByClassId(id));\n        classDTO.setTotalActiveSlot((int) classRepository.countActiveSlotsByClassId(id));\n\n        return classDTO;\n    }\n\n    @Transactional\n    public ClassDTO create(ClassCreateRequest request) {\n        // Validate unique constraint\n        if (classRepository.existsByCodeAndSubjectIdAndSemesterId(\n                request.getCode(), request.getSubjectId(), request.getSemesterId())) {\n            throw new ResourceExistsException(\"Class already exists with subject, semester, and code\", ErrorCode.CLASS_EXISTS);\n        }\n\n        Subject subject = subjectRepository.findById(request.getSubjectId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Subject not found: \" + request.getSubjectId(), ErrorCode.SUBJECT_NOT_FOUND));\n\n        Semester semester = semesterRepository.findById(request.getSemesterId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Semester not found: \" + request.getSemesterId(), ErrorCode.SEMESTER_NOT_FOUND));\n\n        // Check if subject and semester are active\n        if (!subject.getActive() || !semester.getActive()) {\n            throw new OperationNotAllowedException(\"Cannot create class with inactive subject or semester\", ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n        }\n\n        AcademicClass academicClass = classMapper.toEntity(request);\n        academicClass.setSubject(subject);\n        academicClass.setSemester(semester);\n        academicClass.setActive(true);\n        AcademicClass savedClass = classRepository.save(academicClass);\n\n        ClassDTO classDTO = classMapper.toDTO(savedClass);\n        classDTO.setSemester(semesterMapper.toDTO(semester));\n\n        // Create simple SubjectDTO without majors and timestamps\n        SubjectDTO subjectDTO = new SubjectDTO();\n        subjectDTO.setId(subject.getId());\n        subjectDTO.setName(subject.getName());\n        subjectDTO.setCode(subject.getCode());\n        subjectDTO.setActive(subject.getActive());\n        classDTO.setSubject(subjectDTO);\n\n        return classDTO;\n    }\n\n    @Transactional\n    public ClassDTO update(Short id, ClassUpdateRequest request) {\n        AcademicClass existing = classRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Class not found: \" + id, ErrorCode.CLASS_NOT_FOUND));\n\n        // Validate unique constraint (excluding current record)\n        if (classRepository.existsByCodeAndSubjectIdAndSemesterIdAndIdNot(\n                request.getCode(), request.getSubjectId(), request.getSemesterId(), id)) {\n            throw new ResourceExistsException(\"Class already exists with subject, semester, and code\", ErrorCode.CLASS_EXISTS);\n        }\n\n        Subject subject = subjectRepository.findById(request.getSubjectId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Subject not found: \" + request.getSubjectId(), ErrorCode.SUBJECT_NOT_FOUND));\n\n        Semester semester = semesterRepository.findById(request.getSemesterId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Semester not found: \" + request.getSemesterId(), ErrorCode.SEMESTER_NOT_FOUND));\n\n        // Check if subject and semester are active\n        if (!subject.getActive() || !semester.getActive()) {\n            throw new OperationNotAllowedException(\"Cannot update class with inactive subject or semester\", ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n        }\n\n        // Check deactivation rules: Time-based validation\n        if (existing.getActive() && !request.getActive()) {\n            LocalDateTime now = LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n            LocalDateTime lastSlotEndTime = getLastActiveSlotEndTime(id);\n\n            if (lastSlotEndTime != null && now.isBefore(lastSlotEndTime)) {\n                throw new OperationNotAllowedException(\n                        String.format(\"Cannot deactivate class that hasn't finished. Last slot ends at: %s\",\n                                     lastSlotEndTime.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"))),\n                        ErrorCode.CLASS_NOT_FINISHED);\n            }\n        }\n\n        classMapper.updateClassFromRequest(request, existing);\n        existing.setSubject(subject);\n        existing.setSemester(semester);\n        AcademicClass savedClass = classRepository.save(existing);\n\n        ClassDTO classDTO = classMapper.toDTO(savedClass);\n        classDTO.setSemester(semesterMapper.toDTO(semester));\n\n        // Create simple SubjectDTO without majors and timestamps\n        SubjectDTO subjectDTO = new SubjectDTO();\n        subjectDTO.setId(subject.getId());\n        subjectDTO.setName(subject.getName());\n        subjectDTO.setCode(subject.getCode());\n        subjectDTO.setActive(subject.getActive());\n        classDTO.setSubject(subjectDTO);\n\n        return classDTO;\n    }\n\n    @Transactional\n    public void delete(Short id) {\n        AcademicClass academicClass = classRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Class not found: \" + id, ErrorCode.CLASS_NOT_FOUND));\n\n        // Check for dependencies\n        long totalSlots = classRepository.countAllSlotsByClassId(id);\n        long totalStudents = classRepository.countAllStudentsByClassId(id);\n\n        if (totalSlots > 0 || totalStudents > 0) {\n            throw new OperationNotAllowedException(\n                    String.format(\"Cannot delete class. Found %d slots and %d enrollments\", totalSlots, totalStudents),\n                    ErrorCode.CLASS_HAS_DEPENDENCIES);\n        }\n\n        try {\n            classRepository.deleteById(id);\n        } catch (DataIntegrityViolationException e) {\n            throw new OperationNotAllowedException(\"Cannot delete class due to existing dependencies\", ErrorCode.CLASS_HAS_DEPENDENCIES);\n        }\n    }\n\n    public List<ClassDTO> searchClassBySemesterId(Short semesterId, ClassSearchRequest request) {\n        if (!semesterRepository.existsById(semesterId)) {\n            throw new ResourceNotFoundException(\"Semester not found: \" + semesterId, ErrorCode.SEMESTER_NOT_FOUND);\n        }\n        return new ArrayList<>(classRepository.searchClassBySemesterId(semesterId, request));\n    }\n\n    public Long countBySemesterId(Short semesterId, ClassSearchRequest request) {\n        return classRepository.countBySemesterId(semesterId, request);\n    }\n\n    public List<ClassDTO> searchClassBySubjectId(Short subjectId, ClassSearchRequest request) {\n        if (!subjectRepository.existsById(subjectId)) {\n            throw new ResourceNotFoundException(\"Subject not found: \" + subjectId, ErrorCode.SUBJECT_NOT_FOUND);\n        }\n        return new ArrayList<>(classRepository.searchClassBySubjectId(subjectId, request));\n    }\n\n    public Long countBySubjectId(Short subjectId, ClassSearchRequest request) {\n        return classRepository.countBySubjectId(subjectId, request);\n    }\n\n    public List<ClassDTO> searchClassesByStudentId(Integer studentId, ClassSearchRequest request) {\n        if (!studentRepository.existsById(studentId)) {\n            throw new ResourceNotFoundException(\"Student profile not found: \" + studentId, ErrorCode.STUDENT_PROFILE_NOT_FOUND);\n        }\n        return new ArrayList<>(classRepository.searchClassesByStudentId(studentId, request));\n    }\n\n    public Long countClassesByStudentId(Integer studentId, ClassSearchRequest request) {\n        if (!studentRepository.existsById(studentId)) {\n            throw new ResourceNotFoundException(\"Student profile not found: \" + studentId, ErrorCode.STUDENT_PROFILE_NOT_FOUND);\n        }\n        return classRepository.countClassesByStudentId(studentId, request);\n    }\n\n    public List<ClassDTO> searchClassesByStaffId(Integer staffId, ClassSearchRequest request) {\n        if (!staffRepository.existsById(staffId)) {\n            throw new ResourceNotFoundException(\"Staff profile not found: \" + staffId, ErrorCode.STAFF_PROFILE_NOT_FOUND);\n        }\n        return new ArrayList<>(classRepository.searchClassesByStaffId(staffId, request));\n    }\n\n    public Long countClassesByStaffId(Integer staffId, ClassSearchRequest request) {\n        if (!staffRepository.existsById(staffId)) {\n            throw new ResourceNotFoundException(\"Staff profile not found: \" + staffId, ErrorCode.STAFF_PROFILE_NOT_FOUND);\n        }\n        return classRepository.countClassesByStaffId(staffId, request);\n    }\n\n    @Transactional(readOnly = true)\n    public ClassDTO getClassDetailsForRoster(Short classId) {\n        AcademicClass academicClass = classRepository.findById(classId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Class not found: \" + classId, ErrorCode.CLASS_NOT_FOUND));\n\n        ClassDTO classDTO = new ClassDTO();\n        classDTO.setId(academicClass.getId());\n        classDTO.setCode(academicClass.getCode());\n\n        SubjectDTO subjectDTO = new SubjectDTO();\n        subjectDTO.setId(academicClass.getSubject().getId());\n        subjectDTO.setName(academicClass.getSubject().getName());\n        subjectDTO.setCode(academicClass.getSubject().getCode());\n        classDTO.setSubject(subjectDTO);\n\n        SemesterDTO semesterDTO = new SemesterDTO();\n        semesterDTO.setId(academicClass.getSemester().getId());\n        semesterDTO.setName(academicClass.getSemester().getName());\n        semesterDTO.setCode(academicClass.getSemester().getCode());\n        classDTO.setSemester(semesterDTO);\n\n        return classDTO;\n    }\n\n    // ========== CSV IMPORT METHODS ==========\n\n    /**\n     * Import classes from CSV file.\n     * Supports partial success: valid rows are processed, invalid rows are reported.\n     * NO @Transactional on this method to avoid rollback-only conflicts.\n     */\n    public ImportResultDTO importFromCsv(MultipartFile file, String modeStr) {\n        ImportMode mode = ImportMode.fromString(modeStr);\n\n        List<ClassCsvRow> rows;\n        try {\n            rows = csvParserService.parseClassCsv(file);\n        } catch (Exception e) {\n            log.error(\"Failed to parse Class CSV file\", e);\n            throw new BadRequestException(\"Failed to parse CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        // Deduplicate by business key (code + subject + semester)\n        Map<String, ClassCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (ClassCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getUniqueKey(), row);\n        }\n\n        // Process each row in isolated transaction\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (ClassCsvRow row : uniqueRows.values()) {\n            try {\n                processOneClassRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()));\n            }\n        }\n\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Process one class row in an isolated transaction (REQUIRES_NEW).\n     * This allows partial success - each row commits or rolls back independently.\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneClassRow(ClassCsvRow row, ImportMode mode) {\n        // Validate row data\n        String validationError = row.getValidationError();\n        if (validationError != null) {\n            throw new BadRequestException(\n                    String.format(\"Row %d: %s\", row.getRowNumber(), validationError),\n                    ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Lookup subject by code\n        Subject subject = subjectRepository.findByCode(row.getSubjectCode());\n        if (subject == null) {\n            throw new ResourceNotFoundException(\"Subject code not found: \" + row.getSubjectCode(),\n                    ErrorCode.SUBJECT_NOT_FOUND);\n        }\n\n        // Lookup semester by code\n        Semester semester = semesterRepository.findByCode(row.getSemesterCode());\n        if (semester == null) {\n            throw new ResourceNotFoundException(\"Semester code not found: \" + row.getSemesterCode(),\n                    ErrorCode.SEMESTER_NOT_FOUND);\n        }\n\n        // Check if class already exists (by code + subject + semester)\n        AcademicClass existing = classRepository.findByCodeAndSubjectIdAndSemesterId(\n                row.getCode(), subject.getId(), semester.getId());\n\n        if (existing != null) {\n            // Class exists\n            if (mode == ImportMode.ADD_ONLY) {\n                throw new ResourceExistsException(\n                        String.format(\"Class already exists: code=%s, subject=%s, semester=%s\",\n                                row.getCode(), row.getSubjectCode(), row.getSemesterCode()),\n                        ErrorCode.CLASS_EXISTS);\n            }\n\n            // Update mode: update status if provided\n            if (row.getIsActive() != null) {\n                existing.setActive(row.getIsActive());\n                existing.setUpdatedAt(Instant.now());\n                classRepository.save(existing);\n            } else {\n            }\n\n        } else {\n            // Class does not exist: create new\n            AcademicClass academicClass = new AcademicClass();\n            academicClass.setCode(row.getCode());\n            academicClass.setSubject(subject);\n            academicClass.setSemester(semester);\n            academicClass.setActive(row.getIsActive() != null ? row.getIsActive() : true);\n            academicClass.setCreatedAt(Instant.now());\n            academicClass.setUpdatedAt(Instant.now());\n            classRepository.save(academicClass);\n        }\n    }\n\n    /**\n     * Extract error code from exception.\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n\n    /**\n     * Get the end time of the last active slot for a class\n     * @param classId Class ID\n     * @return Last slot end time, or null if no active slots\n     */\n    private LocalDateTime getLastActiveSlotEndTime(Short classId) {\n        return classRepository.findLastActiveSlotEndTimeByClassId(classId);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\ClassSummaryService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/ClassSummaryService.java",
      "filename": "ClassSummaryService.java",
      "size_bytes": 22229,
      "lines": 476,
      "last_modified": "2025-11-24T08:56:45.319022",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.enums.AttendanceStatus;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.dto.response.AttendanceStatisticsDTO;\nimport com.fuacs.backend.dto.response.AttendanceSummaryDTO;\nimport com.fuacs.backend.dto.response.ClassDTO;\nimport com.fuacs.backend.dto.response.ClassSummaryDTO;\nimport com.fuacs.backend.dto.response.EnrollmentSummaryDTO;\nimport com.fuacs.backend.dto.response.MajorDTO;\nimport com.fuacs.backend.dto.response.SlotSummaryDTO;\nimport com.fuacs.backend.dto.response.StudentAttendanceSummaryDTO;\nimport com.fuacs.backend.entity.AcademicClass;\nimport com.fuacs.backend.entity.AttendanceRecord;\nimport com.fuacs.backend.entity.Enrollment;\nimport com.fuacs.backend.entity.Slot;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.AttendanceRecordRepository;\nimport com.fuacs.backend.repository.ClassRepository;\nimport com.fuacs.backend.repository.EnrollmentRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport com.fuacs.backend.util.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.PageImpl;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * Service class to orchestrate data retrieval from multiple repositories\n * and provide comprehensive class summary information for lecturers.\n */\n@Service\npublic class ClassSummaryService {\n\n    private static final Logger log = LoggerFactory.getLogger(ClassSummaryService.class);\n\n    private final ClassRepository classRepository;\n    private final AttendanceRecordRepository attendanceRecordRepository;\n    private final EnrollmentRepository enrollmentRepository;\n    private final SlotRepository slotRepository;\n    private final StudentProfileRepository studentProfileRepository;\n    private final ClassService classService;\n\n    public ClassSummaryService(ClassRepository classRepository,\n                              AttendanceRecordRepository attendanceRecordRepository,\n                              EnrollmentRepository enrollmentRepository,\n                              SlotRepository slotRepository,\n                              StudentProfileRepository studentProfileRepository,\n                              ClassService classService) {\n        this.classRepository = classRepository;\n        this.attendanceRecordRepository = attendanceRecordRepository;\n        this.enrollmentRepository = enrollmentRepository;\n        this.slotRepository = slotRepository;\n        this.studentProfileRepository = studentProfileRepository;\n        this.classService = classService;\n    }\n\n    /**\n     * Retrieve comprehensive class summary including student lists, attendance records, and statistics.\n     * Validates lecturer authorization for accessing specific class data.\n     * \n     * @param classId The ID of the class to retrieve summary for\n     * @param semesterId The semester ID to filter data\n     * @return ClassSummaryDTO containing all class information\n     */\n    @Transactional(readOnly = true)\n    public ClassSummaryDTO getClassSummary(Short classId, Short semesterId) {\n        // Validate lecturer authorization\n        validateLecturerAuthorization(classId, semesterId);\n\n        // Get class information\n        ClassDTO classInfo = classService.findById(classId);\n\n        // Get enrollment summary\n        EnrollmentSummaryDTO enrollmentSummary = getEnrollmentSummary(classId);\n\n        // Get attendance statistics\n        AttendanceStatisticsDTO attendanceStatistics = getAttendanceStatistics(classId, semesterId);\n\n        // Get slot list for matrix (horizontal axis)\n        List<SlotSummaryDTO> slots = getSlotListForMatrix(classId, semesterId);\n\n        // Get student attendance summaries (vertical axis with Map<slotId, status>)\n        List<StudentAttendanceSummaryDTO> students = getStudentAttendanceSummaries(classId, semesterId);\n\n        return new ClassSummaryDTO(classInfo, enrollmentSummary, attendanceStatistics, slots, students);\n    }\n\n    /**\n     * Validate that the authenticated user is authorized to access the specified class data.\n     * Performs comprehensive security checks including authentication, class existence,\n     * semester validation, and lecturer assignment verification.\n     *\n     * Admin users (DATA_OPERATOR) are allowed to access any class summary without\n     * being assigned as staff to the class slots.\n     *\n     * @param classId The class ID to validate access for\n     * @param semesterId The semester ID for additional validation\n     * @throws OperationNotAllowedException if user is not authenticated or not authorized\n     * @throws ResourceNotFoundException if class or semester is not found\n     */\n    private void validateLecturerAuthorization(Short classId, Short semesterId) {\n        // Validate user authentication\n        SecurityUtil.getLoginUserId()\n            .orElseThrow(() -> {\n                return new OperationNotAllowedException(\n                    \"User not authenticated. Please log in to access this resource.\",\n                    ErrorCode.UN_AUTHENTICATION);\n            });\n\n        // Validate that the class exists\n        AcademicClass academicClass = classRepository.findById(classId)\n            .orElseThrow(() -> {\n                return new ResourceNotFoundException(\n                    \"Class not found with ID: \" + classId, ErrorCode.CLASS_NOT_FOUND);\n            });\n\n        // Validate that the class belongs to the specified semester\n        if (!academicClass.getSemester().getId().equals(semesterId)) {\n            throw new OperationNotAllowedException(\n                String.format(\"Class does not belong to the specified semester. Class belongs to semester %d, but requested semester is %d.\",\n                             academicClass.getSemester().getId(), semesterId),\n                ErrorCode.CLASS_SEMESTER_MISMATCH);\n        }\n\n        // Check if user is admin (DATA_OPERATOR) - allow access without slot assignment\n        boolean isAdmin = SecurityUtil.getUserAuthentication()\n            .map(auth -> auth.hasRole(\"DATA_OPERATOR\") || auth.getPermissions().contains(\"USER_READ_DETAIL\"))\n            .orElse(false);\n\n        if (isAdmin) {\n            // Admin users can access any class summary\n            return;\n        }\n\n        // For non-admin users, check if they are assigned as staff to slots in this class\n        Integer currentUserId = SecurityUtil.getLoginUserId().orElse(null);\n        List<Slot> userSlots = slotRepository.findByClassIdAndStaffUserId(classId, currentUserId);\n\n        if (userSlots.isEmpty()) {\n            throw new OperationNotAllowedException(\n                \"Access denied. You are not authorized to view this class summary. You must be assigned as staff to slots in this class.\",\n                ErrorCode.NOT_ASSIGNED_TO_CLASS);\n        }\n\n        // Additional validation: ensure at least one slot belongs to the specified semester\n        boolean hasSlotInSemester = userSlots.stream()\n            .anyMatch(slot -> slot.getAcademicClass() != null &&\n                     slot.getAcademicClass().getSemester().getId().equals(semesterId));\n\n        if (!hasSlotInSemester) {\n            throw new OperationNotAllowedException(\n                \"Access denied. You are not authorized to access this class in the specified semester.\",\n                ErrorCode.NOT_ASSIGNED_TO_CLASS);\n        }\n    }\n\n    /**\n     * Calculate enrollment summary with total student count.\n     *\n     * @param classId The class ID to get enrollment data for\n     * @return EnrollmentSummaryDTO with enrollment statistics\n     */\n    private EnrollmentSummaryDTO getEnrollmentSummary(Short classId) {\n        // Get total student count only\n        int totalStudents = (int) classRepository.countAllStudentsByClassId(classId);\n\n        return new EnrollmentSummaryDTO(totalStudents);\n    }\n\n    /**\n     * Get ordered slot list for attendance matrix.\n     * Returns LECTURE and LECTURE_WITH_PT slots only, ordered chronologically by start time.\n     * This provides the horizontal axis (columns) for the attendance matrix.\n     *\n     * @param classId The class ID to get slots for\n     * @param semesterId The semester ID to filter slots\n     * @return List of SlotSummaryDTO ordered by startTime\n     */\n    private List<SlotSummaryDTO> getSlotListForMatrix(Short classId, Short semesterId) {\n        List<Slot> eligibleSlots = slotRepository.findByClassId(classId).stream()\n            .filter(slot -> slot.getAcademicClass().getSemester().getId().equals(semesterId))\n            .filter(slot -> slot.getSlotCategory() == SlotCategory.LECTURE ||\n                           slot.getSlotCategory() == SlotCategory.LECTURE_WITH_PT)\n            .sorted(Comparator.comparing(Slot::getStartTime))\n            .collect(Collectors.toList());\n\n        return eligibleSlots.stream()\n            .map(slot -> new SlotSummaryDTO(\n                slot.getId(),\n                slot.getTitle(),\n                slot.getDescription(),\n                slot.getStartTime(),\n                slot.getEndTime(),\n                slot.getSlotCategory()\n            ))\n            .collect(Collectors.toList());\n    }\n\n    /**\n     * Calculate class-level attendance statistics including slot counts and overall attendance rate.\n     * Only includes slots with categories LECTURE and LECTURE_WITH_PT, excludes FINAL_EXAM slots.\n     * \n     * @param classId The class ID to calculate statistics for\n     * @param semesterId The semester ID to filter slots\n     * @return AttendanceStatisticsDTO with class attendance metrics\n     */\n    private AttendanceStatisticsDTO getAttendanceStatistics(Short classId, Short semesterId) {\n        // Get eligible slots (LECTURE and LECTURE_WITH_PT only)\n        List<Slot> eligibleSlots = slotRepository.findByClassId(classId).stream()\n            .filter(slot -> slot.getAcademicClass().getSemester().getId().equals(semesterId))\n            .filter(slot -> slot.getSlotCategory() == SlotCategory.LECTURE || \n                           slot.getSlotCategory() == SlotCategory.LECTURE_WITH_PT)\n            .collect(Collectors.toList());\n\n        int totalSlots = eligibleSlots.size();\n        \n        // Count completed slots (slots that have ended)\n        Instant now = Instant.now();\n        int completedSlots = (int) eligibleSlots.stream()\n            .filter(slot -> slot.getEndTime().isBefore(now.atZone(java.time.ZoneOffset.UTC).toLocalDateTime()))\n            .count();\n        \n        int upcomingSlots = totalSlots - completedSlots;\n\n        return new AttendanceStatisticsDTO(totalSlots, completedSlots, upcomingSlots);\n    }\n\n    /**\n     * Get detailed attendance summaries for all students in the class.\n     * Includes individual student attendance records and statistics.\n     * \n     * @param classId The class ID to get student data for\n     * @param semesterId The semester ID to filter data\n     * @return List of StudentAttendanceSummaryDTO with detailed student information\n     */\n    private List<StudentAttendanceSummaryDTO> getStudentAttendanceSummaries(Short classId, Short semesterId) {\n        return getStudentAttendanceSummariesDirect(classId, semesterId);\n    }\n\n    /**\n     * Direct approach to get student attendance summaries using repository queries.\n     * Includes ALL enrolled students, even those with no attendance records (all NOT_YET).\n     *\n     * @param classId The class ID\n     * @param semesterId The semester ID\n     * @return List of student attendance summaries\n     */\n    private List<StudentAttendanceSummaryDTO> getStudentAttendanceSummariesDirect(Short classId, Short semesterId) {\n        // Get all attendance records for the class and semester with filtering\n        List<AttendanceRecord> attendanceRecords = attendanceRecordRepository.findByClassAndSemesterWithSlotFiltering(classId, semesterId);\n\n        // Group records by student\n        Map<Integer, List<AttendanceRecord>> recordsByStudent = attendanceRecords.stream()\n            .collect(Collectors.groupingBy(record -> record.getStudent().getId()));\n\n        // Get eligible slots for this class and semester\n        List<Slot> eligibleSlots = slotRepository.findByClassId(classId).stream()\n            .filter(slot -> slot.getAcademicClass().getSemester().getId().equals(semesterId))\n            .filter(slot -> slot.getSlotCategory() == SlotCategory.LECTURE ||\n                           slot.getSlotCategory() == SlotCategory.LECTURE_WITH_PT)\n            .collect(Collectors.toList());\n\n        // Get ALL enrolled students for this class (not just those with attendance records)\n        List<Enrollment> enrollments = enrollmentRepository.findAllByAcademicClassId(classId);\n        Set<Integer> enrolledStudentIds = enrollments.stream()\n            .map(enrollment -> enrollment.getStudent().getId())\n            .collect(Collectors.toSet());\n\n        // FIX N+1: Batch fetch all student profiles first (for ALL enrolled students)\n        // Use custom query that eagerly loads Major to avoid LazyInitializationException\n        Map<Integer, com.fuacs.backend.entity.StudentProfile> profileMap = enrolledStudentIds.isEmpty()\n            ? new HashMap<>()\n            : studentProfileRepository.findAllByUserIdsWithMajor(enrolledStudentIds)\n                .stream()\n                .collect(Collectors.toMap(\n                    sp -> sp.getUserId(),\n                    sp -> sp\n                ));\n\n        // Also create a map of User entities from enrollments\n        Map<Integer, User> userMap = enrollments.stream()\n            .collect(Collectors.toMap(\n                enrollment -> enrollment.getStudent().getId(),\n                Enrollment::getStudent,\n                (existing, replacement) -> existing // Handle duplicates\n            ));\n\n        List<StudentAttendanceSummaryDTO> studentSummaries = new ArrayList<>();\n\n        // Process ALL enrolled students (not just those with attendance records)\n        for (Integer studentId : enrolledStudentIds) {\n            User student = userMap.get(studentId);\n            if (student == null) continue;\n\n            // Get attendance records for this student (may be empty for all NOT_YET)\n            List<AttendanceRecord> studentRecords = recordsByStudent.getOrDefault(studentId, new ArrayList<>());\n\n            // Create student attendance summary with preloaded profile\n            StudentAttendanceSummaryDTO studentSummary = createStudentAttendanceSummary(\n                student, studentRecords, eligibleSlots, profileMap.get(studentId));\n\n            studentSummaries.add(studentSummary);\n        }\n\n        // Sort by student name for consistent ordering\n        studentSummaries.sort((s1, s2) -> s1.getFullName().compareToIgnoreCase(s2.getFullName()));\n\n        return studentSummaries;\n    }\n\n    /**\n     * Create individual student attendance summary with detailed records and statistics.\n     *\n     * @param student The student user entity\n     * @param attendanceRecords List of attendance records for the student\n     * @param eligibleSlots List of eligible slots for attendance calculation\n     * @param studentProfile Preloaded student profile (to avoid N+1 queries)\n     * @return StudentAttendanceSummaryDTO with complete student information\n     */\n    private StudentAttendanceSummaryDTO createStudentAttendanceSummary(User student,\n                                                                      List<AttendanceRecord> attendanceRecords,\n                                                                      List<Slot> eligibleSlots,\n                                                                      com.fuacs.backend.entity.StudentProfile studentProfile) {\n        // Create basic student info\n        StudentAttendanceSummaryDTO summary = new StudentAttendanceSummaryDTO();\n        summary.setUserId(student.getId());\n        summary.setFullName(student.getFullName());\n        summary.setEmail(student.getEmail());\n\n        // Use preloaded student profile (NO DB query here - N+1 fix)\n        if (studentProfile != null) {\n            summary.setRollNumber(studentProfile.getRollNumber());\n\n            if (studentProfile.getMajor() != null) {\n                MajorDTO majorDTO = new MajorDTO();\n                majorDTO.setId(studentProfile.getMajor().getId());\n                majorDTO.setName(studentProfile.getMajor().getName());\n                majorDTO.setCode(studentProfile.getMajor().getCode());\n                summary.setMajor(majorDTO);\n            }\n        }\n\n        // Calculate attendance statistics\n        int totalSlots = eligibleSlots.size();\n        int presentCount = (int) attendanceRecords.stream()\n            .filter(record -> record.getStatus() == AttendanceStatus.PRESENT)\n            .count();\n        int absentCount = (int) attendanceRecords.stream()\n            .filter(record -> record.getStatus() == AttendanceStatus.ABSENT)\n            .count();\n        int notYetCount = totalSlots - attendanceRecords.size(); // Slots without attendance records\n\n        AttendanceSummaryDTO attendanceSummary = new AttendanceSummaryDTO(\n            totalSlots, presentCount, absentCount, notYetCount);\n        summary.setAttendanceSummary(attendanceSummary);\n\n        // Create attendance matrix map (slotId → status)\n        // Build map from existing records\n        Map<Integer, AttendanceStatus> recordMap = attendanceRecords.stream()\n            .collect(Collectors.toMap(\n                record -> record.getSlot().getId(),\n                AttendanceRecord::getStatus\n            ));\n\n        // Fill matrix: all eligible slots, null for NOT_YET\n        Map<Integer, AttendanceStatus> attendanceMap = new HashMap<>();\n        for (Slot slot : eligibleSlots) {\n            attendanceMap.put(\n                slot.getId(),\n                recordMap.getOrDefault(slot.getId(), null)  // null = NOT_YET\n            );\n        }\n\n        summary.setAttendanceRecords(attendanceMap);\n\n        return summary;\n    }\n\n    /**\n     * Get paginated student attendance summaries for a class.\n     * Supports search, filter, and sorting.\n     *\n     * @param classId Class identifier\n     * @param semesterId Semester identifier\n     * @param search Search query (name, roll number, email)\n     * @param filter Performance filter (all, excellent, good, fair, poor)\n     * @param pageable Pagination parameters\n     * @return Page of StudentAttendanceSummaryDTO\n     */\n    @Transactional(readOnly = true)\n    public Page<StudentAttendanceSummaryDTO> getClassSummaryStudents(\n        Short classId,\n        Short semesterId,\n        String search,\n        String filter,\n        Pageable pageable\n    ) {\n        // Validate authorization\n        validateLecturerAuthorization(classId, semesterId);\n\n        // For now, get all summaries then paginate in memory\n        // TODO: Optimize with true database pagination in future\n        List<StudentAttendanceSummaryDTO> allSummaries =\n            getStudentAttendanceSummaries(classId, semesterId);\n\n        // Apply search filter\n        if (search != null && !search.isBlank()) {\n            String searchLower = search.toLowerCase();\n            allSummaries = allSummaries.stream()\n                .filter(s ->\n                    s.getFullName().toLowerCase().contains(searchLower) ||\n                    s.getRollNumber().toLowerCase().contains(searchLower) ||\n                    s.getEmail().toLowerCase().contains(searchLower)\n                )\n                .toList();\n        }\n\n        // Apply sorting\n        allSummaries = applySorting(allSummaries, pageable.getSort());\n\n        // Apply pagination\n        int start = (int) pageable.getOffset();\n        int end = Math.min(start + pageable.getPageSize(), allSummaries.size());\n        List<StudentAttendanceSummaryDTO> pageContent =\n            allSummaries.subList(start, Math.min(end, allSummaries.size()));\n\n        return new PageImpl<>(pageContent, pageable, allSummaries.size());\n    }\n\n    private List<StudentAttendanceSummaryDTO> applySorting(\n        List<StudentAttendanceSummaryDTO> summaries,\n        Sort sort\n    ) {\n        if (sort.isUnsorted()) {\n            return summaries;\n        }\n\n        // Create comparator from Sort\n        Comparator<StudentAttendanceSummaryDTO> comparator = null;\n        for (Sort.Order order : sort) {\n            Comparator<StudentAttendanceSummaryDTO> orderComparator = switch (order.getProperty()) {\n                case \"fullName\" -> Comparator.comparing(StudentAttendanceSummaryDTO::getFullName);\n                case \"rollNumber\" -> Comparator.comparing(StudentAttendanceSummaryDTO::getRollNumber);\n                default -> Comparator.comparing(StudentAttendanceSummaryDTO::getRollNumber);\n            };\n\n            if (order.isDescending()) {\n                orderComparator = orderComparator.reversed();\n            }\n\n            comparator = (comparator == null) ? orderComparator : comparator.thenComparing(orderComparator);\n        }\n\n        return summaries.stream()\n            .sorted(comparator)\n            .toList();\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\CsvParserService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/CsvParserService.java",
      "filename": "CsvParserService.java",
      "size_bytes": 50727,
      "lines": 1193,
      "last_modified": "2025-11-21T19:16:59.614648",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.dto.request.*;\nimport com.fuacs.backend.exception.BadRequestException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Service\npublic class CsvParserService {\n\n    private static final long MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB\n    private static final int MAX_ROWS = 10000;\n\n    // CSV Headers for each resource type\n    private static final String EXPECTED_HEADER = \"roll_number,class_code,semester_code\";\n    private static final String ENROLLMENT_HEADER = \"roll_number,class_code,semester_code\";\n    private static final String SLOT_HEADER = \"title,start_time,end_time,slot_category,class_code,semester_code,room_name,staff_username\";\n    private static final String EXAM_SLOT_HEADER = \"title,start_time,end_time,slot_category,semester_code,room_name,staff_username,subject_codes\";\n    private static final String STUDENT_PROFILE_HEADER = \"full_name,email,username,roll_number,major_code\";\n    private static final String STUDENT_PROFILE_HEADER_WITH_EXTRAS = \"full_name,email,username,roll_number,major_code,status,password\";\n    private static final String STAFF_PROFILE_HEADER = \"full_name,email,staff_code,roles\";\n    private static final String STAFF_PROFILE_HEADER_WITH_EXTRAS = \"full_name,email,staff_code,roles,status,password\";\n    private static final String MAJOR_HEADER = \"code,name\";\n    private static final String MAJOR_HEADER_WITH_STATUS = \"code,name,status\";\n    private static final String SEMESTER_HEADER = \"code,name,start_date,end_date\";\n    private static final String SEMESTER_HEADER_WITH_STATUS = \"code,name,start_date,end_date,status\";\n    private static final String SUBJECT_HEADER = \"code,name,major_codes\";\n    private static final String SUBJECT_HEADER_WITH_STATUS = \"code,name,major_codes,status\";\n    private static final String CLASS_HEADER = \"code,subject_code,semester_code\";\n    private static final String CLASS_HEADER_WITH_STATUS = \"code,subject_code,semester_code,status\";\n    private static final String ROOM_HEADER = \"name,location\";\n    private static final String ROOM_HEADER_WITH_STATUS = \"name,location,status\";\n    private static final String CAMERA_HEADER = \"name,rtspUrl,room_name\";\n    private static final String CAMERA_HEADER_WITH_STATUS = \"name,rtspUrl,room_name,status\";\n    private static final String EXAM_SLOT_PARTICIPANT_HEADER = \"semester_code,start_time,room_name,subject_code,roll_number\";\n    private static final String BULK_PHOTO_HEADER = \"roll_number,image_filename\";\n\n    /**\n     * Parse Enrollment CSV file.\n     * CSV format: roll_number,class_code,semester_code\n     */\n    public List<EnrollmentCsvRow> parseEnrollmentCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<EnrollmentCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            // Validate header\n            String header = reader.readLine();\n            if (header == null || !header.trim().equals(ENROLLMENT_HEADER)) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + ENROLLMENT_HEADER,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            // Parse rows\n            String line;\n            int rowNum = 2; // Row 1 is header\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = line.split(\",\", -1);\n                if (parts.length != 3) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 3 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                EnrollmentCsvRow row = new EnrollmentCsvRow();\n                row.setRowNumber(rowNum);\n                row.setRollNumber(parts[0].trim());\n                row.setClassCode(parts[1].trim());\n                row.setSemesterCode(parts[2].trim());\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Validate individual CSV row data\n     *\n     * @param row CSV row to validate\n     * @return List of validation error messages (empty if valid)\n     */\n    public List<String> validateRow(EnrollmentCsvRow row) {\n        List<String> errors = new ArrayList<>();\n\n        if (row.getRollNumber() == null || row.getRollNumber().trim().isEmpty()) {\n            errors.add(\"roll_number is required\");\n        }\n\n        if (row.getClassCode() == null || row.getClassCode().trim().isEmpty()) {\n            errors.add(\"class_code is required\");\n        }\n\n        if (row.getSemesterCode() == null || row.getSemesterCode().trim().isEmpty()) {\n            errors.add(\"semester_code is required\");\n        }\n\n        return errors;\n    }\n\n    // ==================== CSV Parsing Methods for Academic Resources\n    // ====================\n\n    /**\n     * Parse Major CSV file.\n     * CSV format: code,name[,status]\n     */\n    public List<MajorCsvRow> parseMajorCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<MajorCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            // Validate header (accept legacy 2-column and new 3-column headers)\n            String header = reader.readLine();\n            if (header == null) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Missing header row.\",\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n            String trimmedHeader = header.trim();\n            boolean headerIs2 = trimmedHeader.equals(MAJOR_HEADER);\n            boolean headerIs3 = trimmedHeader.equals(MAJOR_HEADER_WITH_STATUS);\n            if (!headerIs2 && !headerIs3) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + MAJOR_HEADER + \" or \" + MAJOR_HEADER_WITH_STATUS,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            // Parse rows\n            String line;\n            int rowNum = 2; // Row 1 is header\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = line.split(\",\", -1);\n                if (parts.length != 2 && parts.length != 3) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 2 or 3 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                MajorCsvRow row = new MajorCsvRow();\n                row.setRowNumber(rowNum);\n                row.setCode(parts[0].trim());\n                row.setName(parts[1].trim());\n                if (parts.length == 3) {\n                    String statusStr = parts[2].trim();\n                    if (!statusStr.isEmpty()) {\n                        if (\"true\".equalsIgnoreCase(statusStr) || \"false\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(Boolean.parseBoolean(statusStr));\n                        } else if (\"1\".equals(statusStr) || \"0\".equals(statusStr)) {\n                            row.setIsActive(\"1\".equals(statusStr));\n                        } else if (\"yes\".equalsIgnoreCase(statusStr) || \"no\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(\"yes\".equalsIgnoreCase(statusStr));\n                        } else {\n                            throw new BadRequestException(\n                                    \"Invalid status value at row \" + rowNum + \". Expected true/false, 1/0, or yes/no\",\n                                    ErrorCode.INVALID_FIELD_FORMAT);\n                        }\n                    } else {\n                        // empty status treated as not provided → keep null in DTO\n                        row.setIsActive(null);\n                    }\n                }\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Parse Semester CSV file.\n     * CSV format: code,name,start_date,end_date OR code,name,start_date,end_date,status\n     */\n    public List<SemesterCsvRow> parseSemesterCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<SemesterCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            String header = reader.readLine();\n            boolean hasStatusColumn = false;\n\n            if (header == null) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + SEMESTER_HEADER + \" or \" + SEMESTER_HEADER_WITH_STATUS,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            String trimmedHeader = header.trim();\n            if (trimmedHeader.equals(SEMESTER_HEADER)) {\n                hasStatusColumn = false;\n            } else if (trimmedHeader.equals(SEMESTER_HEADER_WITH_STATUS)) {\n                hasStatusColumn = true;\n            } else {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + SEMESTER_HEADER + \" or \" + SEMESTER_HEADER_WITH_STATUS,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            String line;\n            int rowNum = 2;\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = line.split(\",\", -1);\n                int expectedColumns = hasStatusColumn ? 5 : 4;\n                if (parts.length != expectedColumns) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected \" + expectedColumns + \" columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                SemesterCsvRow row = new SemesterCsvRow();\n                row.setRowNumber(rowNum);\n                row.setCode(parts[0].trim());\n                row.setName(parts[1].trim());\n                row.setStartDateStr(parts[2].trim());\n                row.setEndDateStr(parts[3].trim());\n                if (hasStatusColumn && parts.length > 4) {\n                    row.setStatusStr(parts[4].trim());\n                }\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Parse Subject CSV file.\n     * CSV format: code,name,major_codes (major_codes is comma-separated, may need\n     * quotes)\n     */\n    public List<SubjectCsvRow> parseSubjectCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<SubjectCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            // Validate header (accept legacy 3-column and new 4-column headers)\n            String header = reader.readLine();\n            if (header == null) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Missing header row.\",\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n            String trimmedHeader = header.trim();\n            boolean headerIs3 = trimmedHeader.equals(SUBJECT_HEADER);\n            boolean headerIs4 = trimmedHeader.equals(SUBJECT_HEADER_WITH_STATUS);\n            if (!headerIs3 && !headerIs4) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + SUBJECT_HEADER + \" or \" + SUBJECT_HEADER_WITH_STATUS,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            String line;\n            int rowNum = 2;\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                // Handle quoted fields for major_codes\n                String[] parts = parseCsvLine(line, 4);\n                if (parts.length != 3 && parts.length != 4) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 3 or 4 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                SubjectCsvRow row = new SubjectCsvRow();\n                row.setRowNumber(rowNum);\n                row.setCode(parts[0].trim());\n                row.setName(parts[1].trim());\n                row.setMajorCodes(parts[2].trim());\n\n                // Parse status field (column 4) if present\n                if (parts.length == 4) {\n                    String statusStr = parts[3].trim();\n                    if (!statusStr.isEmpty()) {\n                        if (\"true\".equalsIgnoreCase(statusStr) || \"false\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(Boolean.parseBoolean(statusStr));\n                        } else if (\"1\".equals(statusStr) || \"0\".equals(statusStr)) {\n                            row.setIsActive(\"1\".equals(statusStr));\n                        } else if (\"yes\".equalsIgnoreCase(statusStr) || \"no\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(\"yes\".equalsIgnoreCase(statusStr));\n                        } else {\n                            throw new BadRequestException(\n                                    \"Invalid status value at row \" + rowNum + \". Expected true/false, 1/0, or yes/no\",\n                                    ErrorCode.INVALID_FIELD_FORMAT);\n                        }\n                    } else {\n                        // empty status treated as not provided → keep null in DTO\n                        row.setIsActive(null);\n                    }\n                }\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Parse Class CSV file.\n     * CSV format: code,subject_code,semester_code[,status]\n     */\n    public List<ClassCsvRow> parseClassCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<ClassCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            // Validate header (accept legacy 3-column and new 4-column headers)\n            String header = reader.readLine();\n            if (header == null) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Missing header row.\",\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n            String trimmedHeader = header.trim();\n            boolean headerIs3 = trimmedHeader.equals(CLASS_HEADER);\n            boolean headerIs4 = trimmedHeader.equals(CLASS_HEADER_WITH_STATUS);\n            if (!headerIs3 && !headerIs4) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + CLASS_HEADER + \" or \" + CLASS_HEADER_WITH_STATUS,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            String line;\n            int rowNum = 2;\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = line.split(\",\", -1);\n                if (parts.length != 3 && parts.length != 4) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 3 or 4 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                ClassCsvRow row = new ClassCsvRow();\n                row.setRowNumber(rowNum);\n                row.setCode(parts[0].trim());\n                row.setSubjectCode(parts[1].trim());\n                row.setSemesterCode(parts[2].trim());\n\n                // Parse status field (column 4) if present\n                if (parts.length == 4) {\n                    String statusStr = parts[3].trim();\n                    if (!statusStr.isEmpty()) {\n                        if (\"true\".equalsIgnoreCase(statusStr) || \"false\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(Boolean.parseBoolean(statusStr));\n                        } else if (\"1\".equals(statusStr) || \"0\".equals(statusStr)) {\n                            row.setIsActive(\"1\".equals(statusStr));\n                        } else if (\"yes\".equalsIgnoreCase(statusStr) || \"no\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(\"yes\".equalsIgnoreCase(statusStr));\n                        } else {\n                            throw new BadRequestException(\n                                    \"Invalid status value at row \" + rowNum + \". Expected true/false, 1/0, or yes/no\",\n                                    ErrorCode.INVALID_FIELD_FORMAT);\n                        }\n                    } else {\n                        // empty status treated as not provided → keep null in DTO\n                        row.setIsActive(null);\n                    }\n                }\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Parse Room CSV file.\n     * CSV format: name,location or name,location,status\n     */\n    public List<RoomCsvRow> parseRoomCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<RoomCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            // Validate header (accept legacy 2-column and new 3-column headers)\n            String header = reader.readLine();\n            if (header == null) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Missing header row.\",\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n            String trimmedHeader = header.trim();\n            boolean headerIs2 = trimmedHeader.equals(ROOM_HEADER);\n            boolean headerIs3 = trimmedHeader.equals(ROOM_HEADER_WITH_STATUS);\n            if (!headerIs2 && !headerIs3) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + ROOM_HEADER + \" or \" + ROOM_HEADER_WITH_STATUS,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            String line;\n            int rowNum = 2;\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = line.split(\",\", -1);\n                if (parts.length != 2 && parts.length != 3) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 2 or 3 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                RoomCsvRow row = new RoomCsvRow();\n                row.setRowNumber(rowNum);\n                row.setName(parts[0].trim());\n                row.setLocation(parts[1].trim());\n                if (parts.length == 3) {\n                    String statusStr = parts[2].trim();\n                    if (!statusStr.isEmpty()) {\n                        if (\"true\".equalsIgnoreCase(statusStr) || \"false\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(Boolean.parseBoolean(statusStr));\n                        } else if (\"1\".equals(statusStr) || \"0\".equals(statusStr)) {\n                            row.setIsActive(\"1\".equals(statusStr));\n                        } else if (\"yes\".equalsIgnoreCase(statusStr) || \"no\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(\"yes\".equalsIgnoreCase(statusStr));\n                        } else {\n                            throw new BadRequestException(\n                                    \"Invalid status value at row \" + rowNum + \". Expected true/false, 1/0, or yes/no\",\n                                    ErrorCode.INVALID_FIELD_FORMAT);\n                        }\n                    } else {\n                        // empty status treated as not provided → keep null in DTO\n                        row.setIsActive(null);\n                    }\n                }\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Parse Camera CSV file.\n     * CSV format: name,rtspUrl,room_name or name,rtspUrl,room_name,status\n     */\n    public List<CameraCsvRow> parseCameraCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<CameraCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            // Validate header (accept legacy 3-column and new 4-column headers)\n            String header = reader.readLine();\n            if (header == null) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Missing header row.\",\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n            String trimmedHeader = header.trim();\n            boolean headerIs3 = trimmedHeader.equals(CAMERA_HEADER);\n            boolean headerIs4 = trimmedHeader.equals(CAMERA_HEADER_WITH_STATUS);\n            if (!headerIs3 && !headerIs4) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + CAMERA_HEADER + \" or \" + CAMERA_HEADER_WITH_STATUS,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            String line;\n            int rowNum = 2;\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = line.split(\",\", -1);\n                if (parts.length != 3 && parts.length != 4) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 3 or 4 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                CameraCsvRow row = new CameraCsvRow();\n                row.setRowNumber(rowNum);\n                row.setName(parts[0].trim());\n                row.setRtspUrl(parts[1].trim());\n                row.setRoomName(parts[2].trim());\n                if (parts.length == 4) {\n                    String statusStr = parts[3].trim();\n                    if (!statusStr.isEmpty()) {\n                        if (\"true\".equalsIgnoreCase(statusStr) || \"false\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(Boolean.parseBoolean(statusStr));\n                        } else if (\"1\".equals(statusStr) || \"0\".equals(statusStr)) {\n                            row.setIsActive(\"1\".equals(statusStr));\n                        } else if (\"yes\".equalsIgnoreCase(statusStr) || \"no\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(\"yes\".equalsIgnoreCase(statusStr));\n                        } else {\n                            throw new BadRequestException(\n                                    \"Invalid status value at row \" + rowNum + \". Expected true/false, 1/0, or yes/no\",\n                                    ErrorCode.INVALID_FIELD_FORMAT);\n                        }\n                    } else {\n                        // empty status treated as not provided → keep null in DTO\n                        row.setIsActive(null);\n                    }\n                }\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Parse Slot CSV file for LECTURE/LECTURE_WITH_PT slots.\n     * CSV format: title,start_time,end_time,slot_category,class_code,semester_code,room_name,staff_username\n     * Note: title can be empty\n     */\n    public List<SlotCsvRow> parseSlotCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<SlotCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            String header = reader.readLine();\n            if (header == null || !header.trim().equals(SLOT_HEADER)) {\n                throw new BadRequestException(\n                        String.format(\n                            \"Invalid CSV header.%nExpected: %s%nReceived: %s%nPlease check column names, order, and spacing.\",\n                            SLOT_HEADER, header),\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            String line;\n            int rowNum = 2;\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = parseCsvLine(line, 8);\n                if (parts.length != 8) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 8 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                SlotCsvRow row = new SlotCsvRow();\n                row.setRowNumber(rowNum);\n                row.setTitle(parts[0].trim());\n                row.setStartTimeStr(parts[1].trim());\n                row.setEndTimeStr(parts[2].trim());\n                row.setSlotCategory(parts[3].trim());\n                row.setClassCode(parts[4].trim());\n                row.setSemesterCode(parts[5].trim());\n                row.setRoomName(parts[6].trim());\n                row.setStaffUsername(parts[7].trim());\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Parse Exam Slot CSV file for FINAL_EXAM slots.\n     * CSV format: title,start_time,end_time,slot_category,semester_code,room_name,staff_username,subject_codes\n     * Note: title can be empty, subject_codes can contain comma-separated values (quoted if needed)\n     */\n    public List<ExamSlotCsvRow> parseExamSlotCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<ExamSlotCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            String header = reader.readLine();\n            if (header == null || !header.trim().equals(EXAM_SLOT_HEADER)) {\n                throw new BadRequestException(\n                        String.format(\n                            \"Invalid CSV header.%nExpected: %s%nReceived: %s%nPlease check column names, order, and spacing.\",\n                            EXAM_SLOT_HEADER, header),\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            String line;\n            int rowNum = 2;\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = parseCsvLine(line, 8);\n                if (parts.length != 8) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 8 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                ExamSlotCsvRow row = new ExamSlotCsvRow();\n                row.setRowNumber(rowNum);\n                row.setTitle(parts[0].trim());\n                row.setStartTimeStr(parts[1].trim());\n                row.setEndTimeStr(parts[2].trim());\n                row.setSlotCategory(parts[3].trim());\n                row.setSemesterCode(parts[4].trim());\n                row.setRoomName(parts[5].trim());\n                row.setStaffUsername(parts[6].trim());\n                row.setSubjectCodes(parts[7].trim());\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Parse Student Profile CSV file.\n     * CSV format: full_name,email,username,roll_number,major_code[,status,password]\n     */\n    public List<StudentProfileCsvRow> parseStudentProfileCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<StudentProfileCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            // Validate header (accept legacy 5-column and new 7-column headers)\n            String header = reader.readLine();\n            if (header == null) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Missing header row.\",\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n            String trimmedHeader = header.trim();\n            boolean headerIs5 = trimmedHeader.equals(STUDENT_PROFILE_HEADER);\n            boolean headerIs7 = trimmedHeader.equals(STUDENT_PROFILE_HEADER_WITH_EXTRAS);\n            if (!headerIs5 && !headerIs7) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + STUDENT_PROFILE_HEADER + \" or \" + STUDENT_PROFILE_HEADER_WITH_EXTRAS,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            String line;\n            int rowNum = 2;\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = line.split(\",\", -1);\n                if (parts.length != 5 && parts.length != 7) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 5 or 7 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                StudentProfileCsvRow row = new StudentProfileCsvRow();\n                row.setRowNumber(rowNum);\n                row.setFullName(parts[0].trim());\n                row.setEmail(parts[1].trim());\n                row.setUsername(parts[2].trim());\n                row.setRollNumber(parts[3].trim());\n                row.setMajorCode(parts[4].trim());\n\n                // Parse status field (column 6) if present\n                if (parts.length == 7) {\n                    String statusStr = parts[5].trim();\n                    if (!statusStr.isEmpty()) {\n                        if (\"true\".equalsIgnoreCase(statusStr) || \"false\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(Boolean.parseBoolean(statusStr));\n                        } else if (\"1\".equals(statusStr) || \"0\".equals(statusStr)) {\n                            row.setIsActive(\"1\".equals(statusStr));\n                        } else if (\"yes\".equalsIgnoreCase(statusStr) || \"no\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(\"yes\".equalsIgnoreCase(statusStr));\n                        } else {\n                            throw new BadRequestException(\n                                    \"Invalid status value at row \" + rowNum + \". Expected true/false, 1/0, or yes/no\",\n                                    ErrorCode.INVALID_FIELD_FORMAT);\n                        }\n                    } else {\n                        // empty status treated as not provided → keep null in DTO\n                        row.setIsActive(null);\n                    }\n\n                    // Parse password field (column 7) - can be empty\n                    String passwordStr = parts[6].trim();\n                    if (!passwordStr.isEmpty()) {\n                        row.setPassword(passwordStr);\n                    } else {\n                        row.setPassword(null);\n                    }\n                }\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Parse Staff Profile CSV file.\n     * CSV format: full_name,email,staff_code,roles[,status,password]\n     */\n    public List<StaffProfileCsvRow> parseStaffProfileCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<StaffProfileCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            // Validate header (accept legacy 4-column and new 6-column headers)\n            String header = reader.readLine();\n            if (header == null) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Missing header row.\",\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n            String trimmedHeader = header.trim();\n            boolean headerIs4 = trimmedHeader.equals(STAFF_PROFILE_HEADER);\n            boolean headerIs6 = trimmedHeader.equals(STAFF_PROFILE_HEADER_WITH_EXTRAS);\n            if (!headerIs4 && !headerIs6) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + STAFF_PROFILE_HEADER + \" or \" + STAFF_PROFILE_HEADER_WITH_EXTRAS,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            String line;\n            int rowNum = 2;\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = line.split(\",\", -1);\n                if (parts.length != 4 && parts.length != 6) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 4 or 6 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                StaffProfileCsvRow row = new StaffProfileCsvRow();\n                row.setRowNumber(rowNum);\n                row.setFullName(parts[0].trim());\n                row.setEmail(parts[1].trim());\n                row.setStaffCode(parts[2].trim());\n                row.setRolesStr(parts[3].trim());\n\n                // Parse status field (column 5) if present\n                if (parts.length == 6) {\n                    String statusStr = parts[4].trim();\n                    if (!statusStr.isEmpty()) {\n                        if (\"true\".equalsIgnoreCase(statusStr) || \"false\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(Boolean.parseBoolean(statusStr));\n                        } else if (\"1\".equals(statusStr) || \"0\".equals(statusStr)) {\n                            row.setIsActive(\"1\".equals(statusStr));\n                        } else if (\"yes\".equalsIgnoreCase(statusStr) || \"no\".equalsIgnoreCase(statusStr)) {\n                            row.setIsActive(\"yes\".equalsIgnoreCase(statusStr));\n                        } else {\n                            throw new BadRequestException(\n                                    \"Invalid status value at row \" + rowNum + \". Expected true/false, 1/0, or yes/no\",\n                                    ErrorCode.INVALID_FIELD_FORMAT);\n                        }\n                    } else {\n                        // empty status treated as not provided → keep null in DTO\n                        row.setIsActive(null);\n                    }\n\n                    // Parse password field (column 6) - can be empty\n                    String passwordStr = parts[5].trim();\n                    if (!passwordStr.isEmpty()) {\n                        row.setPassword(passwordStr);\n                    } else {\n                        row.setPassword(null);\n                    }\n                }\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\", ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    // ==================== Helper Methods ====================\n\n    /**\n     * Validate file size, type, and existence.\n     */\n    private void validateFile(MultipartFile file) {\n        if (file == null || file.isEmpty()) {\n            throw new BadRequestException(\"CSV file is required\", ErrorCode.FILE_REQUIRED);\n        }\n\n        if (file.getSize() > MAX_FILE_SIZE) {\n            throw new BadRequestException(\"File size exceeds maximum limit of 5MB\", ErrorCode.FILE_TOO_LARGE);\n        }\n\n        String contentType = file.getContentType();\n        String filename = file.getOriginalFilename();\n        if (contentType == null\n                || (!contentType.equals(\"text/csv\") && !contentType.equals(\"application/vnd.ms-excel\"))) {\n            if (filename == null || !filename.toLowerCase().endsWith(\".csv\")) {\n                throw new BadRequestException(\"Invalid file type. Only CSV files are allowed\",\n                        ErrorCode.INVALID_FILE_TYPE);\n            }\n        }\n    }\n\n    /**\n     * Skip UTF-8 BOM character if present.\n     */\n    private void skipBomIfPresent(BufferedReader reader) throws IOException {\n        reader.mark(1);\n        int firstChar = reader.read();\n        if (firstChar != 0xFEFF) {\n            reader.reset();\n        }\n    }\n\n    /**\n     * Parse CSV line handling quoted fields (for fields containing commas).\n     * Simple implementation for quoted fields.\n     */\n    private String[] parseCsvLine(String line, int expectedColumns) {\n        List<String> result = new ArrayList<>();\n        StringBuilder current = new StringBuilder();\n        boolean inQuotes = false;\n\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n\n            if (c == '\"') {\n                inQuotes = !inQuotes;\n            } else if (c == ',' && !inQuotes) {\n                result.add(current.toString());\n                current = new StringBuilder();\n            } else {\n                current.append(c);\n            }\n        }\n\n        result.add(current.toString());\n\n        return result.toArray(new String[0]);\n    }\n\n    // ==================== Exam Slot Import Methods ====================\n\n    /**\n     * Parse Exam Slot Participant CSV file.\n     * CSV format: semester_code,start_time,room_name,subject_code,roll_number\n     */\n    public List<ExamSlotParticipantCsvRow> parseExamSlotParticipantCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<ExamSlotParticipantCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            // Validate header\n            String header = reader.readLine();\n            if (header == null || !header.trim().equals(EXAM_SLOT_PARTICIPANT_HEADER)) {\n                throw new BadRequestException(\n                        \"Invalid CSV format. Expected header: \" + EXAM_SLOT_PARTICIPANT_HEADER,\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            // Parse rows\n            String line;\n            int rowNum = 2; // Row 1 is header\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                            \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                            ErrorCode.TOO_MANY_ROWS);\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = line.split(\",\", -1);\n                if (parts.length != 5) {\n                    throw new BadRequestException(\n                            \"Invalid CSV format at row \" + rowNum + \". Expected 5 columns, found \" + parts.length,\n                            ErrorCode.INVALID_CSV_FORMAT);\n                }\n\n                ExamSlotParticipantCsvRow row = new ExamSlotParticipantCsvRow();\n                row.setRowNumber(rowNum);\n                row.setSemesterCode(parts[0].trim());\n                row.setStartTime(parts[1].trim());\n                row.setRoomName(parts[2].trim());\n                row.setSubjectCode(parts[3].trim());\n                row.setRollNumber(parts[4].trim());\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty. No data rows found\",\n                        ErrorCode.INVALID_CSV_FORMAT);\n            }\n\n            return rows;\n        }\n    }\n\n    /**\n     * Parse bulk photo upload CSV file\n     * CSV format: roll_number,image_filename\n     */\n    public List<BulkPhotoUploadCsvRow> parseBulkPhotoCsv(MultipartFile file) throws IOException {\n        validateFile(file);\n\n        List<BulkPhotoUploadCsvRow> rows = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {\n\n            skipBomIfPresent(reader);\n\n            // Validate header\n            String header = reader.readLine();\n            if (header == null || !header.trim().equals(BULK_PHOTO_HEADER)) {\n                throw new BadRequestException(\n                    \"Invalid CSV format. Expected header: \" + BULK_PHOTO_HEADER,\n                    ErrorCode.INVALID_CSV_FORMAT\n                );\n            }\n\n            // Parse rows\n            String line;\n            int rowNum = 2;\n            while ((line = reader.readLine()) != null) {\n                if (rowNum > MAX_ROWS + 1) {\n                    throw new BadRequestException(\n                        \"CSV file exceeds maximum limit of \" + MAX_ROWS + \" rows\",\n                        ErrorCode.TOO_MANY_ROWS\n                    );\n                }\n\n                if (line.trim().isEmpty()) {\n                    rowNum++;\n                    continue;\n                }\n\n                String[] parts = line.split(\",\", -1);\n                if (parts.length != 2) {\n                    throw new BadRequestException(\n                        \"Invalid CSV format at row \" + rowNum + \". Expected 2 columns, found \" + parts.length,\n                        ErrorCode.INVALID_CSV_FORMAT\n                    );\n                }\n\n                BulkPhotoUploadCsvRow row = new BulkPhotoUploadCsvRow();\n                row.setRowNumber(rowNum);\n                row.setRollNumber(parts[0].trim());\n                row.setImageFilename(parts[1].trim());\n\n                if (!row.isValid()) {\n                    throw new BadRequestException(\n                        \"Invalid data at row \" + rowNum,\n                        ErrorCode.INVALID_FIELD_FORMAT\n                    );\n                }\n\n                rows.add(row);\n                rowNum++;\n            }\n\n            if (rows.isEmpty()) {\n                throw new BadRequestException(\"CSV file is empty\", ErrorCode.EMPTY_CSV_FILE);\n            }\n\n            return rows;\n        }\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\DataOperatorDashboardService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/DataOperatorDashboardService.java",
      "filename": "DataOperatorDashboardService.java",
      "size_bytes": 8456,
      "lines": 183,
      "last_modified": "2025-11-21T19:16:59.614648",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.dto.response.DataOperatorDashboardResponse;\nimport com.fuacs.backend.dto.response.DataOperatorStatsDTO;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.entity.Semester;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.repository.ClassRepository;\nimport com.fuacs.backend.repository.SemesterRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport com.fuacs.backend.repository.SubjectRepository;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@Service\n@Transactional(readOnly = true)\npublic class DataOperatorDashboardService {\n\n    private final ClassRepository classRepository;\n    private final StudentProfileRepository studentProfileRepository;\n    private final SubjectRepository subjectRepository;\n    private final SlotRepository slotRepository;\n    private final SemesterRepository semesterRepository;\n\n    public DataOperatorDashboardService(ClassRepository classRepository,\n                                        StudentProfileRepository studentProfileRepository,\n                                        SubjectRepository subjectRepository,\n                                        SlotRepository slotRepository,\n                                        SemesterRepository semesterRepository) {\n        this.classRepository = classRepository;\n        this.studentProfileRepository = studentProfileRepository;\n        this.subjectRepository = subjectRepository;\n        this.slotRepository = slotRepository;\n        this.semesterRepository = semesterRepository;\n    }\n\n    public DataOperatorDashboardResponse getDashboardData(Short requestedSemesterId) {\n        // Validate semester if provided\n        if (requestedSemesterId != null) {\n            validateSemesterExists(requestedSemesterId);\n        }\n        \n        List<SemesterDTO> semesters = getAvailableSemesters();\n        Short selectedSemesterId = determineSelectedSemester(requestedSemesterId);\n        DataOperatorStatsDTO stats = getSystemStats(selectedSemesterId);\n        \n        return new DataOperatorDashboardResponse(semesters, selectedSemesterId, stats);\n    }\n\n    private Short determineSelectedSemester(Short requestedSemesterId) {\n        // CHANGED: Simplified logic to support \"All Semester\" mode\n        // If specific semester is requested, use it\n        // If null is requested, return null to indicate \"All Semester\" mode\n        // Frontend is responsible for auto-selecting current semester on initial load\n        return requestedSemesterId;\n    }\n\n    private DataOperatorStatsDTO getSystemStats(Short semesterId) {\n        // CHANGED: Support \"All Semester\" mode when semesterId is null\n        if (semesterId == null) {\n            return calculateAllSemesterStats();\n        }\n\n        // Class statistics\n        Integer totalClasses = classRepository.countTotalClassesBySemester(semesterId);\n        Integer activeClasses = classRepository.countActiveClassesBySemester(semesterId);\n\n        // Student statistics\n        Integer totalStudents = studentProfileRepository.countTotalStudentsBySemester(semesterId);\n        Integer activeStudents = studentProfileRepository.countActiveStudentsBySemester(semesterId);\n        Double averageStudentsPerClass = studentProfileRepository.calculateAverageStudentsPerClassBySemester(semesterId);\n\n        // Additional statistics\n        Integer totalSubjects = subjectRepository.countSubjectsBySemester(semesterId);\n        Integer totalLecturers = classRepository.countLecturersBySemester(semesterId);\n        Integer totalSlots = slotRepository.countTotalSlotsBySemester(semesterId);\n        Double slotsCompletionRate = slotRepository.calculateSlotsCompletionRateBySemester(semesterId);\n\n        // Handle null values\n        totalClasses = totalClasses != null ? totalClasses : 0;\n        activeClasses = activeClasses != null ? activeClasses : 0;\n        totalStudents = totalStudents != null ? totalStudents : 0;\n        activeStudents = activeStudents != null ? activeStudents : 0;\n        averageStudentsPerClass = averageStudentsPerClass != null ? averageStudentsPerClass : 0.0;\n        totalSubjects = totalSubjects != null ? totalSubjects : 0;\n        totalLecturers = totalLecturers != null ? totalLecturers : 0;\n        totalSlots = totalSlots != null ? totalSlots : 0;\n        slotsCompletionRate = slotsCompletionRate != null ? slotsCompletionRate : 0.0;\n\n        return new DataOperatorStatsDTO(\n                totalClasses,\n                activeClasses,\n                totalStudents,\n                activeStudents,\n                averageStudentsPerClass,\n                totalSubjects,\n                totalLecturers,\n                totalSlots,\n                slotsCompletionRate\n        );\n    }\n\n    private DataOperatorStatsDTO calculateAllSemesterStats() {\n        // Calculate stats across ALL semesters (no semester filter)\n\n        // Count all classes (no semester filter)\n        Long totalClassesCount = classRepository.count();\n        Integer totalClasses = totalClassesCount != null ? totalClassesCount.intValue() : 0;\n\n        // Count active classes (based on isActive flag)\n        Integer activeClasses = classRepository.countActiveClasses();\n\n        // Count all students\n        Long totalStudentsCount = studentProfileRepository.count();\n        Integer totalStudents = totalStudentsCount != null ? totalStudentsCount.intValue() : 0;\n        Integer activeStudents = totalStudents; // Simplified: assume all students are active\n\n        // CHANGED: Use correct query that calculates average based on enrollments, not student profiles\n        Double averageStudentsPerClass = studentProfileRepository.calculateAverageStudentsPerClass();\n\n        // Count all subjects\n        Long totalSubjectsCount = subjectRepository.count();\n        Integer totalSubjects = totalSubjectsCount != null ? totalSubjectsCount.intValue() : 0;\n\n        // Count total lecturers and slots across all semesters\n        Integer totalLecturers = classRepository.countTotalLecturers();\n        Integer totalSlots = slotRepository.countTotalSlots();\n        Double slotsCompletionRate = slotRepository.calculateSlotsCompletionRate();\n\n        // Handle null values\n        activeClasses = activeClasses != null ? activeClasses : 0;\n        averageStudentsPerClass = averageStudentsPerClass != null ? averageStudentsPerClass : 0.0;\n        totalLecturers = totalLecturers != null ? totalLecturers : 0;\n        totalSlots = totalSlots != null ? totalSlots : 0;\n        slotsCompletionRate = slotsCompletionRate != null ? slotsCompletionRate : 0.0;\n\n        return new DataOperatorStatsDTO(\n                totalClasses,\n                activeClasses,\n                totalStudents,\n                activeStudents,\n                averageStudentsPerClass,\n                totalSubjects,\n                totalLecturers,\n                totalSlots,\n                slotsCompletionRate\n        );\n    }\n\n    private List<SemesterDTO> getAvailableSemesters() {\n        List<Semester> semesters = semesterRepository.findAll();\n        return semesters.stream()\n                .map(this::mapToSemesterDTO)\n                .collect(Collectors.toList());\n    }\n\n    private SemesterDTO mapToSemesterDTO(Semester semester) {\n        return new SemesterDTO(\n                semester.getId(),\n                semester.getName(),\n                semester.getCode(),\n                semester.getStartDate(),\n                semester.getEndDate(),\n                semester.getActive()\n        );\n    }\n\n    private void validateSemesterExists(Short semesterId) {\n        if (semesterId == null || semesterId <= 0) {\n            throw new BadRequestException(\"Invalid semester ID\", ErrorCode.BAD_REQUEST);\n        }\n        \n        boolean semesterExists = semesterRepository.existsById(semesterId);\n        if (!semesterExists) {\n            throw new BadRequestException(\"Semester not found with ID: \" + semesterId, ErrorCode.BAD_REQUEST);\n        }\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\EmailService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/EmailService.java",
      "filename": "EmailService.java",
      "size_bytes": 1361,
      "lines": 42,
      "last_modified": "2025-11-09T20:27:56.546183",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class EmailService {\n\n    private final JavaMailSender mailSender;\n\n    @Value(\"${frontend.url:http://localhost:3000}\")\n    private String frontendUrl;\n\n    public EmailService(JavaMailSender mailSender) {\n        this.mailSender = mailSender;\n    }\n\n    @Async\n    public void sendPasswordResetEmail(String to, String token) {\n        String resetLink = frontendUrl + \"/reset-password?token=\" + token;\n\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setTo(to);\n        message.setSubject(\"Reset your password\");\n        message.setText(\"Click the following link to reset your password:\\n\" + resetLink +\n                \"\\n\\nThis link will expire in 15 minutes.\");\n\n        mailSender.send(message);\n    }\n\n    @Async\n    public void sendPassword(String to, String password) {\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setTo(to);\n        message.setSubject(\"Your password: \" + password);\n        mailSender.send(message);\n    }\n}\n\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\EnrollmentService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/EnrollmentService.java",
      "filename": "EnrollmentService.java",
      "size_bytes": 23240,
      "lines": 510,
      "last_modified": "2025-11-23T11:44:42.299359",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.dto.mapper.EnrollmentMapper;\nimport com.fuacs.backend.dto.request.EnrollmentCreateRequest;\nimport com.fuacs.backend.dto.request.EnrollmentCsvRow;\nimport com.fuacs.backend.dto.request.EnrollmentSearchRequest;\nimport com.fuacs.backend.dto.request.EnrollmentUpdateRequest;\nimport com.fuacs.backend.dto.response.BulkEnrollmentResponse;\nimport com.fuacs.backend.dto.response.EnrollmentDTO;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.dto.response.StudentProfileDTO;\nimport com.fuacs.backend.entity.AcademicClass;\nimport com.fuacs.backend.entity.Enrollment;\nimport com.fuacs.backend.entity.EnrollmentId;\nimport com.fuacs.backend.entity.StudentProfile;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.ClassRepository;\nimport com.fuacs.backend.repository.EnrollmentRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport com.fuacs.backend.repository.UserRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.util.*;\n\n@Service\npublic class EnrollmentService {\n\n    private static final Logger logger = LoggerFactory.getLogger(EnrollmentService.class);\n\n    private final EnrollmentRepository enrollmentRepository;\n    private final EnrollmentMapper enrollmentMapper;\n    private final ClassRepository classRepository;\n    private final UserRepository userRepository;\n    private final StudentProfileRepository studentProfileRepository;\n    private final CsvParserService csvParserService;\n    private final SlotRepository slotRepository;\n\n    public EnrollmentService(EnrollmentRepository enrollmentRepository,\n            EnrollmentMapper enrollmentMapper,\n            ClassRepository classRepository,\n            UserRepository userRepository,\n            StudentProfileRepository studentProfileRepository,\n            CsvParserService csvParserService,\n            SlotRepository slotRepository) {\n        this.enrollmentRepository = enrollmentRepository;\n        this.enrollmentMapper = enrollmentMapper;\n        this.classRepository = classRepository;\n        this.userRepository = userRepository;\n        this.studentProfileRepository = studentProfileRepository;\n        this.csvParserService = csvParserService;\n        this.slotRepository = slotRepository;\n    }\n\n    @Transactional\n    public EnrollmentDTO create(EnrollmentCreateRequest request) {\n        AcademicClass academicClass = classRepository.findById(request.getClassId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Class not found: \" + request.getClassId(),\n                        ErrorCode.CLASS_NOT_FOUND));\n        if (!academicClass.getActive()) {\n            throw new BadRequestException(\"Cannot enroll student into inactive class\",\n                    ErrorCode.INACTIVE_CLASS_NOT_ALLOWED);\n        }\n\n        // Validate student exists, is active, and has STUDENT role\n        StudentProfile student = studentProfileRepository.findById(request.getStudentUserId())\n                .orElseThrow(\n                        () -> new ResourceNotFoundException(\"Student profile not found: \" + request.getStudentUserId(),\n                                ErrorCode.STUDENT_PROFILE_NOT_FOUND));\n        if (!student.getUser().getActive()) {\n            throw new BadRequestException(\"Cannot enroll inactive student\", ErrorCode.INACTIVE_STUDENT_NOT_ALLOWED);\n        }\n\n        // Validate student major matches class's subject's majors\n        Set<Short> subjectMajorIds = academicClass.getSubject().getMajors()\n                .stream()\n                .map(major -> major.getId())\n                .collect(java.util.stream.Collectors.toSet());\n\n        if (!subjectMajorIds.contains(student.getMajor().getId())) {\n            throw new BadRequestException(\n                    \"Student's major (\" + student.getMajor().getCode() +\n                            \") is not eligible for this class's subject\",\n                    ErrorCode.STUDENT_MAJOR_NOT_MATCH\n            );\n        }\n\n        // Validate semester date range - enrollment only allowed before semester ends\n        java.time.LocalDate today = java.time.LocalDate.now(java.time.ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        java.time.LocalDate semesterEndDate = academicClass.getSemester().getEndDate();\n\n        if (today.isAfter(semesterEndDate)) {\n            throw new OperationNotAllowedException(\n                    \"Cannot modify enrollments after semester ends (ended: \" + semesterEndDate + \")\",\n                    ErrorCode.SEMESTER_ENDED\n            );\n        }\n\n        // Check if enrollment already exists\n        EnrollmentId enrollmentId = enrollmentMapper.createEnrollmentId(request.getClassId(),\n                request.getStudentUserId());\n\n        if (enrollmentRepository.existsById(enrollmentId)) {\n            Enrollment existingEnrollment = enrollmentRepository.findById(enrollmentId)\n                    .orElseThrow(() -> new ResourceNotFoundException(\"Enrollment not found\",\n                            ErrorCode.ENROLLMENT_NOT_FOUND));\n            if (existingEnrollment.getEnrolled()) {\n                throw new ResourceExistsException(\"Student is already enrolled in this class\",\n                        ErrorCode.ALREADY_ENROLLED);\n            } else {\n                // Re-enrollment case\n                existingEnrollment.setEnrolled(true);\n                Enrollment updatedEnrollment = enrollmentRepository.save(existingEnrollment);\n\n                // Map to DTO and populate student details\n                EnrollmentDTO dto = enrollmentMapper.toDTO(updatedEnrollment);\n                dto.setStudent(createStudentDTO(student));\n                return dto;\n            }\n        }\n\n        Enrollment enrollment = enrollmentMapper.toEntity(request);\n        enrollment.setEnrolled(true);\n        enrollment.setAcademicClass(academicClass);\n        enrollment.setStudent(student.getUser());\n        Enrollment savedEnrollment = enrollmentRepository.save(enrollment);\n\n        // Map to DTO and populate student details\n        EnrollmentDTO dto = enrollmentMapper.toDTO(savedEnrollment);\n        dto.setStudent(createStudentDTO(student));\n        return dto;\n    }\n\n    private StudentProfileDTO createStudentDTO(StudentProfile studentProfile) {\n        StudentProfileDTO dto = new StudentProfileDTO();\n        dto.setUserId(studentProfile.getUserId());\n        dto.setFullName(studentProfile.getUser().getFullName());\n        dto.setEmail(studentProfile.getUser().getEmail());\n        dto.setRollNumber(studentProfile.getRollNumber());\n\n        if (studentProfile.getMajor() != null) {\n            com.fuacs.backend.dto.response.MajorDTO majorDTO = new com.fuacs.backend.dto.response.MajorDTO();\n            majorDTO.setName(studentProfile.getMajor().getName());\n            majorDTO.setCode(studentProfile.getMajor().getCode());\n            dto.setMajor(majorDTO);\n        }\n\n        return dto;\n    }\n\n    public List<EnrollmentDTO> search(EnrollmentSearchRequest request) {\n        return enrollmentRepository.search(request);\n    }\n\n    public Long count(EnrollmentSearchRequest request) {\n        return enrollmentRepository.count(request);\n    }\n\n    @Transactional(readOnly = true)\n    public EnrollmentDTO findById(Short classId, Integer studentUserId) {\n        EnrollmentId enrollmentId = enrollmentMapper.createEnrollmentId(classId, studentUserId);\n        EnrollmentDTO enrollment = enrollmentRepository.findByEnrollmentId(enrollmentId);\n\n        if (enrollment == null) {\n            throw new ResourceNotFoundException(\n                    \"Enrollment not found for class \" + classId + \" and student \" + studentUserId,\n                    ErrorCode.ENROLLMENT_NOT_FOUND);\n        }\n\n        return enrollment;\n    }\n\n    @Transactional\n    public EnrollmentDTO update(Short classId, Integer studentUserId, EnrollmentUpdateRequest request) {\n        EnrollmentId enrollmentId = enrollmentMapper.createEnrollmentId(classId, studentUserId);\n        Enrollment enrollment = enrollmentRepository.findById(enrollmentId)\n                .orElseThrow(() -> new ResourceNotFoundException(\n                        \"Enrollment not found for class \" + classId + \" and student \" + studentUserId,\n                        ErrorCode.ENROLLMENT_NOT_FOUND));\n\n        // Validate semester date range - only allow withdrawal/re-enrollment before semester ends\n        java.time.LocalDate today = java.time.LocalDate.now(java.time.ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        java.time.LocalDate semesterEndDate = enrollment.getAcademicClass().getSemester().getEndDate();\n\n        if (today.isAfter(semesterEndDate)) {\n            throw new OperationNotAllowedException(\n                    \"Cannot modify enrollments after semester ends (ended: \" + semesterEndDate + \")\",\n                    ErrorCode.SEMESTER_ENDED\n            );\n        }\n\n        enrollmentMapper.updateEnrollmentFromRequest(request, enrollment);\n        enrollmentRepository.save(enrollment);\n\n        // Use repository method to get full DTO with student and class details\n        return enrollmentRepository.findByEnrollmentId(enrollmentId);\n    }\n\n    /**\n     * Hard delete enrollment record.\n     * Only allowed if the class has not started any slots yet.\n     *\n     * @param classId Class ID\n     * @param studentUserId Student user ID\n     * @throws ResourceNotFoundException if enrollment not found\n     * @throws OperationNotAllowedException if class has already started\n     */\n    @Transactional\n    public void delete(Short classId, Integer studentUserId) {\n        EnrollmentId enrollmentId = enrollmentMapper.createEnrollmentId(classId, studentUserId);\n\n        // Check enrollment exists\n        Enrollment enrollment = enrollmentRepository.findById(enrollmentId)\n                .orElseThrow(() -> new ResourceNotFoundException(\n                        \"Enrollment not found for class \" + classId + \" and student \" + studentUserId,\n                        ErrorCode.ENROLLMENT_NOT_FOUND));\n\n        // Get first slot start time for this class\n        LocalDateTime firstSlotStartTime = slotRepository.findFirstSlotStartTimeByClassId(classId);\n\n        // If class has slots, check if first slot has started\n        if (firstSlotStartTime != null) {\n            LocalDateTime now = LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n\n            if (!now.isBefore(firstSlotStartTime)) {\n                throw new OperationNotAllowedException(\n                        \"Cannot delete enrollment after class has started (first slot: \" + firstSlotStartTime + \")\",\n                        ErrorCode.CLASS_ALREADY_STARTED\n                );\n            }\n        }\n\n        // Hard delete the enrollment\n        enrollmentRepository.delete(enrollment);\n        logger.info(\"Deleted enrollment for class {} and student {}\", classId, studentUserId);\n    }\n\n    public List<StudentProfileDTO> findByClassId(Short classId, EnrollmentSearchRequest request) {\n        if (!classRepository.existsById(classId)) {\n            throw new ResourceNotFoundException(\"Class not found: \" + classId, ErrorCode.CLASS_NOT_FOUND);\n        }\n\n        return enrollmentRepository.findByClassId(classId, request);\n    }\n\n    public Long countByClassId(Short classId, EnrollmentSearchRequest request) {\n        if (!classRepository.existsById(classId)) {\n            throw new ResourceNotFoundException(\"Class not found: \" + classId, ErrorCode.CLASS_NOT_FOUND);\n        }\n\n        return enrollmentRepository.countByClassId(classId, request);\n    }\n\n    public Long countByClassId(Short classId, Boolean isEnrolled, String search) {\n        if (!classRepository.existsById(classId)) {\n            throw new ResourceNotFoundException(\"Class not found: \" + classId, ErrorCode.CLASS_NOT_FOUND);\n        }\n\n        return enrollmentRepository.countByClassId(classId, isEnrolled, search);\n    }\n\n    public Long countEnrolledByClassId(Short classId) {\n        if (!classRepository.existsById(classId)) {\n            throw new ResourceNotFoundException(\"Class not found: \" + classId, ErrorCode.CLASS_NOT_FOUND);\n        }\n\n        return enrollmentRepository.countEnrolledByClassId(classId);\n    }\n\n    public Long countWithdrawnByClassId(Short classId) {\n        if (!classRepository.existsById(classId)) {\n            throw new ResourceNotFoundException(\"Class not found: \" + classId, ErrorCode.CLASS_NOT_FOUND);\n        }\n\n        return enrollmentRepository.countWithdrawnByClassId(classId);\n    }\n\n    public boolean existsById(Short classId, Integer studentUserId) {\n        EnrollmentId enrollmentId = enrollmentMapper.createEnrollmentId(classId, studentUserId);\n        return enrollmentRepository.existsById(enrollmentId);\n    }\n\n    public boolean existsByIdAndIsEnrolled(Short classId, Integer studentUserId, boolean isEnrolled) {\n        EnrollmentId enrollmentId = enrollmentMapper.createEnrollmentId(classId, studentUserId);\n        return enrollmentRepository.existsByIdAndIsEnrolled(enrollmentId, isEnrolled);\n    }\n\n    /**\n     * Bulk enroll students from CSV file (legacy method)\n     * Delegates to importFromCsv with AddAndUpdate mode\n     *\n     * @param file CSV file with format: student_id,class_code,semester_code\n     * @return BulkEnrollmentResponse with success/failure details\n     * @deprecated Use importFromCsv() instead\n     */\n    @Deprecated\n    public BulkEnrollmentResponse bulkEnroll(MultipartFile file) {\n        // Delegate to new import method with AddAndUpdate mode\n        ImportResultDTO result = importFromCsv(file, \"AddAndUpdate\");\n\n        // Convert to legacy response format\n        BulkEnrollmentResponse response = new BulkEnrollmentResponse();\n        response.setTotalRows(result.getSuccessCount() + result.getFailureCount());\n        // Map new response to old response (simplified)\n        return response;\n    }\n\n    /**\n     * Import enrollments from CSV file with partial success pattern.\n     * Supports AddOnly and AddAndUpdate modes.\n     * NO @Transactional here to avoid rollback-only conflict.\n     *\n     * @param file CSV file with format: student_id,class_code,semester_code\n     * @param modeStr Import mode (\"AddOnly\" or \"AddAndUpdate\")\n     * @return ImportResultDTO with success/failure counts and error details\n     */\n    public ImportResultDTO importFromCsv(MultipartFile file, String modeStr) {\n        logger.info(\"Starting enrollment CSV import with mode: {}\", modeStr);\n\n        // Parse mode\n        ImportMode mode;\n        try {\n            mode = ImportMode.fromString(modeStr);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), ErrorCode.INVALID_IMPORT_MODE);\n        }\n\n        // Parse CSV\n        List<EnrollmentCsvRow> rows;\n        try {\n            rows = csvParserService.parseEnrollmentCsv(file);\n        } catch (IOException e) {\n            throw new BadRequestException(\"Failed to process CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        logger.info(\"Parsed {} rows from CSV\", rows.size());\n\n        // Deduplicate within file by business key\n        Map<String, EnrollmentCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (EnrollmentCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getUniqueKey(), row);\n        }\n\n        logger.info(\"After deduplication: {} unique enrollments\", uniqueRows.size());\n\n        // Process rows with partial success\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (EnrollmentCsvRow row : uniqueRows.values()) {\n            try {\n                processOneEnrollmentRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                logger.warn(\"Failed to process row {}: {}\", row.getRowNumber(), e.getMessage());\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()\n                ));\n            }\n        }\n\n        logger.info(\"Enrollment import completed: {} successful, {} failed\", successCount, errors.size());\n\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Process a single enrollment row in a separate transaction.\n     * This ensures one row's failure doesn't affect others (partial success).\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneEnrollmentRow(EnrollmentCsvRow row, ImportMode mode) {\n        // Validate row\n        if (!row.isValid()) {\n            throw new BadRequestException(\"Invalid row data\", ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Find student by roll number (with eager fetch of User and Major to avoid lazy loading issues)\n        StudentProfile student = studentProfileRepository.findByRollNumberWithUserAndMajor(row.getRollNumber());\n        if (student == null) {\n            throw new ResourceNotFoundException(\n                    \"Student not found with roll number: \" + row.getRollNumber(),\n                    ErrorCode.STUDENT_NOT_FOUND\n            );\n        }\n\n        // Check if student is active\n        if (!student.getUser().getActive()) {\n            throw new BadRequestException(\n                    \"Cannot enroll inactive student: \" + row.getRollNumber(),\n                    ErrorCode.INACTIVE_STUDENT_NOT_ALLOWED\n            );\n        }\n\n        // Find class by code and semester code (with eager fetch of Subject+majors and Semester to avoid lazy loading issues)\n        AcademicClass academicClass = classRepository.findByCodeAndSemesterCodeWithSubjectAndSemester(\n                row.getClassCode(), row.getSemesterCode());\n        if (academicClass == null) {\n            throw new ResourceNotFoundException(\n                    \"Class not found for code \" + row.getClassCode() +\n                            \" and semester \" + row.getSemesterCode(),\n                    ErrorCode.CLASS_NOT_FOUND\n            );\n        }\n\n        // Check if class is active\n        if (!academicClass.getActive()) {\n            throw new BadRequestException(\n                    \"Cannot enroll student into inactive class: \" + row.getClassCode(),\n                    ErrorCode.INACTIVE_CLASS_NOT_ALLOWED\n            );\n        }\n\n        // Validate student major matches class's subject's majors\n        Set<Short> subjectMajorIds = academicClass.getSubject().getMajors()\n                .stream()\n                .map(major -> major.getId())\n                .collect(java.util.stream.Collectors.toSet());\n\n        if (!subjectMajorIds.contains(student.getMajor().getId())) {\n            throw new BadRequestException(\n                    \"Student \" + row.getRollNumber() + \" with major (\" + student.getMajor().getCode() +\n                            \") is not eligible for class \" + row.getClassCode(),\n                    ErrorCode.STUDENT_MAJOR_NOT_MATCH\n            );\n        }\n\n        // Validate semester date range - enrollment only allowed before semester ends\n        java.time.LocalDate today = java.time.LocalDate.now(java.time.ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        java.time.LocalDate semesterEndDate = academicClass.getSemester().getEndDate();\n\n        if (today.isAfter(semesterEndDate)) {\n            throw new OperationNotAllowedException(\n                    \"Cannot modify enrollments after semester ends (ended: \" + semesterEndDate + \")\",\n                    ErrorCode.SEMESTER_ENDED\n            );\n        }\n\n        // Check if enrollment already exists\n        EnrollmentId enrollmentId = enrollmentMapper.createEnrollmentId(\n                academicClass.getId(), student.getUserId());\n\n        if (enrollmentRepository.existsById(enrollmentId)) {\n            Enrollment existingEnrollment = enrollmentRepository.findById(enrollmentId)\n                    .orElseThrow(() -> new ResourceNotFoundException(\n                            \"Enrollment not found\", ErrorCode.ENROLLMENT_NOT_FOUND));\n\n            if (existingEnrollment.getEnrolled()) {\n                // Already enrolled\n                if (mode == ImportMode.ADD_ONLY) {\n                    throw new ResourceExistsException(\n                            \"Student \" + row.getRollNumber() + \" is already enrolled in class \" + row.getClassCode(),\n                            ErrorCode.ALREADY_ENROLLED\n                    );\n                }\n                // AddAndUpdate mode: skip if already enrolled (no update needed)\n            } else {\n                // Re-enrollment case (was withdrawn before)\n                existingEnrollment.setEnrolled(true);\n                existingEnrollment.setUpdatedAt(Instant.now());\n                enrollmentRepository.save(existingEnrollment);\n            }\n        } else {\n            // Create new enrollment\n            Enrollment enrollment = new Enrollment();\n            enrollment.setId(enrollmentId);\n            enrollment.setEnrolled(true);\n            enrollment.setAcademicClass(academicClass);\n            enrollment.setStudent(student.getUser());\n            enrollment.setCreatedAt(Instant.now());\n            enrollment.setUpdatedAt(Instant.now());\n            enrollmentRepository.save(enrollment);\n        }\n    }\n\n    /**\n     * Extract error code from exception.\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\EvidenceStorageService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/EvidenceStorageService.java",
      "filename": "EvidenceStorageService.java",
      "size_bytes": 4239,
      "lines": 128,
      "last_modified": "2025-11-14T16:49:05.061297",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.client.RestTemplate;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\n/**\n * Service for downloading and storing evidence images from recognition-service\n */\n@Service\npublic class EvidenceStorageService {\n\n    private static final Logger log = LoggerFactory.getLogger(EvidenceStorageService.class);\n    private static final String EVIDENCE_BASE_DIR = \"./uploads/evidence\";\n    \n    private final RestTemplate restTemplate;\n\n    public EvidenceStorageService() {\n        this.restTemplate = new RestTemplate();\n        // Create base directory if not exists\n        createDirectoryIfNotExists(EVIDENCE_BASE_DIR);\n    }\n\n    /**\n     * Download image from recognition-service and save locally\n     * \n     * @param sourceUrl Full URL from recognition-service (e.g., http://localhost:8000/uploads/evidence/9001/9001_SE123456.jpg)\n     * @param slotId Slot ID for organizing files\n     * @param filename Filename to save as\n     * @return Local relative path (e.g., /evidence/9001/9001_SE123456.jpg) or null if failed\n     */\n    public String downloadAndSaveEvidence(String sourceUrl, Integer slotId, String filename) {\n        if (sourceUrl == null || sourceUrl.isBlank()) {\n            return null;\n        }\n\n        try {\n            // Create slot-specific directory\n            String slotDir = EVIDENCE_BASE_DIR + \"/\" + slotId;\n            createDirectoryIfNotExists(slotDir);\n\n            // Download image bytes\n            byte[] imageBytes = restTemplate.getForObject(sourceUrl, byte[].class);\n            \n            if (imageBytes == null || imageBytes.length == 0) {\n                log.error(\"Downloaded image is empty from: {}\", sourceUrl);\n                return null;\n            }\n\n            // Save to local file\n            String localPath = slotDir + \"/\" + filename;\n            File outputFile = new File(localPath);\n            \n            try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n                fos.write(imageBytes);\n            }\n\n            // Return relative path for URL (without leading dot)\n            return \"/evidence/\" + slotId + \"/\" + filename;\n            \n        } catch (Exception e) {\n            log.error(\"Failed to download and save evidence from {}: {}\", sourceUrl, e.getMessage(), e);\n            return null;\n        }\n    }\n\n    /**\n     * Extract filename from URL\n     * Example: http://localhost:8000/uploads/evidence/9001/9001_SE123456.jpg -> 9001_SE123456.jpg\n     */\n    public String extractFilenameFromUrl(String url) {\n        if (url == null || url.isBlank()) {\n            return null;\n        }\n        \n        int lastSlashIndex = url.lastIndexOf('/');\n        if (lastSlashIndex >= 0 && lastSlashIndex < url.length() - 1) {\n            return url.substring(lastSlashIndex + 1);\n        }\n        \n        return null;\n    }\n\n    /**\n     * Create directory if it doesn't exist\n     */\n    private void createDirectoryIfNotExists(String dirPath) {\n        try {\n            Path path = Paths.get(dirPath);\n            if (!Files.exists(path)) {\n                Files.createDirectories(path);\n            }\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Delete evidence file\n     */\n    public boolean deleteEvidence(String relativePath) {\n        if (relativePath == null || relativePath.isBlank()) {\n            return false;\n        }\n\n        try {\n            // Convert relative path to absolute\n            String absolutePath = \".\" + relativePath;\n            File file = new File(absolutePath);\n            \n            if (file.exists() && file.delete()) {\n                return true;\n            }\n            \n            return false;\n        } catch (Exception e) {\n            log.error(\"Failed to delete evidence {}: {}\", relativePath, e.getMessage());\n            return false;\n        }\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\ExamAttendanceReportService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/ExamAttendanceReportService.java",
      "filename": "ExamAttendanceReportService.java",
      "size_bytes": 8016,
      "lines": 199,
      "last_modified": "2025-11-15T17:13:58.152586",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.enums.SessionStatus;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.dto.response.*;\nimport com.fuacs.backend.entity.*;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.*;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.util.List;\n\n@Service\npublic class ExamAttendanceReportService {\n\n    private final SlotRepository slotRepository;\n    private final ExamSlotSubjectRepository examSlotSubjectRepository;\n    private final ExamSlotParticipantRepository examSlotParticipantRepository;\n\n    public ExamAttendanceReportService(SlotRepository slotRepository,\n                                     ExamSlotSubjectRepository examSlotSubjectRepository,\n                                     ExamSlotParticipantRepository examSlotParticipantRepository) {\n        this.slotRepository = slotRepository;\n        this.examSlotSubjectRepository = examSlotSubjectRepository;\n        this.examSlotParticipantRepository = examSlotParticipantRepository;\n    }\n\n    /**\n     * Get comprehensive exam attendance report including slot information, subjects, students, and attendance data\n     * \n     * @param slotId The exam slot ID\n     * @return ExamAttendanceReportDTO with all slot details and attendance information\n     * @throws ResourceNotFoundException if slot not found\n     * @throws BadRequestException if slot is not a final exam slot\n     */\n    @Transactional(readOnly = true)\n    public ExamAttendanceReportDTO getExamAttendanceReport(Integer slotId) {\n        // Validate slot ID parameter\n        if (slotId == null || slotId <= 0) {\n            throw new BadRequestException(\"Invalid slot ID: \" + slotId, ErrorCode.BAD_REQUEST);\n        }\n\n        // Fetch slot with room and staff information using optimized query\n        Slot slot = slotRepository.findByIdWithRoomAndStaff(slotId);\n        if (slot == null) {\n            throw new ResourceNotFoundException(\"Exam slot not found: \" + slotId, ErrorCode.SLOT_NOT_FOUND);\n        }\n\n        // Validate slot is a final exam slot\n        if (slot.getSlotCategory() != SlotCategory.FINAL_EXAM) {\n            throw new BadRequestException(\"Slot must be FINAL_EXAM type\", ErrorCode.INVALID_SLOT_TYPE);\n        }\n\n        // Build slot basic information\n        RoomDTO roomDTO = buildRoomDTO(slot.getRoom());\n        UserDTO staffDTO = buildUserDTO(slot.getStaff());\n        SessionStatus sessionStatus = determineSessionStatus(slot);\n\n        // Get subjects assigned to this exam slot\n        List<SubjectDTO> subjects = examSlotSubjectRepository.findSubjectsBySlotId(slotId);\n\n        // Get students with attendance information using optimized query\n        List<StudentAttendanceInfoDTO> students = examSlotParticipantRepository.findStudentsWithAttendanceBySlotId(slotId);\n\n        // Calculate statistics\n        ExamSlotStatisticsDTO statistics = calculateStatistics(students);\n\n        return new ExamAttendanceReportDTO(\n                slot.getId(),\n                slot.getTitle(),\n                slot.getDescription(),\n                slot.getStartTime(),\n                slot.getEndTime(),\n                roomDTO,\n                staffDTO,\n                sessionStatus,\n                subjects,\n                students,\n                statistics\n        );\n    }\n\n    /**\n     * Build RoomDTO from Room entity\n     */\n    private RoomDTO buildRoomDTO(Room room) {\n        if (room == null) {\n            return null;\n        }\n        RoomDTO roomDTO = new RoomDTO();\n        roomDTO.setId(room.getId());\n        roomDTO.setName(room.getName());\n        roomDTO.setLocation(room.getLocation());\n        return roomDTO;\n    }\n\n    /**\n     * Build UserDTO from User entity (for staff information)\n     */\n    private UserDTO buildUserDTO(User user) {\n        if (user == null) {\n            return null;\n        }\n        UserDTO userDTO = new UserDTO();\n        userDTO.setId(user.getId());\n        userDTO.setFullName(user.getFullName());\n        userDTO.setEmail(user.getEmail());\n        userDTO.setUsername(user.getUsername());\n        return userDTO;\n    }\n\n    /**\n     * Determine session status based on current time and slot timing\n     */\n    private SessionStatus determineSessionStatus(Slot slot) {\n        LocalDateTime now = LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        \n        if (now.isBefore(slot.getStartTime())) {\n            return SessionStatus.NOT_STARTED;\n        } else if (now.isAfter(slot.getEndTime())) {\n            return SessionStatus.COMPLETED;\n        } else {\n            return SessionStatus.IN_PROGRESS;\n        }\n    }\n\n    /**\n     * Get comprehensive exam attendance report for a specific user with authorization check.\n     * This method validates that the requesting user is the owner (assigned staff) of the slot\n     * before returning the exam attendance report.\n     * \n     * @param slotId The exam slot ID\n     * @param userId The requesting user ID (must be the slot owner)\n     * @return ExamAttendanceReportDTO with all slot details and attendance information\n     * @throws ResourceNotFoundException if slot not found\n     * @throws BadRequestException if slot is not a final exam slot\n     * @throws OperationNotAllowedException if user is not authorized to access this slot\n     */\n    @Transactional(readOnly = true)\n    public ExamAttendanceReportDTO getExamAttendanceReportForUser(Integer slotId, Integer userId) {\n        // Validate input parameters\n        if (slotId == null || slotId <= 0) {\n            throw new BadRequestException(\"Invalid slot ID: \" + slotId, ErrorCode.BAD_REQUEST);\n        }\n        \n        if (userId == null || userId <= 0) {\n            throw new BadRequestException(\"Invalid user ID: \" + userId, ErrorCode.BAD_REQUEST);\n        }\n\n        // Check if slot exists and user is the owner (assigned staff)\n        boolean isSlotOwner = slotRepository.existsByIdAndStaffId(slotId, userId);\n        if (!isSlotOwner) {\n            // Check if slot exists at all to provide appropriate error message\n            boolean slotExists = slotRepository.existsById(slotId);\n            if (!slotExists) {\n                throw new ResourceNotFoundException(\"Exam slot not found: \" + slotId, ErrorCode.SLOT_NOT_FOUND);\n            } else {\n                // Slot exists but user is not the owner\n                throw new OperationNotAllowedException(\"Access denied to this slot\", ErrorCode.FORBIDDEN);\n            }\n        }\n\n        // User is authorized, reuse existing logic to get the report\n        return getExamAttendanceReport(slotId);\n    }\n\n    /**\n     * Calculate attendance statistics\n     */\n    private ExamSlotStatisticsDTO calculateStatistics(List<StudentAttendanceInfoDTO> students) {\n        int totalStudents = students.size();\n        int presentCount = 0;\n        int absentCount = 0;\n        int notYetCount = 0;\n\n        for (StudentAttendanceInfoDTO student : students) {\n            switch (student.getStatus()) {\n                case PRESENT:\n                    presentCount++;\n                    break;\n                case ABSENT:\n                    absentCount++;\n                    break;\n                case NOT_YET:\n                    // NOT_YET means student has not been marked yet\n                    notYetCount++;\n                    break;\n            }\n        }\n\n        return new ExamSlotStatisticsDTO(totalStudents, presentCount, absentCount, notYetCount);\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\ExamAttendanceService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/ExamAttendanceService.java",
      "filename": "ExamAttendanceService.java",
      "size_bytes": 23951,
      "lines": 525,
      "last_modified": "2025-11-21T19:16:59.615653",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.enums.AttendanceMethod;\nimport com.fuacs.backend.constant.enums.AttendanceStatus;\nimport com.fuacs.backend.constant.enums.ScanMode;\nimport com.fuacs.backend.dto.request.RecognitionResultRequest;\nimport com.fuacs.backend.dto.response.ExamAttendanceDTO;\nimport com.fuacs.backend.dto.response.RemarkDTO;\nimport com.fuacs.backend.dto.response.SlotDTO;\nimport com.fuacs.backend.dto.response.StudentProfileDTO;\nimport com.fuacs.backend.entity.ExamAttendance;\nimport com.fuacs.backend.entity.ExamAttendanceEvidence;\nimport com.fuacs.backend.entity.Slot;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.dto.request.ExamAttendanceUpdateRequest;\nimport com.fuacs.backend.repository.ExamAttendanceEvidenceRepository;\nimport com.fuacs.backend.repository.ExamAttendanceRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport com.fuacs.backend.repository.UserRepository;\nimport com.fuacs.backend.repository.EnrollmentRepository;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport com.fuacs.backend.entity.EnrollmentId;\nimport com.fuacs.backend.realtime.SseHub;\nimport com.fuacs.backend.dto.realtime.AttendanceUpdateEvent;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n@Service\npublic class ExamAttendanceService {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExamAttendanceService.class);\n\n    private final ExamAttendanceRepository examAttendanceRepository;\n    private final ExamAttendanceEvidenceRepository examAttendanceEvidenceRepository;\n    private final SlotRepository slotRepository;\n    private final UserRepository userRepository;\n    private final EnrollmentRepository enrollmentRepository;\n    private final StudentProfileRepository studentProfileRepository;\n    private final EvidenceStorageService evidenceStorageService;\n    private final SseHub sseHub;\n\n    public ExamAttendanceService(ExamAttendanceRepository examAttendanceRepository,\n            ExamAttendanceEvidenceRepository examAttendanceEvidenceRepository,\n            SlotRepository slotRepository,\n            UserRepository userRepository,\n            EnrollmentRepository enrollmentRepository,\n            StudentProfileRepository studentProfileRepository,\n            EvidenceStorageService evidenceStorageService,\n            SseHub sseHub) {\n        this.examAttendanceRepository = examAttendanceRepository;\n        this.examAttendanceEvidenceRepository = examAttendanceEvidenceRepository;\n        this.slotRepository = slotRepository;\n        this.userRepository = userRepository;\n        this.enrollmentRepository = enrollmentRepository;\n        this.studentProfileRepository = studentProfileRepository;\n        this.evidenceStorageService = evidenceStorageService;\n        this.sseHub = sseHub;\n    }\n\n    @Transactional(readOnly = true)\n    public ExamAttendanceDTO findById(Long id) {\n        ExamAttendance ea = examAttendanceRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam attendance record not found: \" + id,\n                        ErrorCode.EXAM_ATTENDANCE_NOT_FOUND));\n\n        return toDTO(ea, true);\n    }\n\n    @Transactional(readOnly = true)\n    public java.util.List<ExamAttendanceDTO> findAll(\n            com.fuacs.backend.dto.request.ExamAttendanceSearchRequest request) {\n        return examAttendanceRepository.search(request);\n    }\n\n    @Transactional(readOnly = true)\n    public Long count(com.fuacs.backend.dto.request.ExamAttendanceSearchRequest request) {\n        return examAttendanceRepository.count(request);\n    }\n\n    @Transactional\n    public ExamAttendanceDTO updateStatus(Long id, ExamAttendanceUpdateRequest request, Integer currentUserId) {\n        ExamAttendance ea = examAttendanceRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam attendance record not found: \" + id,\n                        ErrorCode.EXAM_ATTENDANCE_NOT_FOUND));\n\n        Slot slot = ea.getSlot();\n\n        // Check if slot is active\n        if (!slot.getActive()) {\n            throw new BadRequestException(\n                    \"Cannot update exam attendance for inactive slot\",\n                    ErrorCode.INACTIVE_SLOT_NOT_ALLOWED);\n        }\n\n        // Assigned staff only (controller enforces permission, we double-check\n        // assignment)\n        if (!slot.getStaff().getId().equals(currentUserId)) {\n            throw new OperationNotAllowedException(\"You are not assigned to this slot and cannot edit exam attendance\",\n                    ErrorCode.NOT_ASSIGNED_TO_SLOT);\n        }\n\n        // Time-based window validation\n        validateEditWindow(slot);\n\n        // Optional guard: for class-based slots (LECTURE_WITH_PT), ensure student is\n        // enrolled\n        if (slot.getAcademicClass() != null) {\n            Short classId = slot.getAcademicClass().getId();\n            EnrollmentId eid = new EnrollmentId(classId, ea.getStudent().getId());\n            boolean enrolled = enrollmentRepository.existsByIdAndIsEnrolled(eid, true);\n            if (!enrolled) {\n                throw new OperationNotAllowedException(\"Student is not enrolled in this class\",\n                        ErrorCode.STUDENT_NOT_ENROLLED_IN_CLASS);\n            }\n        }\n\n        // Transition validation (simple: allow any manual change)\n        AttendanceStatus newStatus = request.getStatus();\n        if (newStatus == null) {\n            throw new BadRequestException(\"Status is required\", ErrorCode.STATUS_REQUIRED);\n        }\n\n        ea.setStatus(newStatus);\n        ea.setMethod(AttendanceMethod.MANUAL);\n        ea.setRecordedAt(Instant.now());\n\n        // Set remark inline (overwrites existing remark)\n        if (request.getRemark() != null && !request.getRemark().trim().isEmpty()) {\n            ea.setRemark(request.getRemark().trim());\n        }\n\n        // Save\n        ea = examAttendanceRepository.save(ea);\n\n        return toDTO(ea, true);\n    }\n\n    private void validateEditWindow(Slot slot) {\n        // Convert LocalDateTime to ZonedDateTime with Vietnam timezone\n        LocalDateTime slotStart = slot.getStartTime();\n        ZonedDateTime slotStartVN = slotStart.atZone(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        LocalDate slotDateVN = slotStartVN.toLocalDate();\n\n        // Create cutoff at 23:59:59 Vietnam time on the slot date\n        ZonedDateTime cutoffVN = slotDateVN.atTime(23, 59, 59).atZone(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        ZonedDateTime nowVN = ZonedDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n\n        // Check 1: Slot must have started (reject edit before slot start time)\n        if (nowVN.isBefore(slotStartVN)) {\n            throw new OperationNotAllowedException(\n                    \"Cannot edit exam attendance before slot start time\",\n                    ErrorCode.EDIT_BEFORE_SLOT_START);\n        }\n\n        // Check 2: Cutoff time window (23:59:59 Vietnam time on slot date)\n        if (nowVN.isAfter(cutoffVN)) {\n            boolean hasManualPermission = com.fuacs.backend.util.SecurityUtil.getUserAuthentication()\n                    .map(com.fuacs.backend.config.UserAuthentication::getPermissions)\n                    .map(p -> p.contains(\"ATTENDANCE_STATUS_UPDATE_MANUAL\"))\n                    .orElse(false);\n            if (!hasManualPermission) {\n                throw new OperationNotAllowedException(\n                        \"Edit window has expired. Only Data Operator can edit exam attendance after 23:59:59 Vietnam time of slot date\",\n                        ErrorCode.EDIT_WINDOW_EXPIRED);\n            }\n        }\n    }\n\n    private ExamAttendanceDTO toDTO(ExamAttendance ea, boolean includeRemarks) {\n        // Build StudentProfileDTO (minimal)\n        User stu = ea.getStudent();\n        StudentProfileDTO student = new StudentProfileDTO();\n        student.setUserId(stu.getId());\n        student.setFullName(stu.getFullName());\n        student.setEmail(stu.getEmail());\n        student.setUsername(stu.getUsername());\n\n        // Fetch rollNumber from StudentProfile\n        studentProfileRepository.findById(stu.getId()).ifPresent(profile -> {\n            student.setRollNumber(profile.getRollNumber());\n        });\n\n        // Build SlotDTO (minimal)\n        Slot slot = ea.getSlot();\n        SlotDTO slotDTO = new SlotDTO(\n                slot.getId(),\n                slot.getTitle(),\n                slot.getDescription(),\n                slot.getStartTime(),\n                slot.getEndTime(),\n                slot.getSlotCategory(),\n                slot.getActive(),\n                slot.getCreatedAt(),\n                slot.getUpdatedAt(),\n                null,\n                null);\n\n        return new ExamAttendanceDTO(\n                true,\n                ea.getCreatedAt(),\n                ea.getUpdatedAt(),\n                ea.getId(),\n                student,\n                slotDTO,\n                null,\n                ea.getStatus(),\n                ea.getMethod(),\n                ea.getRecordedAt(),\n                ea.getRemark(),\n                ea.getNeedsReview());\n    }\n\n    // ========== Recognition Callback Processing ==========\n\n    /**\n     * Process recognition results from Python service for EXAM attendance.\n     * PRESENT status is preserved - once marked PRESENT, remains PRESENT.\n     *\n     * This method handles face recognition callbacks for exam sessions (both\n     * LECTURE_WITH_PT and FINAL_EXAM).\n     *\n     * @param request Recognition results from Python service\n     * @return Map with processing statistics\n     */\n    @Transactional\n    public Map<String, Object> processRecognitionResults(RecognitionResultRequest request) {\n        Integer slotId = request.getSlotId();\n        Slot slot = slotRepository.findById(slotId)\n                .orElseThrow(\n                        () -> new ResourceNotFoundException(\"Slot not found: \" + slotId, ErrorCode.SLOT_NOT_FOUND));\n\n        // Check if slot is active\n        if (!slot.getActive()) {\n            throw new BadRequestException(\n                    \"Cannot process exam attendance for inactive slot\",\n                    ErrorCode.INACTIVE_SLOT_NOT_ALLOWED);\n        }\n\n        ScanMode mode = request.getMode() != null ? request.getMode() : ScanMode.INITIAL;\n        List<RecognitionResultRequest.RecognitionItem> recognitions = request.getRecognitions();\n\n        logger.info(\"Processing {} exam recognition results for slot {} in {} mode\",\n                recognitions.size(), slotId, mode);\n\n        int totalRecognitions = recognitions.size();\n        int successCount = 0;\n        int skippedCount = 0;\n        int keptPresentCount = 0; // Students who remain PRESENT (status unchanged)\n        List<Map<String, Object>> results = new ArrayList<>();\n\n        // Process each recognition\n        for (RecognitionResultRequest.RecognitionItem recognition : recognitions) {\n            Integer studentUserId = recognition.getStudentUserId();\n\n            // Find exam attendance record\n            ExamAttendance record = examAttendanceRepository.findBySlotIdAndStudentUserId(slotId, studentUserId);\n\n            if (record == null) {\n                // Student not in exam roster - skip\n                logger.warn(\"Student {} not found in exam roster for slot {}\", studentUserId, slotId);\n                results.add(Map.of(\n                        \"studentUserId\", studentUserId,\n                        \"status\", \"skipped\",\n                        \"reason\", \"Student not in exam roster\"));\n                skippedCount++;\n                continue;\n            }\n\n            AttendanceStatus currentStatus = record.getStatus();\n            Map<String, Object> result = new HashMap<>();\n            result.put(\"studentUserId\", studentUserId);\n            result.put(\"previousStatus\", currentStatus.name());\n\n            // NEW LOGIC: Override ABSENT in both INITIAL and RESCAN modes\n            // INITIAL: Student arrived but was manually marked absent before scan → Override to PRESENT\n            // RESCAN: Late arrival - student was ABSENT but now detected → Override to PRESENT\n            if (currentStatus == AttendanceStatus.NOT_YET || currentStatus == AttendanceStatus.ABSENT) {\n                AttendanceStatus previousStatus = currentStatus;\n\n                // Update to PRESENT\n                record.setStatus(AttendanceStatus.PRESENT);\n                record.setMethod(AttendanceMethod.AUTO);\n                record.setRecordedAt(Instant.now());\n                record.setNeedsReview(false); // Clear any existing review flags\n                examAttendanceRepository.save(record);\n\n                result.put(\"status\", \"updated\");\n                result.put(\"newStatus\", \"PRESENT\");\n                result.put(\"details\", \"Updated exam attendance (override from \" + previousStatus + \")\");\n                successCount++;\n\n                // Publish SSE update for status change (without evidence yet)\n                tryPublish(\n                        slotId,\n                        studentUserId,\n                        \"exam\",\n                        record.getId(),\n                        AttendanceStatus.PRESENT.name().toLowerCase(),\n                        AttendanceMethod.AUTO.name().toLowerCase(),\n                        record.getRecordedAt() != null ? record.getRecordedAt().toString() : null,\n                        null // evidenceImageUrl will be published separately if available\n                );\n\n                // Store evidence image if provided\n                RecognitionResultRequest.Evidence evidence = recognition.getEvidence();\n                if (evidence != null) {\n                    String sourceImageUrl = evidence.getExamImageUrl();\n                    if (sourceImageUrl != null && !sourceImageUrl.isBlank()) {\n                        try {\n                            // Download image from recognition-service\n                            String filename = evidenceStorageService.extractFilenameFromUrl(sourceImageUrl);\n                            String localImagePath = evidenceStorageService.downloadAndSaveEvidence(\n                                sourceImageUrl,\n                                slot.getId(),\n                                filename\n                            );\n\n                            if (localImagePath != null) {\n                                ExamAttendanceEvidence ev = examAttendanceEvidenceRepository\n                                        .findByExamAttendanceId(record.getId());\n                                if (ev == null) {\n                                    ev = new ExamAttendanceEvidence();\n                                    ev.setExamAttendance(record);\n                                } else {\n                                    // Delete old image if exists\n                                    if (ev.getImageUrl() != null) {\n                                        evidenceStorageService.deleteEvidence(ev.getImageUrl());\n                                    }\n                                }\n                                ev.setImageUrl(localImagePath);\n                                examAttendanceEvidenceRepository.save(ev);\n\n                                // Re-publish SSE update with evidence URL\n                                tryPublish(\n                                        slotId,\n                                        studentUserId,\n                                        \"exam\",\n                                        record.getId(),\n                                        AttendanceStatus.PRESENT.name().toLowerCase(),\n                                        AttendanceMethod.AUTO.name().toLowerCase(),\n                                        record.getRecordedAt() != null ? record.getRecordedAt().toString() : null,\n                                        localImagePath // evidenceImageUrl now available\n                                );\n                            } else {\n                                logger.error(\"Failed to download exam evidence image from: {}\", sourceImageUrl);\n                            }\n                        } catch (Exception e) {\n                            logger.error(\"Error processing exam evidence for student {}: {}\",\n                                studentUserId, e.getMessage());\n                        }\n                    }\n                }\n            } else if (currentStatus == AttendanceStatus.PRESENT) {\n                // Already PRESENT - no changes needed\n                result.put(\"status\", \"kept_present\");\n                result.put(\"newStatus\", \"PRESENT\");\n                result.put(\"reason\", \"Already PRESENT (status unchanged)\");\n                keptPresentCount++;\n            }\n\n            results.add(result);\n        }\n\n        logger.info(\"Exam recognition processing completed: slot={}, mode={}, total={}, success={}, kept_present={}, skipped={}\",\n                slotId, mode, totalRecognitions, successCount, keptPresentCount, skippedCount);\n\n        return Map.of(\n                \"slotId\", slotId,\n                \"mode\", mode.name(),\n                \"attendanceType\", \"EXAM\",\n                \"totalRecognitions\", totalRecognitions,\n                \"successCount\", successCount,\n                \"keptPresentCount\", keptPresentCount,\n                \"skippedCount\", skippedCount,\n                \"results\", results\n        );\n    }\n\n    /**\n     * Publish SSE attendance update event\n     * Pattern copied from AttendanceRecordService for consistency\n     */\n    private void tryPublish(Integer slotId,\n                            Integer studentUserId,\n                            String kind,\n                            Long recordId,\n                            String status,\n                            String method,\n                            String recordedAt,\n                            String evidenceImageUrl) {\n        try {\n            AttendanceUpdateEvent evt = new AttendanceUpdateEvent(\n                    slotId,\n                    studentUserId,\n                    kind,\n                    recordId,\n                    status,\n                    method,\n                    recordedAt,\n                    evidenceImageUrl\n            );\n            sseHub.publishAttendanceUpdate(slotId, evt);\n        } catch (Exception e) {\n            logger.warn(\"Failed to publish SSE attendance.update: {}\", e.getMessage());\n        }\n    }\n\n    /**\n     * Publish SSE update with needsReview field (for RESCAN mode)\n     */\n    private void tryPublishWithReview(Integer slotId,\n                                      Integer studentUserId,\n                                      String kind,\n                                      Long recordId,\n                                      String status,\n                                      String method,\n                                      String recordedAt,\n                                      String evidenceImageUrl,\n                                      Boolean needsReview) {\n        try {\n            AttendanceUpdateEvent evt = new AttendanceUpdateEvent(\n                    slotId,\n                    studentUserId,\n                    kind,\n                    recordId,\n                    status,\n                    method,\n                    recordedAt,\n                    evidenceImageUrl,\n                    needsReview\n            );\n            sseHub.publishAttendanceUpdate(slotId, evt);\n        } catch (Exception e) {\n            logger.warn(\"Failed to publish SSE attendance.update with needsReview: {}\", e.getMessage());\n        }\n    }\n\n    /**\n     * Apply review flags after RESCAN session stops (EXAM mode)\n     * Called from SlotSessionService.stopExamSession() with recognized student IDs from Python response\n     *\n     * For EXAM attendance, the logic is:\n     * - PRESENT but NOT detected → Set needsReview=TRUE (potential early departure from exam)\n     * - PRESENT and detected → Clear needsReview=FALSE (confirmed presence)\n     * - ABSENT detected → Already handled by processRecognitionResults (override to PRESENT)\n     *\n     * @param slot The slot being rescanned\n     * @param detectedStudentIds Set of student IDs detected during RESCAN\n     * @return Map with statistics (presentNotDetected, presentConfirmed)\n     */\n    public Map<String, Object> applyRescanReviewFlags(Slot slot, Set<Integer> detectedStudentIds) {\n        logger.info(\"Applying RESCAN review flags (EXAM): slotId={}, detectedCount={}\", slot.getId(), detectedStudentIds.size());\n\n        List<ExamAttendance> allRecords = examAttendanceRepository.findBySlotId(slot.getId());\n\n        int presentConfirmedCount = 0;\n\n        for (ExamAttendance record : allRecords) {\n            Integer studentId = record.getStudent().getId();\n            boolean wasDetected = detectedStudentIds.contains(studentId);\n            boolean changed = false;\n\n            // EXAM RESCAN: Trust PRESENT students (no needsReview if not detected)\n            // Assumption: Student finished exam early and left before rescan\n\n            // Only case: PRESENT and detected → Clear needsReview to confirm presence\n            if (record.getStatus() == AttendanceStatus.PRESENT && wasDetected) {\n                if (Boolean.TRUE.equals(record.getNeedsReview())) {\n                    record.setNeedsReview(false);\n                    changed = true;\n                }\n                presentConfirmedCount++;\n            }\n            // Note: PRESENT not detected → No action (trust them, no needsReview)\n            // Note: ABSENT cases already handled by processRecognitionResults (override to PRESENT)\n\n            // Publish SSE update if changed\n            if (changed) {\n                ExamAttendanceEvidence evidence = examAttendanceEvidenceRepository\n                        .findByExamAttendanceId(record.getId());\n                String evidenceUrl = evidence != null ? evidence.getImageUrl() : null;\n\n                tryPublishWithReview(\n                    slot.getId(),\n                    record.getStudent().getId(),\n                    \"exam\",\n                    record.getId(),\n                    record.getStatus().name().toLowerCase(),\n                    record.getMethod().name().toLowerCase(),\n                    record.getRecordedAt() != null ? record.getRecordedAt().toString() : null,\n                    evidenceUrl,\n                    record.getNeedsReview()\n                );\n            }\n        }\n\n        examAttendanceRepository.saveAll(allRecords);\n\n        Map<String, Object> result = new java.util.HashMap<>();\n        result.put(\"presentConfirmed\", presentConfirmedCount);\n        result.put(\"totalProcessed\", allRecords.size());\n\n        logger.info(\"RESCAN review flags applied (EXAM): {}\", result);\n\n        return result;\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\ExamSlotImportService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/ExamSlotImportService.java",
      "filename": "ExamSlotImportService.java",
      "size_bytes": 12237,
      "lines": 277,
      "last_modified": "2025-11-13T23:33:16.469087",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.dto.request.ExamSlotParticipantCsvRow;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.entity.*;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.util.*;\n\n@Service\npublic class ExamSlotImportService {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExamSlotImportService.class);\n    private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n\n    private final CsvParserService csvParserService;\n    private final SlotRepository slotRepository;\n    private final SubjectRepository subjectRepository;\n    private final StudentProfileRepository studentProfileRepository;\n    private final ExamSlotSubjectRepository examSlotSubjectRepository;\n    private final ExamSlotParticipantRepository examSlotParticipantRepository;\n    private final EnrollmentRepository enrollmentRepository;\n\n    public ExamSlotImportService(\n            CsvParserService csvParserService,\n            SlotRepository slotRepository,\n            SubjectRepository subjectRepository,\n            StudentProfileRepository studentProfileRepository,\n            ExamSlotSubjectRepository examSlotSubjectRepository,\n            ExamSlotParticipantRepository examSlotParticipantRepository,\n            EnrollmentRepository enrollmentRepository) {\n        this.csvParserService = csvParserService;\n        this.slotRepository = slotRepository;\n        this.subjectRepository = subjectRepository;\n        this.studentProfileRepository = studentProfileRepository;\n        this.examSlotSubjectRepository = examSlotSubjectRepository;\n        this.examSlotParticipantRepository = examSlotParticipantRepository;\n        this.enrollmentRepository = enrollmentRepository;\n    }\n\n    /**\n     * Import exam slot participants from CSV file with partial success pattern.\n     * Supports AddOnly and AddAndUpdate modes.\n     * CSV format: semester_code,start_time,room_name,subject_code,roll_number\n     *\n     * @param file CSV file\n     * @param modeStr Import mode (\"AddOnly\" or \"AddAndUpdate\")\n     * @return ImportResultDTO with success/failure counts and error details\n     */\n    public ImportResultDTO importParticipantsFromCsv(MultipartFile file, String modeStr) {\n        logger.info(\"Starting exam slot participant CSV import with mode: {}\", modeStr);\n\n        // Parse mode\n        ImportMode mode;\n        try {\n            mode = ImportMode.fromString(modeStr);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), ErrorCode.INVALID_IMPORT_MODE);\n        }\n\n        // Parse CSV\n        List<ExamSlotParticipantCsvRow> rows;\n        try {\n            rows = csvParserService.parseExamSlotParticipantCsv(file);\n        } catch (IOException e) {\n            throw new BadRequestException(\"Failed to process CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        logger.info(\"Parsed {} rows from CSV\", rows.size());\n\n        // Deduplicate within file by business key\n        Map<String, ExamSlotParticipantCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (ExamSlotParticipantCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getUniqueKey(), row);\n        }\n\n        logger.info(\"After deduplication: {} unique participants\", uniqueRows.size());\n\n        // Process rows with partial success\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (ExamSlotParticipantCsvRow row : uniqueRows.values()) {\n            try {\n                processOneExamSlotParticipantRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                logger.warn(\"Failed to process row {}: {}\", row.getRowNumber(), e.getMessage());\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()\n                ));\n            }\n        }\n\n        logger.info(\"Exam slot participant import completed: {} successful, {} failed\", successCount, errors.size());\n\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Process a single exam slot participant row in a separate transaction.\n     * This ensures one row's failure doesn't affect others (partial success).\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneExamSlotParticipantRow(ExamSlotParticipantCsvRow row, ImportMode mode) {\n        // Validate row\n        if (!row.isValid()) {\n            throw new BadRequestException(\"Invalid row data\", ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Parse start time\n        LocalDateTime startTime;\n        try {\n            startTime = LocalDateTime.parse(row.getStartTime(), DATE_TIME_FORMATTER);\n        } catch (DateTimeParseException e) {\n            throw new BadRequestException(\n                    \"Invalid date format for start_time: \" + row.getStartTime() + \". Expected format: yyyy-MM-ddTHH:mm:ss\",\n                    ErrorCode.INVALID_DATE_FORMAT\n            );\n        }\n\n        // Find slot by natural keys\n        Slot slot = slotRepository.findBySemesterCodeAndStartTimeAndRoomName(\n                row.getSemesterCode(), startTime, row.getRoomName());\n\n        if (slot == null) {\n            throw new ResourceNotFoundException(\n                    \"Exam slot not found for semester \" + row.getSemesterCode() +\n                            \", start time \" + row.getStartTime() + \", room \" + row.getRoomName(),\n                    ErrorCode.SLOT_NOT_FOUND\n            );\n        }\n\n        // Validate slot is FINAL_EXAM with no class\n        if (slot.getSlotCategory() != SlotCategory.FINAL_EXAM || slot.getAcademicClass() != null) {\n            throw new BadRequestException(\n                    \"Slot must be FINAL_EXAM type with no class assigned (independent exam slot)\",\n                    ErrorCode.INVALID_SLOT_TYPE\n            );\n        }\n\n        // Check if slot is active\n        if (!slot.getActive()) {\n            throw new BadRequestException(\n                    \"Cannot add participant to inactive exam slot\",\n                    ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED\n            );\n        }\n\n        // Find subject by code\n        Subject subject = subjectRepository.findByCode(row.getSubjectCode());\n        if (subject == null) {\n            throw new ResourceNotFoundException(\n                    \"Subject not found with code: \" + row.getSubjectCode(),\n                    ErrorCode.SUBJECT_NOT_FOUND\n            );\n        }\n\n        // Check if subject is assigned to this slot (active)\n        Optional<ExamSlotSubject> examSlotSubjectOpt = examSlotSubjectRepository\n                .findBySlotIdAndSubjectIdAndIsActiveTrue(slot.getId(), subject.getId().intValue());\n\n        if (!examSlotSubjectOpt.isPresent()) {\n            throw new BadRequestException(\n                    \"Subject \" + row.getSubjectCode() + \" is not assigned to this exam slot. Please assign the subject first.\",\n                    ErrorCode.SUBJECT_NOT_ASSIGNED_TO_SLOT\n            );\n        }\n\n        ExamSlotSubject examSlotSubject = examSlotSubjectOpt.get();\n\n        // Find student by roll number (eager fetch user to avoid lazy loading issue)\n        StudentProfile student = studentProfileRepository.findByRollNumberWithUserAndMajor(row.getRollNumber());\n        if (student == null) {\n            throw new ResourceNotFoundException(\n                    \"Student not found with roll number: \" + row.getRollNumber(),\n                    ErrorCode.STUDENT_NOT_FOUND\n            );\n        }\n\n        // Check if student is active\n        if (!student.getUser().getActive()) {\n            throw new BadRequestException(\n                    \"Cannot add inactive student: \" + row.getRollNumber(),\n                    ErrorCode.INACTIVE_STUDENT_NOT_ALLOWED\n            );\n        }\n\n        // Check if student is enrolled in this subject during the semester\n        boolean isEnrolledInSubject = enrollmentRepository.existsByStudentAndSubjectAndSemesterAndEnrolled(\n                student.getUserId(), subject.getId().intValue(), slot.getSemester().getId(), true);\n\n        if (!isEnrolledInSubject) {\n            throw new BadRequestException(\n                    \"Student \" + row.getRollNumber() + \" is not enrolled in subject \" + row.getSubjectCode() +\n                            \" during semester \" + row.getSemesterCode(),\n                    ErrorCode.STUDENT_NOT_ENROLLED_IN_SUBJECT\n            );\n        }\n\n        // Check for existing participant\n        Optional<ExamSlotParticipant> existingOpt = examSlotParticipantRepository\n                .findByExamSlotSubjectIdAndStudentUserId(examSlotSubject.getId(), student.getUserId());\n\n        if (existingOpt.isPresent()) {\n            ExamSlotParticipant existing = existingOpt.get();\n\n            if (existing.getIsEnrolled()) {\n                // Already enrolled\n                if (mode == ImportMode.ADD_ONLY) {\n                    throw new ResourceExistsException(\n                            \"Student \" + row.getRollNumber() + \" is already enrolled in exam for subject \" + row.getSubjectCode(),\n                            ErrorCode.ALREADY_ENROLLED\n                    );\n                }\n                // ADD_AND_UPDATE mode: Skip (no change needed)\n                return;\n            } else {\n                // Withdrawn, handle re-enrollment\n                if (mode == ImportMode.ADD_ONLY) {\n                    throw new ResourceExistsException(\n                            \"Student \" + row.getRollNumber() + \" was previously enrolled (withdrawn)\",\n                            ErrorCode.ALREADY_EXISTS\n                    );\n                }\n                // ADD_AND_UPDATE mode: Re-enroll\n                existing.setIsEnrolled(true);\n                examSlotParticipantRepository.save(existing);\n            }\n        } else {\n            // Create new participant\n            ExamSlotParticipant newParticipant = new ExamSlotParticipant();\n            newParticipant.setExamSlotSubject(examSlotSubject);\n            newParticipant.setStudentUser(student.getUser());\n            newParticipant.setIsEnrolled(true);\n\n            examSlotParticipantRepository.save(newParticipant);\n        }\n    }\n\n    /**\n     * Extract error code from exception.\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\ExamSlotService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/ExamSlotService.java",
      "filename": "ExamSlotService.java",
      "size_bytes": 25480,
      "lines": 514,
      "last_modified": "2025-11-23T11:50:03.391660",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.enums.AttendanceMethod;\nimport com.fuacs.backend.constant.enums.AttendanceStatus;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.dto.mapper.SlotMapper;\nimport com.fuacs.backend.dto.request.ExamSlotParticipantCreateRequest;\nimport com.fuacs.backend.dto.request.ExamSlotParticipantSearchRequest;\nimport com.fuacs.backend.dto.request.ExamSlotParticipantUpdateRequest;\nimport com.fuacs.backend.dto.request.ExamSlotSubjectAssignRequest;\nimport com.fuacs.backend.dto.request.PagedRequest;\nimport com.fuacs.backend.dto.response.ExamSlotParticipantDTO;\nimport com.fuacs.backend.dto.response.ExamSlotParticipantsAllResponse;\nimport com.fuacs.backend.dto.response.ExamSlotParticipantsResponse;\nimport com.fuacs.backend.dto.response.ExamSlotSubjectsResponse;\nimport com.fuacs.backend.dto.response.SlotDTO;\nimport com.fuacs.backend.dto.response.SubjectDTO;\nimport com.fuacs.backend.entity.ExamAttendance;\nimport com.fuacs.backend.entity.ExamSlotParticipant;\nimport com.fuacs.backend.entity.ExamSlotSubject;\nimport com.fuacs.backend.entity.Slot;\nimport com.fuacs.backend.entity.Subject;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.EnrollmentRepository;\nimport com.fuacs.backend.repository.ExamAttendanceRepository;\nimport com.fuacs.backend.repository.ExamSlotParticipantRepository;\nimport com.fuacs.backend.repository.ExamSlotSubjectRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport com.fuacs.backend.repository.SubjectRepository;\nimport com.fuacs.backend.repository.UserRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.util.List;\n\n@Service\npublic class ExamSlotService {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExamSlotService.class);\n\n    private final ExamSlotSubjectRepository examSlotSubjectRepository;\n    private final ExamSlotParticipantRepository examSlotParticipantRepository;\n    private final SlotRepository slotRepository;\n    private final SubjectRepository subjectRepository;\n    private final UserRepository userRepository;\n    private final EnrollmentRepository enrollmentRepository;\n    private final ExamAttendanceRepository examAttendanceRepository;\n    private final SlotMapper slotMapper;\n\n    public ExamSlotService(ExamSlotSubjectRepository examSlotSubjectRepository,\n                           ExamSlotParticipantRepository examSlotParticipantRepository,\n                           SlotRepository slotRepository,\n                           SubjectRepository subjectRepository,\n                           UserRepository userRepository,\n                           EnrollmentRepository enrollmentRepository,\n                           ExamAttendanceRepository examAttendanceRepository,\n                           SlotMapper slotMapper) {\n        this.examSlotSubjectRepository = examSlotSubjectRepository;\n        this.examSlotParticipantRepository = examSlotParticipantRepository;\n        this.slotRepository = slotRepository;\n        this.subjectRepository = subjectRepository;\n        this.userRepository = userRepository;\n        this.enrollmentRepository = enrollmentRepository;\n        this.examAttendanceRepository = examAttendanceRepository;\n        this.slotMapper = slotMapper;\n    }\n\n    @Transactional\n    public ExamSlotSubjectsResponse assignSubjectsToSlot(Integer slotId, ExamSlotSubjectAssignRequest request) {\n        // Validate slot exists and is FINAL_EXAM with classId=NULL\n        Slot slot = slotRepository.findById(slotId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam slot not found: \" + slotId,\n                        ErrorCode.SLOT_NOT_FOUND));\n\n        if (slot.getSlotCategory() != SlotCategory.FINAL_EXAM || slot.getAcademicClass() != null) {\n            throw new BadRequestException(\"Slot must be FINAL_EXAM type with no class assigned\",\n                    ErrorCode.INVALID_SLOT_TYPE);\n        }\n\n        if (!slot.getActive()) {\n            throw new BadRequestException(\"Cannot assign subjects to inactive exam slot\",\n                    ErrorCode.INACTIVE_SLOT_NOT_ALLOWED);\n        }\n\n        // Validate all subjects exist and are active\n        List<Integer> subjectIds = request.getSubjectIds();\n        int assignedCount = 0;\n\n        for (Integer subjectId : subjectIds) {\n            Subject subject = subjectRepository.findById(subjectId.shortValue())\n                    .orElseThrow(() -> new ResourceNotFoundException(\"Subject not found: \" + subjectId,\n                            ErrorCode.SUBJECT_NOT_FOUND));\n\n            if (!subject.getActive()) {\n                throw new BadRequestException(\"Cannot assign inactive subject: \" + subjectId,\n                        ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n            }\n\n            // Check for duplicate assignment (only check active assignments)\n            if (examSlotSubjectRepository.existsBySlotIdAndSubjectIdAndIsActiveTrue(slotId, subjectId)) {\n                throw new BadRequestException(\"Cannot assign duplicate subjects to the same slot\",\n                        ErrorCode.DUPLICATE_SUBJECTS_NOT_ALLOWED);\n            }\n\n            // Create ExamSlotSubject entry\n            ExamSlotSubject examSlotSubject = new ExamSlotSubject();\n            examSlotSubject.setSlot(slot);\n            examSlotSubject.setSubject(subject);\n            examSlotSubjectRepository.save(examSlotSubject);\n            assignedCount++;\n        }\n\n        // Get all subjects currently assigned to the slot\n        List<SubjectDTO> allSubjects = examSlotSubjectRepository.findSubjectsBySlotId(slotId);\n\n        return new ExamSlotSubjectsResponse(slotId, allSubjects, assignedCount, allSubjects.size());\n    }\n\n    @Transactional(readOnly = true)\n    public ExamSlotSubjectsResponse getSubjectsBySlotId(Integer slotId) {\n        // Validate slot exists\n        Slot slot = slotRepository.findById(slotId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam slot not found: \" + slotId,\n                        ErrorCode.SLOT_NOT_FOUND));\n\n        List<SubjectDTO> subjects = examSlotSubjectRepository.findSubjectsBySlotId(slotId);\n\n        return new ExamSlotSubjectsResponse(slotId, subjects, 0, subjects.size());\n    }\n\n    @Transactional\n    public ExamSlotParticipantDTO addParticipant(Integer slotId, ExamSlotParticipantCreateRequest request) {\n        // Validate slot exists and is FINAL_EXAM\n        Slot slot = slotRepository.findById(slotId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam slot not found: \" + slotId,\n                        ErrorCode.SLOT_NOT_FOUND));\n\n        if (slot.getSlotCategory() != SlotCategory.FINAL_EXAM || slot.getAcademicClass() != null) {\n            throw new BadRequestException(\"Slot must be FINAL_EXAM type with no class assigned\",\n                    ErrorCode.INVALID_SLOT_TYPE);\n        }\n\n        if (!slot.getActive()) {\n            throw new BadRequestException(\"Cannot add student to inactive exam slot\",\n                    ErrorCode.INACTIVE_SLOT_NOT_ALLOWED);\n        }\n\n        // Check if slot has already started (time-based validation)\n        LocalDateTime now = LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        if (!now.isBefore(slot.getStartTime())) {\n            throw new OperationNotAllowedException(\n                    \"Cannot add participant after exam slot has started (start time: \" + slot.getStartTime() + \")\",\n                    ErrorCode.SLOT_ALREADY_STARTED);\n        }\n\n        // Validate student exists, is active, and has STUDENT role\n        User student = userRepository.findById(request.getStudentUserId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"User not found: \" + request.getStudentUserId(),\n                        ErrorCode.USER_NOT_FOUND));\n\n        if (!student.getActive()) {\n            throw new BadRequestException(\"Cannot add inactive student to exam slot\",\n                    ErrorCode.INACTIVE_STUDENT_NOT_ALLOWED);\n        }\n\n        // Check if student has STUDENT role\n        boolean hasStudentRole = student.getRoles().stream()\n                .anyMatch(role -> \"STUDENT\".equals(role.getName()));\n        if (!hasStudentRole) {\n            throw new BadRequestException(\"User must have STUDENT role to participate in exam\",\n                    ErrorCode.INVALID_USER_ROLE);\n        }\n\n        // Validate subject is assigned to slot\n        ExamSlotSubject examSlotSubject = examSlotSubjectRepository\n                .findBySlotIdAndSubjectId(slotId, request.getSubjectId())\n                .orElseThrow(() -> new BadRequestException(\n                        \"Subject \" + request.getSubjectId() + \" is not assigned to this exam slot\",\n                        ErrorCode.SUBJECT_NOT_ASSIGNED_TO_SLOT));\n\n        // Validate student is enrolled in the subject during the semester\n        Short semesterId = slot.getSemester() != null ? slot.getSemester().getId() : null;\n        if (semesterId != null) {\n            boolean isEnrolled = enrollmentRepository\n                    .existsByStudentAndSubjectAndSemesterAndEnrolled(\n                            request.getStudentUserId(), request.getSubjectId(), semesterId, true);\n\n            if (!isEnrolled) {\n                Subject subject = examSlotSubject.getSubject();\n                String semesterName = slot.getSemester().getName();\n                throw new BadRequestException(\n                        \"Student is not enrolled in subject \" + subject.getCode() + \" during \" + semesterName\n                                + \" semester\",\n                        ErrorCode.STUDENT_NOT_ENROLLED_IN_SUBJECT);\n            }\n        }\n\n        // NEW VALIDATION: Check if student already enrolled in this slot (any subject)\n        boolean alreadyInSlot = examSlotParticipantRepository\n                .existsByExamSlotSubject_Slot_IdAndStudentUserIdAndIsEnrolled(slotId, request.getStudentUserId(), true);\n\n        if (alreadyInSlot) {\n            throw new ResourceExistsException(\n                    \"Student is already enrolled in this exam slot for another subject. \" +\n                    \"A student can only participate in one subject per exam slot.\",\n                    ErrorCode.STUDENT_ALREADY_IN_SLOT);\n        }\n\n        // Check if participant already exists\n        ExamSlotParticipant existing = examSlotParticipantRepository\n                .findByExamSlotSubjectIdAndStudentUserId(examSlotSubject.getId(), request.getStudentUserId())\n                .orElse(null);\n\n        if (existing != null) {\n            if (existing.getIsEnrolled()) {\n                throw new ResourceExistsException(\n                        \"Student is already enrolled in this subject for this exam slot\",\n                        ErrorCode.ALREADY_ENROLLED);\n            } else {\n                // Re-enrollment case\n                existing.setIsEnrolled(true);\n                ExamSlotParticipant updated = examSlotParticipantRepository.save(existing);\n\n                // Auto-create ExamAttendance record for re-enrolled participant\n                ensureExamAttendanceExists(slot, student);\n\n                return examSlotParticipantRepository.findByIdWithDetails(updated.getId());\n            }\n        }\n\n        // Create new participant\n        ExamSlotParticipant participant = new ExamSlotParticipant();\n        participant.setExamSlotSubject(examSlotSubject);\n        participant.setStudentUser(student);\n        participant.setIsEnrolled(true);\n        ExamSlotParticipant saved = examSlotParticipantRepository.save(participant);\n\n        // Auto-create ExamAttendance record for this participant\n        ensureExamAttendanceExists(slot, student);\n\n        return examSlotParticipantRepository.findByIdWithDetails(saved.getId());\n    }\n\n    @Transactional(readOnly = true)\n    public ExamSlotParticipantsResponse getParticipants(Integer slotId, ExamSlotParticipantSearchRequest request) {\n        // Validate slot exists\n        Slot slot = slotRepository.findById(slotId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam slot not found: \" + slotId,\n                        ErrorCode.SLOT_NOT_FOUND));\n\n        // Validate subject is assigned to slot\n        ExamSlotSubject examSlotSubject = examSlotSubjectRepository\n                .findBySlotIdAndSubjectId(slotId, request.getSubjectId())\n                .orElseThrow(() -> new BadRequestException(\n                        \"Subject \" + request.getSubjectId() + \" is not assigned to this exam slot\",\n                        ErrorCode.SUBJECT_NOT_ASSIGNED_TO_SLOT));\n\n        // Get participants with filtering and pagination\n        List<ExamSlotParticipantDTO> participants = examSlotParticipantRepository.search(slotId, request);\n        Long totalItems = examSlotParticipantRepository.count(slotId, request);\n\n        // Calculate enrolled and withdrawn counts\n        Integer totalEnrolled = examSlotParticipantRepository\n                .countByExamSlotSubject_Slot_IdAndExamSlotSubject_Subject_IdAndIsEnrolled(slotId,\n                        request.getSubjectId(), true)\n                .intValue();\n        Integer totalWithdrawn = examSlotParticipantRepository\n                .countByExamSlotSubject_Slot_IdAndExamSlotSubject_Subject_IdAndIsEnrolled(slotId,\n                        request.getSubjectId(), false)\n                .intValue();\n\n        // Map slot and subject\n        SlotDTO slotDTO = slotMapper.toDTO(slot);\n        SubjectDTO subjectDTO = new SubjectDTO();\n        Subject subject = examSlotSubject.getSubject();\n        subjectDTO.setId(subject.getId());\n        subjectDTO.setName(subject.getName());\n        subjectDTO.setCode(subject.getCode());\n\n        return new ExamSlotParticipantsResponse(request, slotDTO, subjectDTO, participants, totalItems, totalEnrolled,\n                totalWithdrawn);\n    }\n\n    /**\n     * Get ALL participants across all subjects for an exam slot\n     * @param slotId Exam slot ID\n     * @param request Paged request with optional filters (no subjectId)\n     * @return Response with all participants (each participant has subject info)\n     */\n    @Transactional(readOnly = true)\n    public ExamSlotParticipantsAllResponse getAllParticipants(Integer slotId, PagedRequest request) {\n        logger.info(\"Getting ALL participants for exam slot {}\", slotId);\n\n        // Validate slot exists\n        Slot slot = slotRepository.findById(slotId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam slot not found: \" + slotId,\n                        ErrorCode.SLOT_NOT_FOUND));\n\n        // Get ALL participants (no subject filter)\n        List<ExamSlotParticipantDTO> participants = examSlotParticipantRepository.searchAllBySlotId(slotId, request);\n        Long totalItems = examSlotParticipantRepository.countAllBySlotId(slotId, request);\n\n        // Calculate stats (ALL subjects combined)\n        Integer totalEnrolled = examSlotParticipantRepository\n                .countByExamSlotSubject_Slot_IdAndIsEnrolled(slotId, true).intValue();\n        Integer totalWithdrawn = examSlotParticipantRepository\n                .countByExamSlotSubject_Slot_IdAndIsEnrolled(slotId, false).intValue();\n\n        // Map slot DTO\n        SlotDTO slotDTO = slotMapper.toDTO(slot);\n\n        return new ExamSlotParticipantsAllResponse(request, slotDTO, participants,\n                                                    totalItems, totalEnrolled, totalWithdrawn);\n    }\n\n    /**\n     * Remove a participant from exam slot (hard delete)\n     * Also deletes related ExamAttendance record\n     * @param slotId Exam slot ID\n     * @param participantId Participant ID to remove\n     */\n    @Transactional\n    public void removeParticipant(Integer slotId, Long participantId) {\n        logger.info(\"Removing participant {} from exam slot {}\", participantId, slotId);\n\n        // Validate slot exists\n        Slot slot = slotRepository.findById(slotId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam slot not found: \" + slotId,\n                        ErrorCode.SLOT_NOT_FOUND));\n\n        // Check if slot has already started (time-based validation)\n        LocalDateTime now = LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        if (!now.isBefore(slot.getStartTime())) {\n            throw new OperationNotAllowedException(\n                    \"Cannot remove participant after exam slot has started (start time: \" + slot.getStartTime() + \")\",\n                    ErrorCode.SLOT_ALREADY_STARTED);\n        }\n\n        // Find participant\n        ExamSlotParticipant participant = examSlotParticipantRepository.findById(participantId)\n                .orElseThrow(() -> new ResourceNotFoundException(\n                        \"Exam slot participant not found: \" + participantId,\n                        ErrorCode.EXAM_SLOT_PARTICIPANT_NOT_FOUND));\n\n        // Validate participant belongs to this slot\n        if (!participant.getExamSlotSubject().getSlot().getId().equals(slotId)) {\n            throw new BadRequestException(\n                    \"Participant does not belong to this slot\",\n                    ErrorCode.EXAM_SLOT_PARTICIPANT_NOT_FOUND);\n        }\n\n        // Delete related ExamAttendance first (if exists)\n        Integer studentUserId = participant.getStudentUser().getId();\n        ExamAttendance attendance = examAttendanceRepository.findBySlotIdAndStudentUserId(slotId, studentUserId);\n        if (attendance != null) {\n            logger.info(\"Deleting ExamAttendance record for student {} in slot {}\", studentUserId, slotId);\n            examAttendanceRepository.delete(attendance);\n        }\n\n        // Hard delete participant\n        examSlotParticipantRepository.delete(participant);\n        logger.info(\"Successfully removed participant {} from exam slot {}\", participantId, slotId);\n    }\n\n    @Transactional(readOnly = true)\n    public ExamSlotParticipantDTO getParticipantById(Integer slotId, Long participantId) {\n        // Validate slot exists\n        slotRepository.findById(slotId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam slot not found: \" + slotId,\n                        ErrorCode.SLOT_NOT_FOUND));\n\n        // Get participant with full details\n        ExamSlotParticipantDTO participant = examSlotParticipantRepository.findByIdWithDetails(participantId);\n        if (participant == null) {\n            throw new ResourceNotFoundException(\n                    \"Exam slot participant not found: \" + participantId,\n                    ErrorCode.EXAM_SLOT_PARTICIPANT_NOT_FOUND);\n        }\n\n        // Validate participant belongs to the slot\n        if (!participant.getSlotId().equals(slotId)) {\n            throw new BadRequestException(\n                    \"Participant \" + participantId + \" does not belong to slot \" + slotId,\n                    ErrorCode.EXAM_SLOT_PARTICIPANT_NOT_FOUND);\n        }\n\n        return participant;\n    }\n\n    @Transactional\n    public ExamSlotParticipantDTO updateParticipant(Integer slotId, Long participantId,\n                                                    ExamSlotParticipantUpdateRequest request) {\n        // Validate slot exists\n        slotRepository.findById(slotId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam slot not found: \" + slotId,\n                        ErrorCode.SLOT_NOT_FOUND));\n\n        // Find participant\n        ExamSlotParticipant participant = examSlotParticipantRepository.findById(participantId)\n                .orElseThrow(() -> new ResourceNotFoundException(\n                        \"Exam slot participant not found: \" + participantId,\n                        ErrorCode.EXAM_SLOT_PARTICIPANT_NOT_FOUND));\n\n        // Validate participant belongs to slot\n        if (!participant.getExamSlotSubject().getSlot().getId().equals(slotId)) {\n            throw new BadRequestException(\n                    \"Participant \" + participantId + \" does not belong to slot \" + slotId,\n                    ErrorCode.EXAM_SLOT_PARTICIPANT_NOT_FOUND);\n        }\n\n        // Update isEnrolled\n        participant.setIsEnrolled(request.getIsEnrolled());\n        ExamSlotParticipant updated = examSlotParticipantRepository.save(participant);\n\n        return examSlotParticipantRepository.findByIdWithDetails(updated.getId());\n    }\n\n    /**\n     * Soft delete a subject from exam slot\n     * Prevents data loss by marking subject as inactive instead of deleting\n     *\n     * @param slotId        The exam slot ID\n     * @param subjectId     The subject ID to remove\n     * @param currentUserId The user performing the action (for audit trail)\n     * @throws ResourceNotFoundException if slot or subject assignment not found\n     * @throws BadRequestException       if slot is not FINAL_EXAM or subject has active participants\n     */\n    @Transactional\n    public void removeSubjectFromSlot(Integer slotId, Integer subjectId, Integer currentUserId) {\n        // Validate slot exists and is FINAL_EXAM type\n        Slot slot = slotRepository.findById(slotId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Exam slot not found: \" + slotId,\n                        ErrorCode.SLOT_NOT_FOUND));\n\n        if (slot.getSlotCategory() != SlotCategory.FINAL_EXAM) {\n            throw new BadRequestException(\n                    \"Can only remove subjects from FINAL_EXAM slots\",\n                    ErrorCode.INVALID_SLOT_CATEGORY);\n        }\n\n        // Find active exam slot subject\n        ExamSlotSubject examSlotSubject = examSlotSubjectRepository\n                .findBySlotIdAndSubjectIdAndIsActiveTrue(slotId, subjectId)\n                .orElseThrow(() -> new ResourceNotFoundException(\n                        \"Subject \" + subjectId + \" is not assigned to slot \" + slotId,\n                        ErrorCode.EXAM_SLOT_SUBJECT_NOT_FOUND));\n\n        // Check for active participants - prevent removal if students are enrolled\n        if (examSlotSubjectRepository.hasActiveParticipants(examSlotSubject.getId())) {\n            Long participantCount = examSlotSubjectRepository.countActiveParticipants(examSlotSubject.getId());\n            throw new BadRequestException(\n                    String.format(\"Cannot remove subject. %d student(s) are enrolled. \" +\n                            \"Please remove or withdraw participants first.\", participantCount),\n                    ErrorCode.EXAM_SLOT_SUBJECT_HAS_PARTICIPANTS);\n        }\n\n        // Get current user for audit\n        User currentUser = userRepository.findById(currentUserId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"User not found: \" + currentUserId,\n                        ErrorCode.USER_NOT_FOUND));\n\n        // Perform soft delete\n        examSlotSubject.setIsActive(false);\n        examSlotSubject.setDeactivatedAt(java.time.Instant.now());\n        examSlotSubject.setDeactivatedByUser(currentUser);\n        examSlotSubjectRepository.save(examSlotSubject);\n    }\n\n    /**\n     * Auto-create ExamAttendance record for a student in a slot if not exists.\n     * This is called when adding a new ExamSlotParticipant to ensure attendance\n     * records are available immediately (no lazy creation needed).\n     *\n     * @param slot The exam slot\n     * @param student The student user\n     */\n    private void ensureExamAttendanceExists(Slot slot, User student) {\n        try {\n            // Check if attendance record already exists\n            ExamAttendance existing = examAttendanceRepository.findBySlotIdAndStudentUserId(\n                    slot.getId(), student.getId());\n\n            if (existing == null) {\n                // Create new attendance record with default status\n                ExamAttendance attendance = new ExamAttendance();\n                attendance.setSlot(slot);\n                attendance.setStudent(student);\n                attendance.setStatus(AttendanceStatus.NOT_YET);\n                attendance.setMethod(AttendanceMethod.MANUAL);\n                attendance.setRecordedAt(Instant.now());\n\n                examAttendanceRepository.save(attendance);\n\n                logger.info(\"Auto-created ExamAttendance for student {} in slot {}\",\n                        student.getId(), slot.getId());\n            }\n        } catch (DataIntegrityViolationException e) {\n            // Concurrent request created the same record - safe to ignore\n        } catch (Exception ignored) {\n        }\n    }\n\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\ExcelService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/ExcelService.java",
      "filename": "ExcelService.java",
      "size_bytes": 8337,
      "lines": 188,
      "last_modified": "2025-10-29T20:56:54.620679",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.dto.response.ErrorDetail;\nimport com.fuacs.backend.dto.response.ImportStudentProfileDTO;\nimport com.fuacs.backend.entity.Major;\nimport com.fuacs.backend.entity.Role;\nimport com.fuacs.backend.entity.StudentProfile;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.repository.MajorRepository;\nimport com.fuacs.backend.repository.RoleRepository;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport com.fuacs.backend.repository.UserRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport org.apache.commons.validator.routines.EmailValidator;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.DataFormatter;\nimport org.apache.poi.ss.usermodel.Row;\nimport org.apache.poi.ss.usermodel.Sheet;\nimport org.apache.poi.ss.usermodel.Workbook;\nimport org.apache.poi.ss.usermodel.WorkbookFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.transaction.interceptor.TransactionAspectSupport;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n@Service\npublic class ExcelService {\n    private static final Logger logger = LoggerFactory.getLogger(ExcelService.class);\n    private static final int MAX_ROWS = 100;\n    private static final String DEFAULT_PASSWORD = \"123456\";\n\n    private final UserRepository userRepository;\n    private final StudentProfileRepository studentProfileRepository;\n    private final MajorRepository majorRepository;\n    private final RoleRepository roleRepository;\n    private final PasswordEncoder passwordEncoder;\n    private final DataFormatter dataFormatter = new DataFormatter();\n    private final EmailValidator emailValidator = EmailValidator.getInstance();\n\n    public ExcelService(UserRepository userRepository, StudentProfileRepository studentProfileRepository, MajorRepository majorRepository, RoleRepository roleRepository, PasswordEncoder passwordEncoder) {\n        this.userRepository = userRepository;\n        this.studentProfileRepository = studentProfileRepository;\n        this.majorRepository = majorRepository;\n        this.roleRepository = roleRepository;\n        this.passwordEncoder = passwordEncoder;\n    }\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    @Transactional\n    public ImportStudentProfileDTO importStudents(MultipartFile file) {\n        ImportStudentProfileDTO response = new ImportStudentProfileDTO();\n        List<ErrorDetail> errors = new ArrayList<>();\n        int success = 0, failed = 0;\n\n        try (InputStream inputStream = file.getInputStream();\n             Workbook workbook = WorkbookFactory.create(inputStream)) {\n\n            Sheet sheet = workbook.getSheetAt(0);\n            int totalRows = sheet.getLastRowNum() + 1;\n            if (totalRows <= 1) {\n                response.setMessage(\"Empty file or missing data\");\n                return response;\n            }\n\n            for (int i = 1; i < totalRows; i++) {\n                Row row = sheet.getRow(i);\n                if (row == null) continue;\n                int rowNumber = i + 1;\n\n                try {\n                    // --- Extract and validate fields ---\n                    String rollNumber = getCellValue(row.getCell(0));\n                    String username = getCellValue(row.getCell(1));\n                    String email = getCellValue(row.getCell(2));\n                    String fullName = getCellValue(row.getCell(3));\n                    String majorCode = getCellValue(row.getCell(4));\n\n                    List<String> rowErrors = validateRow(row);\n                    if (!rowErrors.isEmpty()) {\n                        errors.add(new ErrorDetail(rowNumber, String.join(\", \", rowErrors)));\n                        failed++;\n                        continue;\n                    }\n\n                    if (userRepository.existsByUsername(username)) {\n                        errors.add(new ErrorDetail(rowNumber, \"Duplicate username: \" + username));\n                        failed++;\n                        continue;\n                    }\n                    if (studentProfileRepository.existsByRollNumber(rollNumber)) {\n                        errors.add(new ErrorDetail(rowNumber, \"Duplicate rollNumber: \" + rollNumber));\n                        failed++;\n                        continue;\n                    }\n\n                    Major major = majorRepository.findByCode(majorCode);\n                    if (major == null) {\n                        errors.add(new ErrorDetail(rowNumber, \"Major not found: \" + majorCode));\n                        failed++;\n                        continue;\n                    }\n\n                    if (!emailValidator.isValid(email)) {\n                        errors.add(new ErrorDetail(rowNumber, \"Invalid email: \" + email));\n                        failed++;\n                        continue;\n                    }\n\n                    // --- Create and persist User ---\n                    User user = new User();\n                    user.setUsername(username);\n                    user.setEmail(email);\n                    user.setFullName(fullName);\n                    user.setPasswordHash(passwordEncoder.encode(\"123456\"));\n\n                    Set<Role> roles = new HashSet<>();\n                    roleRepository.findByName(com.fuacs.backend.constant.enums.Role.STUDENT.toString()).ifPresent(roles::add);\n                    user.setRoles(roles);\n\n                    // save user\n                    entityManager.persist(user);\n                    entityManager.flush(); // force insert to DB, get id\n\n                    // --- Create and persist StudentProfile ---\n                    StudentProfile profile = new StudentProfile();\n                    profile.setUser(entityManager.merge(user)); // attach managed User\n                    profile.setUserId(user.getId());\n                    profile.setMajor(major);\n                    profile.setRollNumber(rollNumber);\n\n                    entityManager.persist(profile);\n                    entityManager.flush();\n\n                    success++;\n\n                } catch (DataIntegrityViolationException ex) {\n                    errors.add(new ErrorDetail(rowNumber, \"Constraint violation: \" + ex.getMostSpecificCause().getMessage()));\n                    failed++;\n                    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); // rollback this iteration\n                } catch (Exception ex) {\n                    errors.add(new ErrorDetail(rowNumber, \"Unexpected error: \" + ex.getMessage()));\n                    failed++;\n                    // rollback chỉ dòng này, không ảnh hưởng dòng khác\n                    entityManager.clear();\n                }\n            }\n\n            response.setSuccessfulImports(success);\n            response.setFailedImports(failed);\n            response.setErrors(errors);\n            response.setMessage(\"Import completed with partial success.\");\n\n        } catch (Exception e) {\n            response.setMessage(\"Fatal error during import: \" + e.getMessage());\n        }\n\n        return response;\n    }\n\n    private List<String> validateRow(Row row) {\n        List<String> errors = new ArrayList<>();\n        String[] fields = {\"rollNumber\", \"username\", \"email\", \"fullName\", \"majorCode\"};\n        for (int i = 0; i < fields.length; i++) {\n            String value = getCellValue(row.getCell(i));\n            if (value == null || value.trim().isEmpty()) {\n                errors.add(\"Missing \" + fields[i]);\n            }\n        }\n        return errors;\n    }\n\n    private String getCellValue(Cell cell) {\n        return (cell == null) ? null : new DataFormatter().formatCellValue(cell).trim();\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\ExportService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/ExportService.java",
      "filename": "ExportService.java",
      "size_bytes": 29071,
      "lines": 607,
      "last_modified": "2025-11-24T11:30:18.486908",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.enums.AttendanceStatus;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.dto.request.ExportClassesRequest;\nimport com.fuacs.backend.dto.request.ExportSlotsRequest;\nimport com.fuacs.backend.dto.response.StudentAttendanceInfoDTO;\nimport com.fuacs.backend.entity.*;\nimport com.fuacs.backend.repository.*;\nimport org.apache.poi.ss.usermodel.*;\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Instant;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.format.DateTimeFormatter;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\n@Service\npublic class ExportService {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExportService.class);\n    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n    private static final DateTimeFormatter TIME_FORMAT = DateTimeFormatter.ofPattern(\"HH:mm\");\n    private static final DateTimeFormatter DATETIME_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy HH:mm\");\n\n    private final ClassRepository classRepository;\n    private final SlotRepository slotRepository;\n    private final EnrollmentRepository enrollmentRepository;\n    private final AttendanceRecordRepository attendanceRecordRepository;\n    private final ExamSlotParticipantRepository examSlotParticipantRepository;\n\n    public ExportService(ClassRepository classRepository,\n                         SlotRepository slotRepository,\n                         EnrollmentRepository enrollmentRepository,\n                         AttendanceRecordRepository attendanceRecordRepository,\n                         ExamSlotParticipantRepository examSlotParticipantRepository) {\n        this.classRepository = classRepository;\n        this.slotRepository = slotRepository;\n        this.enrollmentRepository = enrollmentRepository;\n        this.attendanceRecordRepository = attendanceRecordRepository;\n        this.examSlotParticipantRepository = examSlotParticipantRepository;\n    }\n\n    // ==================== EXPORT CLASSES ====================\n\n    @Transactional(readOnly = true)\n    public ByteArrayOutputStream exportClassesToExcel(ExportClassesRequest request) {\n        logger.info(\"Exporting classes to Excel - semesterId: {}, exportAll: {}, ids: {}\",\n                request.getSemesterId(), request.getExportAll(), request.getIds());\n\n        List<AcademicClass> classes = getClassesToExport(request);\n        logger.info(\"Found {} classes to export\", classes.size());\n\n        try (Workbook workbook = new XSSFWorkbook();\n             ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n\n            // Create cell styles\n            CellStyle headerStyle = createHeaderStyle(workbook);\n            CellStyle dateStyle = createDateStyle(workbook);\n\n            // Sheet 1: Overview\n            createClassesOverviewSheet(workbook, classes, headerStyle);\n\n            // Sheet 2-N: Each class with attendance matrix\n            int sheetNum = 1;\n            for (AcademicClass cls : classes) {\n                createClassDetailSheet(workbook, cls, sheetNum++, headerStyle, dateStyle);\n            }\n\n            workbook.write(out);\n            return out;\n        } catch (IOException e) {\n            logger.error(\"Failed to generate Excel file\", e);\n            throw new RuntimeException(\"Failed to generate Excel file\", e);\n        }\n    }\n\n    @Transactional(readOnly = true)\n    public ByteArrayOutputStream exportClassesToCsvZip(ExportClassesRequest request) {\n        logger.info(\"Exporting classes to CSV ZIP - semesterId: {}, exportAll: {}\",\n                request.getSemesterId(), request.getExportAll());\n\n        List<AcademicClass> classes = getClassesToExport(request);\n\n        try (ByteArrayOutputStream out = new ByteArrayOutputStream();\n             ZipOutputStream zipOut = new ZipOutputStream(out)) {\n\n            // Overview CSV\n            String overviewCsv = generateClassesOverviewCsv(classes);\n            addToZip(zipOut, \"00_Overview.csv\", overviewCsv);\n\n            // Each class as separate CSV\n            int fileNum = 1;\n            for (AcademicClass cls : classes) {\n                String classCsv = generateClassDetailCsv(cls);\n                String filename = String.format(\"%02d_%s.csv\", fileNum++, sanitizeFilename(cls.getCode()));\n                addToZip(zipOut, filename, classCsv);\n            }\n\n            zipOut.finish();\n            return out;\n        } catch (IOException e) {\n            logger.error(\"Failed to generate CSV ZIP\", e);\n            throw new RuntimeException(\"Failed to generate CSV ZIP\", e);\n        }\n    }\n\n    // ==================== EXPORT EXAM SLOTS ====================\n\n    @Transactional(readOnly = true)\n    public ByteArrayOutputStream exportExamSlotsToExcel(ExportSlotsRequest request) {\n        logger.info(\"Exporting exam slots to Excel - semesterId: {}, exportAll: {}\",\n                request.getSemesterId(), request.getExportAll());\n\n        List<Slot> slots = getExamSlotsToExport(request);\n        logger.info(\"Found {} exam slots to export\", slots.size());\n\n        try (Workbook workbook = new XSSFWorkbook();\n             ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n\n            CellStyle headerStyle = createHeaderStyle(workbook);\n            CellStyle dateStyle = createDateStyle(workbook);\n\n            // Sheet 1: Overview\n            createExamSlotsOverviewSheet(workbook, slots, headerStyle);\n\n            // Sheet 2-N: Each slot with attendance details\n            int sheetNum = 1;\n            for (Slot slot : slots) {\n                createExamSlotDetailSheet(workbook, slot, sheetNum++, headerStyle, dateStyle);\n            }\n\n            workbook.write(out);\n            return out;\n        } catch (IOException e) {\n            logger.error(\"Failed to generate Excel file\", e);\n            throw new RuntimeException(\"Failed to generate Excel file\", e);\n        }\n    }\n\n    @Transactional(readOnly = true)\n    public ByteArrayOutputStream exportExamSlotsToCsvZip(ExportSlotsRequest request) {\n        logger.info(\"Exporting exam slots to CSV ZIP - semesterId: {}, exportAll: {}\",\n                request.getSemesterId(), request.getExportAll());\n\n        List<Slot> slots = getExamSlotsToExport(request);\n\n        try (ByteArrayOutputStream out = new ByteArrayOutputStream();\n             ZipOutputStream zipOut = new ZipOutputStream(out)) {\n\n            // Overview CSV\n            String overviewCsv = generateExamSlotsOverviewCsv(slots);\n            addToZip(zipOut, \"00_Overview.csv\", overviewCsv);\n\n            // Each slot as separate CSV\n            int fileNum = 1;\n            for (Slot slot : slots) {\n                String slotCsv = generateExamSlotDetailCsv(slot);\n                String filename = String.format(\"%02d_Slot_%d.csv\", fileNum++, slot.getId());\n                addToZip(zipOut, filename, slotCsv);\n            }\n\n            zipOut.finish();\n            return out;\n        } catch (IOException e) {\n            logger.error(\"Failed to generate CSV ZIP\", e);\n            throw new RuntimeException(\"Failed to generate CSV ZIP\", e);\n        }\n    }\n\n    // ==================== HELPER METHODS - DATA FETCHING ====================\n\n    private List<AcademicClass> getClassesToExport(ExportClassesRequest request) {\n        if (Boolean.TRUE.equals(request.getExportAll())) {\n            return classRepository.findAll().stream()\n                    .filter(c -> c.getSemester() != null && c.getSemester().getId().equals(request.getSemesterId()))\n                    .sorted(Comparator.comparing(AcademicClass::getCode))\n                    .collect(Collectors.toList());\n        }\n        if (request.getIds() == null || request.getIds().isEmpty()) {\n            return Collections.emptyList();\n        }\n        return classRepository.findAllById(request.getIds()).stream()\n                .sorted(Comparator.comparing(AcademicClass::getCode))\n                .collect(Collectors.toList());\n    }\n\n    private List<Slot> getExamSlotsToExport(ExportSlotsRequest request) {\n        List<Slot> allSlots;\n        if (Boolean.TRUE.equals(request.getExportAll())) {\n            allSlots = slotRepository.findBySemesterId(request.getSemesterId());\n        } else if (request.getIds() != null && !request.getIds().isEmpty()) {\n            allSlots = slotRepository.findAllById(request.getIds());\n        } else {\n            return Collections.emptyList();\n        }\n\n        return allSlots.stream()\n                .filter(s -> s.getSlotCategory() == SlotCategory.FINAL_EXAM)\n                .sorted(Comparator.comparing(Slot::getStartTime))\n                .collect(Collectors.toList());\n    }\n\n    // ==================== HELPER METHODS - EXCEL CREATION ====================\n\n    private CellStyle createHeaderStyle(Workbook workbook) {\n        CellStyle style = workbook.createCellStyle();\n        Font font = workbook.createFont();\n        font.setBold(true);\n        style.setFont(font);\n        style.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());\n        style.setFillPattern(FillPatternType.SOLID_FOREGROUND);\n        style.setBorderBottom(BorderStyle.THIN);\n        style.setBorderTop(BorderStyle.THIN);\n        style.setBorderRight(BorderStyle.THIN);\n        style.setBorderLeft(BorderStyle.THIN);\n        return style;\n    }\n\n    private CellStyle createDateStyle(Workbook workbook) {\n        CellStyle style = workbook.createCellStyle();\n        CreationHelper createHelper = workbook.getCreationHelper();\n        style.setDataFormat(createHelper.createDataFormat().getFormat(\"dd/mm/yyyy hh:mm\"));\n        return style;\n    }\n\n    private void createClassesOverviewSheet(Workbook workbook, List<AcademicClass> classes, CellStyle headerStyle) {\n        Sheet sheet = workbook.createSheet(\"Overview\");\n        int rowNum = 0;\n\n        // Title\n        Row titleRow = sheet.createRow(rowNum++);\n        titleRow.createCell(0).setCellValue(\"CLASS EXPORT REPORT\");\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Export Date: \" + LocalDateTime.now().format(DATETIME_FORMAT));\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Total Classes: \" + classes.size());\n        rowNum++; // Empty row\n\n        // Header\n        Row headerRow = sheet.createRow(rowNum++);\n        String[] headers = {\"No.\", \"Class Code\", \"Subject\", \"Subject Code\", \"Semester\", \"Total Students\", \"Total Slots\"};\n        for (int i = 0; i < headers.length; i++) {\n            Cell cell = headerRow.createCell(i);\n            cell.setCellValue(headers[i]);\n            cell.setCellStyle(headerStyle);\n        }\n\n        // Data rows\n        int no = 1;\n        for (AcademicClass cls : classes) {\n            Row row = sheet.createRow(rowNum++);\n            row.createCell(0).setCellValue(no++);\n            row.createCell(1).setCellValue(cls.getCode());\n            row.createCell(2).setCellValue(cls.getSubject() != null ? cls.getSubject().getName() : \"N/A\");\n            row.createCell(3).setCellValue(cls.getSubject() != null ? cls.getSubject().getCode() : \"N/A\");\n            row.createCell(4).setCellValue(cls.getSemester() != null ? cls.getSemester().getCode() : \"N/A\");\n\n            List<Enrollment> enrollments = enrollmentRepository.findAllByAcademicClassId(cls.getId());\n            List<Slot> slots = slotRepository.findByClassId(cls.getId());\n\n            row.createCell(5).setCellValue(enrollments.size());\n            row.createCell(6).setCellValue(slots.size());\n        }\n\n        // Auto-size columns\n        for (int i = 0; i < headers.length; i++) {\n            sheet.autoSizeColumn(i);\n        }\n    }\n\n    private void createClassDetailSheet(Workbook workbook, AcademicClass cls, int sheetNum,\n                                        CellStyle headerStyle, CellStyle dateStyle) {\n        String sheetName = String.format(\"%02d_%s\", sheetNum, truncateSheetName(cls.getCode()));\n        Sheet sheet = workbook.createSheet(sheetName);\n        int rowNum = 0;\n\n        // Class info\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"CLASS: \" + cls.getCode());\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Subject: \" +\n                (cls.getSubject() != null ? cls.getSubject().getName() + \" (\" + cls.getSubject().getCode() + \")\" : \"N/A\"));\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Semester: \" +\n                (cls.getSemester() != null ? cls.getSemester().getCode() : \"N/A\"));\n        rowNum++; // Empty row\n\n        // Get slots and students\n        List<Slot> slots = slotRepository.findByClassId(cls.getId()).stream()\n                .filter(s -> s.getSlotCategory() != SlotCategory.FINAL_EXAM)\n                .sorted(Comparator.comparing(Slot::getStartTime))\n                .collect(Collectors.toList());\n        List<Enrollment> enrollments = enrollmentRepository.findAllByAcademicClassId(cls.getId());\n\n        // Attendance Matrix Header\n        Row headerRow = sheet.createRow(rowNum++);\n        int col = 0;\n        Cell noCell = headerRow.createCell(col++);\n        noCell.setCellValue(\"No.\");\n        noCell.setCellStyle(headerStyle);\n\n        Cell rollCell = headerRow.createCell(col++);\n        rollCell.setCellValue(\"Roll Number\");\n        rollCell.setCellStyle(headerStyle);\n\n        Cell nameCell = headerRow.createCell(col++);\n        nameCell.setCellValue(\"Full Name\");\n        nameCell.setCellStyle(headerStyle);\n\n        // Slot columns\n        Map<Integer, Integer> slotColumnMap = new HashMap<>();\n        for (Slot slot : slots) {\n            Cell slotCell = headerRow.createCell(col);\n            slotCell.setCellValue(slot.getStartTime().format(DATE_FORMAT) + \"\\n\" + slot.getStartTime().format(TIME_FORMAT));\n            slotCell.setCellStyle(headerStyle);\n            slotColumnMap.put(slot.getId(), col);\n            col++;\n        }\n\n        // Student rows with attendance\n        int no = 1;\n        for (Enrollment enrollment : enrollments) {\n            User student = enrollment.getStudent();\n            Row row = sheet.createRow(rowNum++);\n            row.createCell(0).setCellValue(no++);\n\n            StudentProfile profile = student.getStudentProfile();\n            row.createCell(1).setCellValue(profile != null ? profile.getRollNumber() : \"N/A\");\n            row.createCell(2).setCellValue(student.getFullName());\n\n            // Fill attendance for each slot\n            for (Slot slot : slots) {\n                int slotCol = slotColumnMap.get(slot.getId());\n                AttendanceRecord record = attendanceRecordRepository.findBySlotIdAndStudentUserId(slot.getId(), student.getId());\n                String status = record != null ? record.getStatus().name() : \"NOT_YET\";\n                row.createCell(slotCol).setCellValue(status);\n            }\n        }\n\n        // Auto-size first 3 columns\n        sheet.autoSizeColumn(0);\n        sheet.autoSizeColumn(1);\n        sheet.autoSizeColumn(2);\n    }\n\n    private void createExamSlotsOverviewSheet(Workbook workbook, List<Slot> slots, CellStyle headerStyle) {\n        Sheet sheet = workbook.createSheet(\"Overview\");\n        int rowNum = 0;\n\n        // Title\n        Row titleRow = sheet.createRow(rowNum++);\n        titleRow.createCell(0).setCellValue(\"EXAM SLOTS EXPORT REPORT\");\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Export Date: \" + LocalDateTime.now().format(DATETIME_FORMAT));\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Total Exam Slots: \" + slots.size());\n        rowNum++;\n\n        // Header\n        Row headerRow = sheet.createRow(rowNum++);\n        String[] headers = {\"No.\", \"Slot ID\", \"Title\", \"Date\", \"Time\", \"Room\", \"Supervisor\", \"Total Students\", \"Present\", \"Absent\"};\n        for (int i = 0; i < headers.length; i++) {\n            Cell cell = headerRow.createCell(i);\n            cell.setCellValue(headers[i]);\n            cell.setCellStyle(headerStyle);\n        }\n\n        // Data rows\n        int no = 1;\n        for (Slot slot : slots) {\n            Row row = sheet.createRow(rowNum++);\n            row.createCell(0).setCellValue(no++);\n            row.createCell(1).setCellValue(slot.getId());\n            row.createCell(2).setCellValue(slot.getTitle() != null ? slot.getTitle() : \"Exam Slot\");\n            row.createCell(3).setCellValue(slot.getStartTime().format(DATE_FORMAT));\n            row.createCell(4).setCellValue(slot.getStartTime().format(TIME_FORMAT) + \" - \" + slot.getEndTime().format(TIME_FORMAT));\n            row.createCell(5).setCellValue(slot.getRoom() != null ? slot.getRoom().getName() : \"N/A\");\n            row.createCell(6).setCellValue(slot.getStaff() != null ? slot.getStaff().getFullName() : \"N/A\");\n\n            // Get statistics\n            List<StudentAttendanceInfoDTO> students = examSlotParticipantRepository.findStudentsWithAttendanceBySlotId(slot.getId());\n            long present = students.stream().filter(s -> s.getStatus() == AttendanceStatus.PRESENT).count();\n            long absent = students.stream().filter(s -> s.getStatus() == AttendanceStatus.ABSENT).count();\n\n            row.createCell(7).setCellValue(students.size());\n            row.createCell(8).setCellValue(present);\n            row.createCell(9).setCellValue(absent);\n        }\n\n        for (int i = 0; i < headers.length; i++) {\n            sheet.autoSizeColumn(i);\n        }\n    }\n\n    private void createExamSlotDetailSheet(Workbook workbook, Slot slot, int sheetNum,\n                                           CellStyle headerStyle, CellStyle dateStyle) {\n        String sheetName = String.format(\"SLOT_%02d\", sheetNum);\n        Sheet sheet = workbook.createSheet(sheetName);\n        int rowNum = 0;\n\n        // Slot info\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"EXAM SLOT DETAILS\");\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Slot ID: \" + slot.getId());\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Title: \" + (slot.getTitle() != null ? slot.getTitle() : \"N/A\"));\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Date: \" + slot.getStartTime().format(DATE_FORMAT));\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Time: \" + slot.getStartTime().format(TIME_FORMAT) + \" - \" + slot.getEndTime().format(TIME_FORMAT));\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Room: \" + (slot.getRoom() != null ? slot.getRoom().getName() : \"N/A\"));\n        sheet.createRow(rowNum++).createCell(0).setCellValue(\"Supervisor: \" + (slot.getStaff() != null ? slot.getStaff().getFullName() : \"N/A\"));\n        rowNum++;\n\n        // Students header\n        Row headerRow = sheet.createRow(rowNum++);\n        String[] headers = {\"No.\", \"Roll Number\", \"Full Name\", \"Subject\", \"Status\", \"Check-in Time\", \"Remark\"};\n        for (int i = 0; i < headers.length; i++) {\n            Cell cell = headerRow.createCell(i);\n            cell.setCellValue(headers[i]);\n            cell.setCellStyle(headerStyle);\n        }\n\n        // Student rows\n        List<StudentAttendanceInfoDTO> students = examSlotParticipantRepository.findStudentsWithAttendanceBySlotId(slot.getId());\n        int no = 1;\n        for (StudentAttendanceInfoDTO student : students) {\n            Row row = sheet.createRow(rowNum++);\n            row.createCell(0).setCellValue(no++);\n            row.createCell(1).setCellValue(student.getRollNumber() != null ? student.getRollNumber() : \"N/A\");\n            row.createCell(2).setCellValue(student.getFullName() != null ? student.getFullName() : \"N/A\");\n            row.createCell(3).setCellValue(student.getSubjectCode() != null ? student.getSubjectCode() : \"N/A\");\n            row.createCell(4).setCellValue(student.getStatus() != null ? student.getStatus().name() : \"NOT_YET\");\n            row.createCell(5).setCellValue(formatInstant(student.getCheckInTime(), TIME_FORMAT));\n            row.createCell(6).setCellValue(student.getRemark() != null ? student.getRemark() : \"-\");\n        }\n\n        for (int i = 0; i < headers.length; i++) {\n            sheet.autoSizeColumn(i);\n        }\n    }\n\n    // ==================== HELPER METHODS - CSV GENERATION ====================\n\n    private String generateClassesOverviewCsv(List<AcademicClass> classes) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"CLASS EXPORT REPORT\\n\");\n        sb.append(\"Export Date,\").append(LocalDateTime.now().format(DATETIME_FORMAT)).append(\"\\n\");\n        sb.append(\"Total Classes,\").append(classes.size()).append(\"\\n\\n\");\n\n        sb.append(\"No.,Class Code,Subject,Subject Code,Semester,Total Students,Total Slots\\n\");\n\n        int no = 1;\n        for (AcademicClass cls : classes) {\n            List<Enrollment> enrollments = enrollmentRepository.findAllByAcademicClassId(cls.getId());\n            List<Slot> slots = slotRepository.findByClassId(cls.getId());\n\n            sb.append(no++).append(\",\");\n            sb.append(escapeCsv(cls.getCode())).append(\",\");\n            sb.append(escapeCsv(cls.getSubject() != null ? cls.getSubject().getName() : \"N/A\")).append(\",\");\n            sb.append(escapeCsv(cls.getSubject() != null ? cls.getSubject().getCode() : \"N/A\")).append(\",\");\n            sb.append(escapeCsv(cls.getSemester() != null ? cls.getSemester().getCode() : \"N/A\")).append(\",\");\n            sb.append(enrollments.size()).append(\",\");\n            sb.append(slots.size()).append(\"\\n\");\n        }\n\n        return sb.toString();\n    }\n\n    private String generateClassDetailCsv(AcademicClass cls) {\n        StringBuilder sb = new StringBuilder();\n\n        // Class info\n        sb.append(\"CLASS: \").append(cls.getCode()).append(\"\\n\");\n        sb.append(\"Subject: \").append(cls.getSubject() != null ? cls.getSubject().getName() : \"N/A\").append(\"\\n\");\n        sb.append(\"Semester: \").append(cls.getSemester() != null ? cls.getSemester().getCode() : \"N/A\").append(\"\\n\\n\");\n\n        // Get data\n        List<Slot> slots = slotRepository.findByClassId(cls.getId()).stream()\n                .filter(s -> s.getSlotCategory() != SlotCategory.FINAL_EXAM)\n                .sorted(Comparator.comparing(Slot::getStartTime))\n                .collect(Collectors.toList());\n        List<Enrollment> enrollments = enrollmentRepository.findAllByAcademicClassId(cls.getId());\n\n        // Header\n        sb.append(\"No.,Roll Number,Full Name\");\n        for (Slot slot : slots) {\n            sb.append(\",\").append(escapeCsv(slot.getStartTime().format(DATE_FORMAT) + \" \" + slot.getStartTime().format(TIME_FORMAT)));\n        }\n        sb.append(\"\\n\");\n\n        // Student rows\n        int no = 1;\n        for (Enrollment enrollment : enrollments) {\n            User student = enrollment.getStudent();\n            StudentProfile profile = student.getStudentProfile();\n\n            sb.append(no++).append(\",\");\n            sb.append(escapeCsv(profile != null ? profile.getRollNumber() : \"N/A\")).append(\",\");\n            sb.append(escapeCsv(student.getFullName()));\n\n            for (Slot slot : slots) {\n                AttendanceRecord record = attendanceRecordRepository.findBySlotIdAndStudentUserId(slot.getId(), student.getId());\n                String status = record != null ? record.getStatus().name() : \"NOT_YET\";\n                sb.append(\",\").append(status);\n            }\n            sb.append(\"\\n\");\n        }\n\n        return sb.toString();\n    }\n\n    private String generateExamSlotsOverviewCsv(List<Slot> slots) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"EXAM SLOTS EXPORT REPORT\\n\");\n        sb.append(\"Export Date,\").append(LocalDateTime.now().format(DATETIME_FORMAT)).append(\"\\n\");\n        sb.append(\"Total Exam Slots,\").append(slots.size()).append(\"\\n\\n\");\n\n        sb.append(\"No.,Slot ID,Title,Date,Time,Room,Supervisor,Total Students,Present,Absent\\n\");\n\n        int no = 1;\n        for (Slot slot : slots) {\n            List<StudentAttendanceInfoDTO> students = examSlotParticipantRepository.findStudentsWithAttendanceBySlotId(slot.getId());\n            long present = students.stream().filter(s -> s.getStatus() == AttendanceStatus.PRESENT).count();\n            long absent = students.stream().filter(s -> s.getStatus() == AttendanceStatus.ABSENT).count();\n\n            sb.append(no++).append(\",\");\n            sb.append(slot.getId()).append(\",\");\n            sb.append(escapeCsv(slot.getTitle() != null ? slot.getTitle() : \"Exam Slot\")).append(\",\");\n            sb.append(slot.getStartTime().format(DATE_FORMAT)).append(\",\");\n            sb.append(slot.getStartTime().format(TIME_FORMAT)).append(\"-\").append(slot.getEndTime().format(TIME_FORMAT)).append(\",\");\n            sb.append(escapeCsv(slot.getRoom() != null ? slot.getRoom().getName() : \"N/A\")).append(\",\");\n            sb.append(escapeCsv(slot.getStaff() != null ? slot.getStaff().getFullName() : \"N/A\")).append(\",\");\n            sb.append(students.size()).append(\",\");\n            sb.append(present).append(\",\");\n            sb.append(absent).append(\"\\n\");\n        }\n\n        return sb.toString();\n    }\n\n    private String generateExamSlotDetailCsv(Slot slot) {\n        StringBuilder sb = new StringBuilder();\n\n        // Slot info\n        sb.append(\"EXAM SLOT DETAILS\\n\");\n        sb.append(\"Slot ID,\").append(slot.getId()).append(\"\\n\");\n        sb.append(\"Title,\").append(escapeCsv(slot.getTitle() != null ? slot.getTitle() : \"N/A\")).append(\"\\n\");\n        sb.append(\"Date,\").append(slot.getStartTime().format(DATE_FORMAT)).append(\"\\n\");\n        sb.append(\"Time,\").append(slot.getStartTime().format(TIME_FORMAT)).append(\"-\").append(slot.getEndTime().format(TIME_FORMAT)).append(\"\\n\");\n        sb.append(\"Room,\").append(escapeCsv(slot.getRoom() != null ? slot.getRoom().getName() : \"N/A\")).append(\"\\n\");\n        sb.append(\"Supervisor,\").append(escapeCsv(slot.getStaff() != null ? slot.getStaff().getFullName() : \"N/A\")).append(\"\\n\\n\");\n\n        // Students\n        sb.append(\"No.,Roll Number,Full Name,Subject,Status,Check-in Time,Remark\\n\");\n\n        List<StudentAttendanceInfoDTO> students = examSlotParticipantRepository.findStudentsWithAttendanceBySlotId(slot.getId());\n        int no = 1;\n        for (StudentAttendanceInfoDTO student : students) {\n            sb.append(no++).append(\",\");\n            sb.append(escapeCsv(student.getRollNumber() != null ? student.getRollNumber() : \"N/A\")).append(\",\");\n            sb.append(escapeCsv(student.getFullName() != null ? student.getFullName() : \"N/A\")).append(\",\");\n            sb.append(escapeCsv(student.getSubjectCode() != null ? student.getSubjectCode() : \"N/A\")).append(\",\");\n            sb.append(student.getStatus() != null ? student.getStatus().name() : \"NOT_YET\").append(\",\");\n            sb.append(formatInstant(student.getCheckInTime(), TIME_FORMAT)).append(\",\");\n            sb.append(escapeCsv(student.getRemark() != null ? student.getRemark() : \"-\")).append(\"\\n\");\n        }\n\n        return sb.toString();\n    }\n\n    // ==================== UTILITY METHODS ====================\n\n    private static final ZoneId VIETNAM_ZONE = ZoneId.of(\"Asia/Ho_Chi_Minh\");\n\n    private String formatInstant(Instant instant, DateTimeFormatter formatter) {\n        if (instant == null) {\n            return \"-\";\n        }\n        return instant.atZone(VIETNAM_ZONE).format(formatter);\n    }\n\n    private void addToZip(ZipOutputStream zipOut, String filename, String content) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        zipOut.putNextEntry(entry);\n        zipOut.write(content.getBytes(StandardCharsets.UTF_8));\n        zipOut.closeEntry();\n    }\n\n    private String escapeCsv(String value) {\n        if (value == null) return \"\";\n        if (value.contains(\",\") || value.contains(\"\\\"\") || value.contains(\"\\n\")) {\n            return \"\\\"\" + value.replace(\"\\\"\", \"\\\"\\\"\") + \"\\\"\";\n        }\n        return value;\n    }\n\n    private String sanitizeFilename(String filename) {\n        return filename.replaceAll(\"[^a-zA-Z0-9.-]\", \"_\");\n    }\n\n    private String truncateSheetName(String name) {\n        // Excel sheet names max 31 chars\n        String sanitized = name.replaceAll(\"[\\\\[\\\\]\\\\*\\\\?/\\\\\\\\:]\", \"_\");\n        return sanitized.length() > 25 ? sanitized.substring(0, 25) : sanitized;\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\FaceEmbeddingService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/FaceEmbeddingService.java",
      "filename": "FaceEmbeddingService.java",
      "size_bytes": 7596,
      "lines": 187,
      "last_modified": "2025-11-11T17:04:14.602000",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.dto.response.PythonEmbeddingResponse;\nimport com.fuacs.backend.entity.FaceEmbedding;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.FaceEmbeddingRepository;\nimport com.fuacs.backend.repository.UserRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.Optional;\n\n/**\n * Service for managing face embeddings\n * Integrates with Python backend for embedding generation\n */\n@Service\npublic class FaceEmbeddingService {\n\n    private static final Logger logger = LoggerFactory.getLogger(FaceEmbeddingService.class);\n\n    private final FaceEmbeddingRepository faceEmbeddingRepository;\n    private final UserRepository userRepository;\n    private final PythonBackendClient pythonBackendClient;\n\n    public FaceEmbeddingService(FaceEmbeddingRepository faceEmbeddingRepository,\n            UserRepository userRepository,\n            PythonBackendClient pythonBackendClient) {\n        this.faceEmbeddingRepository = faceEmbeddingRepository;\n        this.userRepository = userRepository;\n        this.pythonBackendClient = pythonBackendClient;\n    }\n\n    /**\n     * Generate and save face embedding for a student\n     * Called after identity submission is approved\n     *\n     * Flow:\n     * 1. Validate student exists\n     * 2. Call Python backend to generate embedding\n     * 3. Deactivate old embeddings\n     * 4. Save new embedding as active\n     *\n     * @param studentUserId Student user ID\n     * @param photoPath     Path to static face photo\n     * @param videoPath     Path to face video\n     * @param submissionId  Identity submission ID (for logging)\n     * @return Saved face embedding entity\n     */\n    @Transactional\n    public FaceEmbedding generateAndSaveEmbedding(Integer studentUserId,\n            String photoPath,\n            String videoPath,\n            Integer submissionId) {\n        logger.info(\"Generating face embedding for studentUserId={}, submissionId={}\",\n                studentUserId, submissionId);\n\n        // Step 1: Validate student exists\n        User student = userRepository.findById(studentUserId)\n                .orElseThrow(() -> new ResourceNotFoundException(\n                        \"Student not found: \" + studentUserId,\n                        ErrorCode.USER_NOT_FOUND));\n\n        // Step 2: Call Python backend to generate embedding\n        PythonEmbeddingResponse response = pythonBackendClient.generateEmbedding(\n                photoPath,\n                videoPath,\n                submissionId);\n\n        if (response.getData() == null || response.getData().getEmbeddingVector() == null) {\n            logger.error(\"Python backend returned null embedding data\");\n            throw new BadRequestException(\n                    \"Failed to generate embedding: no data returned\",\n                    ErrorCode.EMBEDDING_GENERATION_FAILED);\n        }\n\n        float[] embeddingVector = response.getData().getEmbeddingVector();\n        if (embeddingVector.length != 512) {\n            logger.error(\"Invalid embedding dimension: expected 512, got {}\", embeddingVector.length);\n            throw new BadRequestException(\n                    \"Invalid embedding dimension: \" + embeddingVector.length,\n                    ErrorCode.EMBEDDING_GENERATION_FAILED);\n        }\n\n        // Step 3: Deactivate old embeddings for this student\n        faceEmbeddingRepository.deactivateByStudentId(studentUserId);\n        logger.info(\"Deactivated old embeddings for studentUserId={}\", studentUserId);\n\n        // Step 4: Create and save new embedding\n        // Determine version (increment from previous max version)\n        Integer newVersion = faceEmbeddingRepository.findByStudentIdOrderByVersionDesc(studentUserId)\n                .stream()\n                .findFirst()\n                .map(e -> e.getVersion() + 1)\n                .orElse(1);\n\n        FaceEmbedding newEmbedding = new FaceEmbedding();\n        newEmbedding.setStudent(student);\n        newEmbedding.setVersion(newVersion);\n        newEmbedding.setEmbeddingVector(embeddingVector);\n        newEmbedding.setActive(true); // This is the active embedding\n\n        FaceEmbedding saved = faceEmbeddingRepository.save(newEmbedding);\n        logger.info(\"Saved new face embedding: id={}, studentUserId={}, version={}, quality={}\",\n                saved.getId(), studentUserId, newVersion, response.getData().getQuality());\n\n        return saved;\n    }\n\n    /**\n     * Get active face embedding for a student\n     *\n     * @param studentUserId Student user ID\n     * @return Active embedding, or empty if none exists\n     */\n    @Transactional(readOnly = true)\n    public Optional<FaceEmbedding> getActiveEmbedding(Integer studentUserId) {\n        return faceEmbeddingRepository.findByStudentIdAndIsActiveTrue(studentUserId);\n    }\n\n    /**\n     * Check if student has an active face embedding\n     *\n     * @param studentUserId Student user ID\n     * @return true if active embedding exists\n     */\n    public boolean hasActiveEmbedding(Integer studentUserId) {\n        return faceEmbeddingRepository.existsByStudentIdAndIsActiveTrue(studentUserId);\n    }\n\n    /**\n     * Save embedding directly (without photo/video processing)\n     * Used by bulk upload\n     *\n     * @param studentUserId   Student user ID\n     * @param embeddingVector 512-dimensional embedding vector\n     * @return Saved face embedding entity\n     */\n    @Transactional\n    public FaceEmbedding saveEmbedding(Integer studentUserId, float[] embeddingVector) {\n        logger.info(\"Saving embedding for studentUserId={}\", studentUserId);\n\n        // Validate student exists\n        User student = userRepository.findById(studentUserId)\n            .orElseThrow(() -> new ResourceNotFoundException(\n                \"Student not found: \" + studentUserId,\n                ErrorCode.USER_NOT_FOUND\n            ));\n\n        // Validate embedding dimension\n        if (embeddingVector.length != 512) {\n            throw new BadRequestException(\n                \"Invalid embedding dimension: \" + embeddingVector.length,\n                ErrorCode.EMBEDDING_GENERATION_FAILED\n            );\n        }\n\n        // Deactivate old embeddings\n        faceEmbeddingRepository.deactivateByStudentId(studentUserId);\n        logger.info(\"Deactivated old embeddings for studentUserId={}\", studentUserId);\n\n        // Determine version\n        Integer newVersion = faceEmbeddingRepository.findByStudentIdOrderByVersionDesc(studentUserId)\n            .stream()\n            .findFirst()\n            .map(e -> e.getVersion() + 1)\n            .orElse(1);\n\n        // Create and save new embedding\n        FaceEmbedding newEmbedding = new FaceEmbedding();\n        newEmbedding.setStudent(student);\n        newEmbedding.setVersion(newVersion);\n        newEmbedding.setEmbeddingVector(embeddingVector);\n        newEmbedding.setActive(true);\n\n        FaceEmbedding saved = faceEmbeddingRepository.save(newEmbedding);\n        logger.info(\"Saved face embedding: id={}, studentUserId={}, version={}\",\n            saved.getId(), studentUserId, newVersion);\n\n        return saved;\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\LecturerDashboardService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/LecturerDashboardService.java",
      "filename": "LecturerDashboardService.java",
      "size_bytes": 7891,
      "lines": 157,
      "last_modified": "2025-11-21T19:16:59.616653",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.dto.response.*;\nimport com.fuacs.backend.entity.Semester;\nimport com.fuacs.backend.repository.*;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@Service\n@Transactional(readOnly = true)\npublic class LecturerDashboardService {\n\n    private final SlotRepository slotRepository;\n    private final SemesterRepository semesterRepository;\n    private final ClassRepository classRepository;\n\n    public LecturerDashboardService(SlotRepository slotRepository,\n                                    SemesterRepository semesterRepository,\n                                    ClassRepository classRepository) {\n        this.slotRepository = slotRepository;\n        this.semesterRepository = semesterRepository;\n        this.classRepository = classRepository;\n    }\n\n    public LecturerDashboardResponse getDashboardData(Integer lecturerId, Short requestedSemesterId) {\n        System.out.println(\"DEBUG LecturerDashboardService - lecturerId: \" + lecturerId + \", requestedSemesterId: \" + requestedSemesterId);\n\n        var semestersWithData = getSemestersWithSlotsRaw(lecturerId);\n        System.out.println(\"DEBUG - semestersWithData: \" + semestersWithData.stream().map(s -> s.getId() + \":\" + s.getName()).collect(java.util.stream.Collectors.toList()));\n\n        java.util.Set<Short> dataSemesterIds = semestersWithData.stream().map(Semester::getId).collect(java.util.stream.Collectors.toCollection(java.util.LinkedHashSet::new));\n        System.out.println(\"DEBUG - dataSemesterIds: \" + dataSemesterIds);\n\n        List<SemesterDTO> semesters = toSemesterListIncludingCurrent(semestersWithData);\n        Short selectedSemesterId = determineSelectedSemester(semesters, requestedSemesterId, dataSemesterIds);\n        System.out.println(\"DEBUG - selectedSemesterId: \" + selectedSemesterId);\n\n        DashboardStatsDTO stats = getStats(lecturerId, selectedSemesterId);\n        List<TodaySlotDTO> nextDaySlots = getNextDaySlots(lecturerId, selectedSemesterId);\n        List<MyClassDTO> myClasses = getMyClasses(lecturerId, selectedSemesterId);\n        return new LecturerDashboardResponse(semesters, selectedSemesterId, stats, nextDaySlots, myClasses);\n    }\n\n    private List<Semester> getSemestersWithSlotsRaw(Integer lecturerId) {\n        // Merge semesters from class-based and independent slots while preserving order (most recent first)\n        List<Semester> classSemesters = semesterRepository.findSemestersWithSlotsByLecturerId(lecturerId);\n        List<Semester> independentSemesters = semesterRepository.findIndependentSemestersWithSlotsByLecturerId(lecturerId);\n        java.util.LinkedHashMap<Short, Semester> merged = new java.util.LinkedHashMap<>();\n        for (Semester s : classSemesters) merged.put(s.getId(), s);\n        for (Semester s : independentSemesters) merged.putIfAbsent(s.getId(), s);\n        return new java.util.ArrayList<>(merged.values());\n    }\n\n    private List<SemesterDTO> toSemesterListIncludingCurrent(List<Semester> semestersWithData) {\n        java.util.LinkedHashMap<Short, Semester> map = new java.util.LinkedHashMap<>();\n        for (Semester s : semestersWithData) map.put(s.getId(), s);\n        List<Semester> currentSemesters = semesterRepository.findCurrentSemesters();\n        Semester current = !currentSemesters.isEmpty() ? currentSemesters.get(0) : null;\n        if (current != null && !map.containsKey(current.getId())) {\n            // include current semester in list for UX, even if no data\n            map.put(current.getId(), current);\n        }\n        return map.values().stream().map(this::mapToSemesterDTO).collect(Collectors.toList());\n    }\n\n    private Short determineSelectedSemester(List<SemesterDTO> semesters, Short requestedSemesterId, java.util.Set<Short> dataSemesterIds) {\n        // CHANGED: Simplified logic to support \"All Semester\" mode\n        // If specific semester is requested, use it (even if it has no data)\n        // If null is requested, return null to indicate \"All Semester\" mode\n        // Frontend is responsible for auto-selecting current semester on initial load\n        return requestedSemesterId;\n    }\n\n    private DashboardStatsDTO getStats(Integer lecturerId, Short semesterId) {\n        // CHANGED: Support \"All Semester\" mode when semesterId is null\n        if (semesterId == null) {\n            return slotRepository.calculateLecturerStatsAllSemesters(lecturerId);\n        }\n        return slotRepository.calculateLecturerStats(lecturerId, semesterId);\n    }\n\n    private List<TodaySlotDTO> getNextDaySlots(Integer lecturerId, Short selectedSemesterId) {\n        // Find the next nearest day that has slots (LECTURE or LECTURE_WITH_PT only)\n        LocalDate today = LocalDate.now(java.time.ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n\n        // Get all upcoming slots for the next 30 days\n        LocalDateTime searchStart = today.atStartOfDay();\n        LocalDateTime searchEnd = today.plusDays(30).atTime(23, 59, 59);\n\n        List<TodaySlotDTO> upcomingSlots;\n        if (selectedSemesterId != null) {\n            upcomingSlots = slotRepository.findUpcomingSlotsForNextDay(lecturerId, selectedSemesterId, searchStart, searchEnd);\n        } else {\n            upcomingSlots = slotRepository.findUpcomingSlotsForNextDayAllSemesters(lecturerId, searchStart, searchEnd);\n        }\n\n        if (upcomingSlots.isEmpty()) {\n            return List.of();\n        }\n\n        // Find the earliest slot date\n        LocalDate earliestDate = upcomingSlots.stream()\n            .map(s -> s.getStartTime().toLocalDate())\n            .min(LocalDate::compareTo)\n            .orElse(null);\n\n        if (earliestDate == null) {\n            return List.of();\n        }\n\n        // Filter to only slots on that earliest date\n        LocalDate finalEarliestDate = earliestDate;\n        List<TodaySlotDTO> nextDaySlots = upcomingSlots.stream()\n            .filter(s -> s.getStartTime().toLocalDate().equals(finalEarliestDate))\n            .collect(Collectors.toList());\n\n        // Populate attendance stats\n        nextDaySlots.forEach(s -> s.setAttendanceStats(slotRepository.getAttendanceStats(s.getId())));\n\n        return nextDaySlots;\n    }\n\n    private List<MyClassDTO> getMyClasses(Integer lecturerId, Short semesterId) {\n        List<MyClassDTO> classes;\n        if (semesterId == null) {\n            // All Semester mode: Get all classes sorted by semester start date DESC\n            classes = classRepository.findClassesWithStatsByLecturer(lecturerId);\n        } else {\n            classes = classRepository.findClassesWithStatsByLecturerAndSemester(lecturerId, semesterId);\n        }\n\n        // Populate next slot (upcoming or active) for each class\n        classes.forEach(classDto -> {\n            try {\n                List<TodaySlotDTO> upcomingSlots = classRepository.findUpcomingSlotsForClass(\n                    classDto.getId(),\n                    1  // Limit to 1 next slot per class (includes active slot)\n                );\n                classDto.setUpcomingSlots(upcomingSlots);\n            } catch (Exception e) {\n                System.err.println(\"ERROR getting upcoming slots for class \" + classDto.getId() + \": \" + e.getMessage());\n                classDto.setUpcomingSlots(List.of());  // Empty list on error\n            }\n        });\n\n        return classes;\n    }\n\n    private SemesterDTO mapToSemesterDTO(Semester semester) {\n        return new SemesterDTO(semester.getId(), semester.getName(), semester.getCode(), semester.getStartDate(), semester.getEndDate(), semester.getActive());\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\LecturerService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/LecturerService.java",
      "filename": "LecturerService.java",
      "size_bytes": 11384,
      "lines": 258,
      "last_modified": "2025-11-24T08:04:00.063236",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.dto.mapper.ClassMapper;\nimport com.fuacs.backend.dto.mapper.SemesterMapper;\nimport com.fuacs.backend.dto.mapper.SubjectMapper;\nimport com.fuacs.backend.dto.response.ClassDTO;\nimport com.fuacs.backend.dto.response.LecturerSemesterClassesDTO;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.entity.AcademicClass;\nimport com.fuacs.backend.entity.Semester;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.repository.ClassRepository;\nimport com.fuacs.backend.repository.SemesterRepository;\nimport com.fuacs.backend.util.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * Service class for lecturer-specific operations.\n * Handles retrieving semesters and classes assigned to the authenticated lecturer.\n */\n@Service\npublic class LecturerService {\n\n    private static final Logger log = LoggerFactory.getLogger(LecturerService.class);\n\n    private final SemesterRepository semesterRepository;\n    private final ClassRepository classRepository;\n    private final ClassMapper classMapper;\n    private final SemesterMapper semesterMapper;\n    private final SubjectMapper subjectMapper;\n\n    public LecturerService(SemesterRepository semesterRepository,\n                          ClassRepository classRepository,\n                          ClassMapper classMapper,\n                          SemesterMapper semesterMapper,\n                          SubjectMapper subjectMapper) {\n        this.semesterRepository = semesterRepository;\n        this.classRepository = classRepository;\n        this.classMapper = classMapper;\n        this.semesterMapper = semesterMapper;\n        this.subjectMapper = subjectMapper;\n    }\n\n    /**\n     * Get all semesters where the authenticated lecturer has assigned classes.\n     * \n     * @return List of SemesterDTO containing semesters with lecturer's classes\n     */\n    @Transactional(readOnly = true)\n    public List<SemesterDTO> getLecturerSemesters() {\n\n        // Get current authenticated lecturer ID\n        Integer currentUserId = SecurityUtil.getLoginUserId()\n            .orElseThrow(() -> new OperationNotAllowedException(\n                \"User not authenticated\", ErrorCode.UN_AUTHENTICATION));\n\n        // Get semesters where lecturer has slots assigned\n        List<Semester> semesters = semesterRepository.findSemestersWithSlotsByLecturerId(currentUserId);\n        \n        // Also get semesters from independent slots (if any)\n        List<Semester> independentSemesters = semesterRepository.findIndependentSemestersWithSlotsByLecturerId(currentUserId);\n        \n        // Combine and deduplicate\n        semesters.addAll(independentSemesters);\n        List<Semester> uniqueSemesters = semesters.stream()\n            .distinct()\n            .collect(Collectors.toList());\n\n        return uniqueSemesters.stream()\n            .map(this::convertToSemesterDTO)\n            .collect(Collectors.toList());\n    }\n\n    /**\n     * Get all classes assigned to the authenticated lecturer in a specific semester.\n     * \n     * @param semesterId The semester ID to filter classes\n     * @return List of ClassDTO containing lecturer's classes in the semester\n     */\n    @Transactional(readOnly = true)\n    public List<ClassDTO> getLecturerClasses(Short semesterId) {\n        // Get current authenticated lecturer ID\n        Integer currentUserId = SecurityUtil.getLoginUserId()\n            .orElseThrow(() -> new OperationNotAllowedException(\n                \"User not authenticated\", ErrorCode.UN_AUTHENTICATION));\n\n        // Get classes where lecturer has slots assigned in the specified semester\n        List<AcademicClass> classes = classRepository.findClassesByLecturerAndSemester(currentUserId, semesterId);\n\n        return classes.stream()\n            .map(this::convertToClassDTO)\n            .collect(Collectors.toList());\n    }\n\n    /**\n     * Get all semesters with their associated classes for the authenticated lecturer.\n     * Returns hierarchical structure ordered by semester start date (newest first), then by class code.\n     * \n     * @return List of LecturerSemesterClassesDTO with nested classes\n     */\n    @Transactional(readOnly = true)\n    public List<LecturerSemesterClassesDTO> getLecturerSemestersWithClasses() {\n        // Get current authenticated lecturer ID\n        Integer currentUserId = SecurityUtil.getLoginUserId()\n            .orElseThrow(() -> new OperationNotAllowedException(\n                \"User not authenticated\", ErrorCode.UN_AUTHENTICATION));\n\n        // Get semesters where lecturer has slots assigned\n        List<Semester> semesters = semesterRepository.findSemestersWithSlotsByLecturerId(currentUserId);\n        \n        // Also get semesters from independent slots (if any)\n        List<Semester> independentSemesters = semesterRepository.findIndependentSemestersWithSlotsByLecturerId(currentUserId);\n        \n        // Combine and deduplicate\n        semesters.addAll(independentSemesters);\n        List<Semester> uniqueSemesters = semesters.stream()\n            .distinct()\n            .sorted((s1, s2) -> s2.getStartDate().compareTo(s1.getStartDate())) // Newest first\n            .collect(Collectors.toList());\n\n        // Build the hierarchical structure\n        List<LecturerSemesterClassesDTO> result = uniqueSemesters.stream()\n            .map(semester -> {\n                // Get classes for this semester\n                List<AcademicClass> classes = classRepository.findClassesByLecturerAndSemester(currentUserId, semester.getId());\n                \n                // Sort classes by code\n                classes.sort((c1, c2) -> c1.getCode().compareToIgnoreCase(c2.getCode()));\n                \n                // Convert classes to DTOs\n                List<LecturerSemesterClassesDTO.LecturerClassDTO> classDTOs = classes.stream()\n                    .map(this::convertToLecturerClassDTO)\n                    .collect(Collectors.toList());\n\n                // Create semester DTO with classes\n                LecturerSemesterClassesDTO semesterDTO = new LecturerSemesterClassesDTO();\n                semesterDTO.setId(semester.getId());\n                semesterDTO.setName(semester.getName());\n                semesterDTO.setCode(semester.getCode());\n                semesterDTO.setStartDate(semester.getStartDate());\n                semesterDTO.setEndDate(semester.getEndDate());\n                semesterDTO.setIsActive(semester.getActive());\n                semesterDTO.setCreatedAt(semester.getCreatedAt());\n                semesterDTO.setUpdatedAt(semester.getUpdatedAt());\n                semesterDTO.setClasses(classDTOs);\n\n                return semesterDTO;\n            })\n            .collect(Collectors.toList());\n\n        return result;\n    }\n\n    /**\n     * Get all semesters with their associated classes for a specific lecturer by userId.\n     * Used by admin to view any lecturer's data.\n     * Returns hierarchical structure ordered by semester start date (newest first), then by class code.\n     *\n     * @param userId The lecturer's user ID\n     * @return List of LecturerSemesterClassesDTO with nested classes\n     */\n    @Transactional(readOnly = true)\n    public List<LecturerSemesterClassesDTO> getLecturerSemestersWithClassesByUserId(Integer userId) {\n        // Get semesters where lecturer has slots assigned\n        List<Semester> semesters = semesterRepository.findSemestersWithSlotsByLecturerId(userId);\n\n        // Also get semesters from independent slots (if any)\n        List<Semester> independentSemesters = semesterRepository.findIndependentSemestersWithSlotsByLecturerId(userId);\n\n        // Combine and deduplicate\n        semesters.addAll(independentSemesters);\n        List<Semester> uniqueSemesters = semesters.stream()\n            .distinct()\n            .sorted((s1, s2) -> s2.getStartDate().compareTo(s1.getStartDate())) // Newest first\n            .collect(Collectors.toList());\n\n        // Build the hierarchical structure\n        List<LecturerSemesterClassesDTO> result = uniqueSemesters.stream()\n            .map(semester -> {\n                // Get classes for this semester\n                List<AcademicClass> classes = classRepository.findClassesByLecturerAndSemester(userId, semester.getId());\n\n                // Sort classes by code\n                classes.sort((c1, c2) -> c1.getCode().compareToIgnoreCase(c2.getCode()));\n\n                // Convert classes to DTOs\n                List<LecturerSemesterClassesDTO.LecturerClassDTO> classDTOs = classes.stream()\n                    .map(this::convertToLecturerClassDTO)\n                    .collect(Collectors.toList());\n\n                // Create semester DTO with classes\n                LecturerSemesterClassesDTO semesterDTO = new LecturerSemesterClassesDTO();\n                semesterDTO.setId(semester.getId());\n                semesterDTO.setName(semester.getName());\n                semesterDTO.setCode(semester.getCode());\n                semesterDTO.setStartDate(semester.getStartDate());\n                semesterDTO.setEndDate(semester.getEndDate());\n                semesterDTO.setIsActive(semester.getActive());\n                semesterDTO.setCreatedAt(semester.getCreatedAt());\n                semesterDTO.setUpdatedAt(semester.getUpdatedAt());\n                semesterDTO.setClasses(classDTOs);\n\n                return semesterDTO;\n            })\n            .collect(Collectors.toList());\n\n        return result;\n    }\n\n    /**\n     * Convert AcademicClass entity to LecturerClassDTO (nested DTO).\n     * \n     * @param academicClass The academic class entity\n     * @return LecturerClassDTO\n     */\n    private LecturerSemesterClassesDTO.LecturerClassDTO convertToLecturerClassDTO(AcademicClass academicClass) {\n        LecturerSemesterClassesDTO.LecturerClassDTO dto = new LecturerSemesterClassesDTO.LecturerClassDTO();\n        dto.setId(academicClass.getId());\n        dto.setCode(academicClass.getCode());\n        dto.setIsActive(academicClass.getActive());\n        dto.setCreatedAt(academicClass.getCreatedAt());\n        dto.setUpdatedAt(academicClass.getUpdatedAt());\n        \n        // Convert subject using mapper\n        if (academicClass.getSubject() != null) {\n            dto.setSubject(subjectMapper.toDTO(academicClass.getSubject()));\n        }\n        \n        return dto;\n    }\n\n    /**\n     * Convert Semester entity to SemesterDTO.\n     * \n     * @param semester The semester entity\n     * @return SemesterDTO\n     */\n    private SemesterDTO convertToSemesterDTO(Semester semester) {\n        return semesterMapper.toDTO(semester);\n    }\n\n    /**\n     * Convert AcademicClass entity to ClassDTO.\n     * \n     * @param academicClass The academic class entity\n     * @return ClassDTO\n     */\n    private ClassDTO convertToClassDTO(AcademicClass academicClass) {\n        return classMapper.toDTO(academicClass);\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\MajorService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/MajorService.java",
      "filename": "MajorService.java",
      "size_bytes": 10584,
      "lines": 257,
      "last_modified": "2025-11-21T21:39:58.762658",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.dto.mapper.MajorMapper;\nimport com.fuacs.backend.dto.request.MajorCreateRequest;\nimport com.fuacs.backend.dto.request.MajorCsvRow;\nimport com.fuacs.backend.dto.request.MajorSearchRequest;\nimport com.fuacs.backend.dto.request.MajorUpdateRequest;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.dto.response.MajorDTO;\nimport com.fuacs.backend.entity.Major;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.MajorRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\n@Service\npublic class MajorService {\n\n    private static final Logger logger = LoggerFactory.getLogger(MajorService.class);\n\n    private final MajorRepository majorRepository;\n    private final MajorMapper majorMapper;\n    private final CsvParserService csvParserService;\n\n    public MajorService(MajorRepository majorRepository,\n            MajorMapper majorMapper,\n            CsvParserService csvParserService) {\n        this.majorRepository = majorRepository;\n        this.majorMapper = majorMapper;\n        this.csvParserService = csvParserService;\n    }\n\n    public List<MajorDTO> search(MajorSearchRequest request) {\n        return majorRepository.search(request);\n    }\n\n    public Long count(MajorSearchRequest request) {\n        return majorRepository.count(request);\n    }\n\n    public MajorDTO findById(Short id) {\n        return majorRepository.findMajorDTOById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Major not found: \" + id, ErrorCode.MAJOR_NOT_FOUND));\n    }\n\n    @Transactional\n    public MajorDTO create(MajorCreateRequest request) {\n        if (majorRepository.existsByCode(request.getCode())) {\n            throw new ResourceExistsException(\"Major code already exists: \" + request.getCode(),\n                    ErrorCode.MAJOR_CODE_EXISTS);\n        }\n        if (majorRepository.existsByName(request.getName())) {\n            throw new ResourceExistsException(\"Major name already exists: \" + request.getName(),\n                    ErrorCode.MAJOR_NAME_EXISTS);\n        }\n\n        Major major = majorMapper.toEntity(request);\n        return majorMapper.toDTO(majorRepository.save(major));\n    }\n\n    @Transactional\n    public MajorDTO update(Short id, MajorUpdateRequest request) {\n        Major existing = majorRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Major not found: \" + id, ErrorCode.MAJOR_NOT_FOUND));\n\n        if (!existing.getCode().equals(request.getCode()) &&\n                majorRepository.existsByCodeAndIdNot(request.getCode(), id)) {\n            throw new ResourceExistsException(\"Major code already exists: \" + request.getCode(),\n                    ErrorCode.MAJOR_CODE_EXISTS);\n        }\n        if (!existing.getName().equals(request.getName()) &&\n                majorRepository.existsByNameAndIdNot(request.getName(), id)) {\n            throw new ResourceExistsException(\"Major name already exists: \" + request.getName(),\n                    ErrorCode.MAJOR_NAME_EXISTS);\n        }\n\n        majorMapper.updateFromRequest(request, existing);\n        return majorMapper.toDTO(majorRepository.save(existing));\n    }\n\n    @Transactional\n    public void delete(Short id) {\n        if (!majorRepository.existsById(id)) {\n            throw new ResourceNotFoundException(\"Major not found: \" + id, ErrorCode.MAJOR_NOT_FOUND);\n        }\n        long subjectCount = majorRepository.countSubjectsByMajorId(id);\n        long studentCount = majorRepository.countStudentsByMajorId(id);\n\n        if (subjectCount > 0 || studentCount > 0) {\n            throw new OperationNotAllowedException(\"Cannot delete major. Found \" + subjectCount + \" subjects and \"\n                    + studentCount + \" students. Please reassign or delete them first\",\n                    ErrorCode.MAJOR_HAS_DEPENDENCIES);\n        }\n        try {\n            majorRepository.deleteById(id);\n        } catch (DataIntegrityViolationException e) {\n            throw new OperationNotAllowedException(\"Cannot delete major. It is currently in use by other records.\",\n                    ErrorCode.FOREIGN_KEY_CONSTRAINT_VIOLATION);\n        }\n    }\n\n    /**\n     * Import majors from CSV file with partial success pattern.\n     * Supports AddOnly and AddAndUpdate modes.\n     *\n     * Note: No @Transactional here to avoid rollback-only conflict.\n     * Each row is processed in its own REQUIRES_NEW transaction.\n     *\n     * @param file    CSV file containing majors\n     * @param modeStr Import mode (\"AddOnly\" or \"AddAndUpdate\")\n     * @return ImportResultDTO with success/failure counts and errors\n     */\n    public ImportResultDTO importFromCsv(MultipartFile file, String modeStr) {\n        logger.info(\"Starting major CSV import with mode: {}\", modeStr);\n\n        // Parse mode\n        ImportMode mode;\n        try {\n            mode = ImportMode.fromString(modeStr);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), ErrorCode.INVALID_IMPORT_MODE);\n        }\n\n        // Parse CSV\n        List<MajorCsvRow> rows;\n        try {\n            rows = csvParserService.parseMajorCsv(file);\n        } catch (IOException e) {\n            throw new BadRequestException(\"Failed to process CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        logger.info(\"Parsed {} rows from CSV\", rows.size());\n\n        // Deduplicate within file by code (business key)\n        Map<String, MajorCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (MajorCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getCode(), row);\n        }\n\n        logger.info(\"After deduplication: {} unique majors\", uniqueRows.size());\n\n        // Process rows with partial success\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (MajorCsvRow row : uniqueRows.values()) {\n            try {\n                processOneMajorRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                logger.warn(\"Failed to process row {}: {}\", row.getRowNumber(), e.getMessage());\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()));\n            }\n        }\n\n        logger.info(\"Major import completed: {} successful, {} failed\", successCount, errors.size());\n\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Process a single major row in a separate transaction.\n     * This ensures one row's failure doesn't affect others (partial success).\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneMajorRow(MajorCsvRow row, ImportMode mode) {\n        // Validate row\n        if (!row.isValid()) {\n            throw new BadRequestException(\"Invalid row data\", ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Check if major exists\n        Major existing = majorRepository.findByCode(row.getCode());\n\n        if (existing != null) {\n            if (mode == ImportMode.ADD_ONLY) {\n                throw new ResourceExistsException(\n                        \"Major code already exists: \" + row.getCode(),\n                        ErrorCode.MAJOR_CODE_EXISTS);\n            }\n\n            // AddAndUpdate mode: Update existing major\n            Major major = existing;\n\n            // Check name uniqueness if changing name\n            if (!major.getName().equals(row.getName()) && majorRepository.existsByName(row.getName())) {\n                throw new ResourceExistsException(\n                        \"Major name already exists: \" + row.getName(),\n                        ErrorCode.MAJOR_NAME_EXISTS);\n            }\n\n            major.setName(row.getName());\n            if (row.getIsActive() != null) {\n                major.setActive(row.getIsActive());\n            }\n            major.setUpdatedAt(Instant.now());\n            majorRepository.save(major);\n\n        } else {\n            // Check name uniqueness for new record\n            if (majorRepository.existsByName(row.getName())) {\n                throw new ResourceExistsException(\n                        \"Major name already exists: \" + row.getName(),\n                        ErrorCode.MAJOR_NAME_EXISTS);\n            }\n\n            // Create new major\n            Major major = new Major();\n            major.setCode(row.getCode());\n            major.setName(row.getName());\n            // If status provided → use it; else default to true on create\n            major.setActive(row.getIsActive() != null ? row.getIsActive() : true);\n            major.setCreatedAt(Instant.now());\n            majorRepository.save(major);\n\n        }\n    }\n\n    /**\n     * Extract error code from exception.\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\PermissionService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/PermissionService.java",
      "filename": "PermissionService.java",
      "size_bytes": 4009,
      "lines": 88,
      "last_modified": "2025-10-29T20:56:54.620679",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.dto.mapper.PermissionMapper;\nimport com.fuacs.backend.dto.request.PermissionCreateRequest;\nimport com.fuacs.backend.dto.request.PermissionSearchRequest;\nimport com.fuacs.backend.dto.request.PermissionUpdateRequest;\nimport com.fuacs.backend.dto.response.PermissionDTO;\nimport com.fuacs.backend.entity.Permission;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.PermissionRepository;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@Service\npublic class PermissionService {\n\n    private final PermissionRepository permissionRepository;\n    private final PermissionMapper permissionMapper;\n\n    public PermissionService(PermissionRepository permissionRepository,\n                             PermissionMapper permissionMapper) {\n        this.permissionRepository = permissionRepository;\n        this.permissionMapper = permissionMapper;\n    }\n\n    @Transactional(readOnly = true)\n    public List<PermissionDTO> findAll(PermissionSearchRequest request) {\n        return permissionRepository\n                .findByNameLike(request.getSearch(), null)\n                .stream()\n                .map(permissionMapper::toDTO)\n                .collect(Collectors.toList());\n    }\n\n    public Long countAll(String search) {\n        return permissionRepository.countAll(search);\n    }\n\n    @Transactional(readOnly = true)\n    public PermissionDTO findById(Short id) {\n        return permissionRepository.findById(id)\n                .map(permissionMapper::toDTO)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Permission not found: \" + id, ErrorCode.PERMISSION_NOT_FOUND));\n    }\n\n    @Transactional\n    public PermissionDTO create(PermissionCreateRequest request) {\n        if (permissionRepository.existsByName(request.getName())) {\n            throw new BadRequestException(\"Permission name exists: \" + request.getName(), ErrorCode.PERMISSION_NAME_EXISTS);\n        }\n        Permission permission = permissionMapper.toEntity(request);\n        permission.setActive(true);\n        Permission savedPermission = permissionRepository.save(permission);\n        return permissionMapper.toDTO(savedPermission);\n    }\n\n    @Transactional\n    public PermissionDTO update(Short id, PermissionUpdateRequest request) {\n        Permission existingPermission = permissionRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Permission not found: \" + id, ErrorCode.PERMISSION_NOT_FOUND));\n        if (!existingPermission.getName().equals(request.getName())\n                && permissionRepository.existsByName(request.getName())) {\n            throw new BadRequestException(\"Permission name already exists: \" + request.getName(), ErrorCode.PERMISSION_NAME_EXISTS);\n        }\n        existingPermission.setActive(request.getActive());\n        existingPermission.setName(request.getName());\n        return permissionMapper.toDTO(permissionRepository.save(existingPermission));\n    }\n\n    @Transactional\n    public void delete(Short id) {\n        if (!permissionRepository.existsById(id)) {\n            throw new ResourceNotFoundException(\"Permission not found: \" + id, ErrorCode.PERMISSION_NOT_FOUND);\n        }\n        try {\n            permissionRepository.deleteById(id);\n        } catch (DataIntegrityViolationException e) {\n            // This exception is thrown when a foreign key constraint is violated.\n            throw new BadRequestException(\"Cannot delete permission. It is currently in use by other records (e.g., roles).\", ErrorCode.PERMISSION_CONSTRAINT);\n        }\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\PythonBackendClient.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/PythonBackendClient.java",
      "filename": "PythonBackendClient.java",
      "size_bytes": 16402,
      "lines": 361,
      "last_modified": "2025-11-11T17:48:22.219785",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.dto.request.python.PythonEmbeddingRequest;\nimport com.fuacs.backend.dto.request.python.PythonStartSessionRequest;\nimport com.fuacs.backend.dto.request.python.PythonStopSessionRequest;\nimport com.fuacs.backend.dto.response.PythonEmbeddingResponse;\nimport com.fuacs.backend.dto.response.PythonSessionResponse;\nimport com.fuacs.backend.exception.BadRequestException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.MediaType;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.web.client.HttpClientErrorException;\nimport org.springframework.web.client.HttpServerErrorException;\nimport org.springframework.web.client.ResourceAccessException;\nimport org.springframework.web.client.RestTemplate;\n\nimport java.nio.file.Path;\n\n/**\n * HTTP Client wrapper for Python Backend API calls\n * Handles communication with Face Recognition Service (FastAPI)\n */\n@Service\npublic class PythonBackendClient {\n\n    private static final Logger logger = LoggerFactory.getLogger(PythonBackendClient.class);\n\n    private final RestTemplate restTemplate;\n\n    public PythonBackendClient(@Qualifier(\"pythonBackendRestTemplate\") RestTemplate restTemplate) {\n        this.restTemplate = restTemplate;\n    }\n\n    /**\n     * Start face recognition session\n     * POST /api/v1/recognition/process-session\n     *\n     * @param request Session start request with students, cameras, config\n     * @return Python backend response with session status\n     * @throws BadRequestException if Python backend returns 4xx\n     * @throws RuntimeException    if Python backend is unavailable or returns 5xx\n     */\n    public PythonSessionResponse startRecognitionSession(PythonStartSessionRequest request) {\n        String endpoint = \"/api/v1/recognition/process-session\";\n\n        try {\n            ResponseEntity<PythonSessionResponse> response = restTemplate.postForEntity(\n                    endpoint,\n                    request,\n                    PythonSessionResponse.class);\n\n            PythonSessionResponse body = response.getBody();\n            if (body != null && body.getStatus() == 200) {\n                logger.info(\"Session started successfully for slotId={}, activeCameras={}\",\n                        request.getSlotId(), body.getData().getActiveCameras());\n                return body;\n            } else {\n                logger.error(\"Unexpected response from Python backend: status={}\",\n                        body != null ? body.getStatus() : \"null\");\n                throw new BadRequestException(\n                        \"Python backend returned unexpected status\",\n                        ErrorCode.PYTHON_BACKEND_ERROR);\n            }\n\n        } catch (HttpClientErrorException e) {\n            // 4xx errors from Python backend\n            logger.error(\"Python backend returned 4xx error: {} - {}\",\n                    e.getStatusCode(), e.getResponseBodyAsString());\n\n            // Map Python error codes to Java error codes\n            if (e.getStatusCode().value() == 409) {\n                throw new BadRequestException(\n                        \"Face recognition session already exists for this slot\",\n                        ErrorCode.SESSION_ALREADY_EXISTS);\n            } else if (e.getStatusCode().value() == 400) {\n                throw new BadRequestException(\n                        \"Invalid request to Python backend: \" + e.getMessage(),\n                        ErrorCode.PYTHON_BACKEND_ERROR);\n            } else {\n                throw new BadRequestException(\n                        \"Python backend error: \" + e.getMessage(),\n                        ErrorCode.PYTHON_BACKEND_ERROR);\n            }\n\n        } catch (HttpServerErrorException e) {\n            // 5xx errors from Python backend\n            logger.error(\"Python backend returned 5xx error: {} - {}\",\n                    e.getStatusCode(), e.getResponseBodyAsString());\n\n            // Extract clean error message from Python response\n            String responseBody = e.getResponseBodyAsString();\n            String errorMessage = extractPythonErrorMessage(responseBody);\n\n            // Check for specific error codes\n            if (responseBody.contains(\"ALL_CAMERAS_FAILED\")) {\n                throw new BadRequestException(\n                        errorMessage,\n                        ErrorCode.ALL_CAMERAS_FAILED);\n            }\n\n            throw new RuntimeException(errorMessage);\n\n        } catch (ResourceAccessException e) {\n            // Network/timeout errors\n            logger.error(\"Failed to connect to Python backend: {}\", e.getMessage());\n            throw new RuntimeException(\n                    \"Python backend is unavailable. Please check connection.\");\n        }\n    }\n\n    /**\n     * Stop face recognition session\n     * POST /api/v1/recognition/stop-session\n     *\n     * @param slotId Slot ID to stop session for\n     * @return Python backend response with session statistics\n     */\n    public PythonSessionResponse stopRecognitionSession(Integer slotId) {\n        String endpoint = \"/api/v1/recognition/stop-session\";\n\n        logger.info(\"Calling Python backend: POST {} for slotId={}\", endpoint, slotId);\n\n        try {\n            PythonStopSessionRequest request = new PythonStopSessionRequest(slotId);\n\n            ResponseEntity<PythonSessionResponse> response = restTemplate.postForEntity(\n                    endpoint,\n                    request,\n                    PythonSessionResponse.class);\n\n            PythonSessionResponse body = response.getBody();\n            if (body != null && body.getStatus() == 200) {\n                logger.info(\"Session stopped successfully for slotId={}\", slotId);\n                return body;\n            } else {\n                logger.error(\"Unexpected response from Python backend when stopping session\");\n                throw new BadRequestException(\n                        \"Failed to stop session\",\n                        ErrorCode.SESSION_STOP_FAILED);\n            }\n\n        } catch (HttpClientErrorException e) {\n            if (e.getStatusCode().value() == 404) {\n                logger.warn(\"No active session found for slotId={}\", slotId);\n                throw new BadRequestException(\n                        \"No active face recognition session found for this slot\",\n                        ErrorCode.SESSION_NOT_FOUND);\n            } else {\n                logger.error(\"Python backend error when stopping session: {}\", e.getMessage());\n                String errorMessage = extractPythonErrorMessage(e.getResponseBodyAsString());\n                throw new BadRequestException(\n                        errorMessage,\n                        ErrorCode.PYTHON_BACKEND_ERROR);\n            }\n\n        } catch (HttpServerErrorException e) {\n            // 5xx errors from Python backend\n            logger.error(\"Python backend returned 5xx error when stopping session: {} - {}\",\n                    e.getStatusCode(), e.getResponseBodyAsString());\n            String errorMessage = extractPythonErrorMessage(e.getResponseBodyAsString());\n            throw new RuntimeException(errorMessage);\n\n        } catch (ResourceAccessException e) {\n            // Network/timeout errors\n            logger.error(\"Failed to connect to Python backend: {}\", e.getMessage());\n            throw new RuntimeException(\"Python backend is unavailable. Please check connection.\");\n\n        } catch (Exception e) {\n            logger.error(\"Error stopping recognition session: {}\", e.getMessage());\n            throw new RuntimeException(\"Failed to stop recognition session: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Generate face embedding from photo and video\n     * POST /api/v1/embeddings/generate\n     *\n     * @param photoUrl     Path to static face photo\n     * @param videoUrl     Path to face video\n     * @param submissionId Identity submission ID (for logging)\n     * @return 512-dimensional face embedding with quality metrics\n     */\n    public PythonEmbeddingResponse generateEmbedding(String photoUrl, String videoUrl, Integer submissionId) {\n        String endpoint = \"/api/v1/embeddings/generate\";\n\n        logger.info(\"Calling Python backend: POST {} for submissionId={}\", endpoint, submissionId);\n\n        try {\n            PythonEmbeddingRequest request = new PythonEmbeddingRequest(photoUrl, videoUrl, submissionId);\n\n            ResponseEntity<PythonEmbeddingResponse> response = restTemplate.postForEntity(\n                    endpoint,\n                    request,\n                    PythonEmbeddingResponse.class);\n\n            PythonEmbeddingResponse body = response.getBody();\n            if (body != null && body.getStatus() == 200) {\n                logger.info(\"Embedding generated successfully: quality={}, framesWithFace={}/{}\",\n                        body.getData().getQuality(),\n                        body.getData().getFramesWithFace(),\n                        body.getData().getTotalFrames());\n                return body;\n            } else {\n                logger.error(\"Failed to generate embedding: status={}, message={}\",\n                        body != null ? body.getStatus() : \"null\",\n                        body != null ? body.getMessage() : \"null\");\n                throw new BadRequestException(\n                        body != null ? body.getMessage() : \"Failed to generate embedding\",\n                        ErrorCode.EMBEDDING_GENERATION_FAILED);\n            }\n\n        } catch (HttpClientErrorException e) {\n            logger.error(\"Python backend error during embedding generation: {} - {}\",\n                    e.getStatusCode(), e.getResponseBodyAsString());\n\n            // Map specific Python error codes\n            String responseBody = e.getResponseBodyAsString();\n            if (responseBody.contains(\"NO_FACE_IN_PHOTO\") || responseBody.contains(\"NO_FACE_IN_VIDEO\")) {\n                throw new BadRequestException(\n                        \"No face detected in provided media\",\n                        ErrorCode.NO_FACE_DETECTED);\n            } else if (responseBody.contains(\"FACE_MISMATCH\")) {\n                throw new BadRequestException(\n                        \"Face in photo does not match face in video\",\n                        ErrorCode.FACE_MISMATCH);\n            } else if (responseBody.contains(\"LOW_QUALITY_FACE\")) {\n                throw new BadRequestException(\n                        \"Face quality is too low\",\n                        ErrorCode.LOW_QUALITY_FACE);\n            } else {\n                throw new BadRequestException(\n                        \"Failed to generate embedding: \" + e.getMessage(),\n                        ErrorCode.EMBEDDING_GENERATION_FAILED);\n            }\n\n        } catch (Exception e) {\n            logger.error(\"Error generating embedding: {}\", e.getMessage());\n            throw new RuntimeException(\"Failed to generate embedding: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Generate face embedding from photo file (for bulk upload)\n     * POST /api/v1/embeddings/generate\n     *\n     * @param photoPath    Path to photo file\n     * @param submissionId Student user ID (for logging)\n     * @return Embedding response with 512-dim vector + quality score\n     * @throws BadRequestException if face not detected or quality too low\n     */\n    public PythonEmbeddingResponse generateEmbedding(Path photoPath, Integer submissionId) {\n        String endpoint = \"/api/v1/embeddings/generate\";\n\n        logger.info(\"Generating embedding for submissionId={}, photo={}\", submissionId, photoPath);\n\n        // Build multipart/form-data request\n        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();\n        body.add(\"photo\", new FileSystemResource(photoPath.toFile()));\n        body.add(\"submissionId\", submissionId);\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n\n        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);\n\n        try {\n            ResponseEntity<PythonEmbeddingResponse> response = restTemplate.exchange(\n                endpoint,\n                HttpMethod.POST,\n                requestEntity,\n                PythonEmbeddingResponse.class\n            );\n\n            PythonEmbeddingResponse pythonResp = response.getBody();\n\n            if (pythonResp != null && pythonResp.getStatus() == 200) {\n                logger.info(\"Embedding generated successfully for submissionId={}, quality={}\",\n                    submissionId,\n                    pythonResp.getData() != null ? pythonResp.getData().getQuality() : \"N/A\"\n                );\n                return pythonResp;\n            } else {\n                String errorMsg = pythonResp != null ? pythonResp.getMessage() : \"Unknown error\";\n                throw new BadRequestException(\n                    \"Embedding generation failed: \" + errorMsg,\n                    ErrorCode.EMBEDDING_GENERATION_FAILED\n                );\n            }\n\n        } catch (HttpClientErrorException e) {\n            // 400 errors: face not detected, low quality, invalid format\n            logger.warn(\"Photo validation failed for submissionId={}: {}\", submissionId, e.getResponseBodyAsString());\n\n            throw new BadRequestException(\n                \"Photo validation failed: \" + extractPythonErrorMessage(e.getResponseBodyAsString()),\n                ErrorCode.INVALID_FACE_PHOTO\n            );\n\n        } catch (HttpServerErrorException e) {\n            // 500 errors from Python backend\n            logger.error(\"Python backend error for submissionId={}: {}\", submissionId, e.getMessage());\n            throw new RuntimeException(\"Python backend error: \" + e.getMessage());\n\n        } catch (ResourceAccessException e) {\n            // Network/timeout errors\n            logger.error(\"Python backend unavailable for submissionId={}: {}\", submissionId, e.getMessage());\n            throw new RuntimeException(\"Python backend unavailable: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Check Python backend health\n     * GET /api/v1/health\n     *\n     * @return true if healthy, false otherwise\n     */\n    public boolean checkHealth() {\n        String endpoint = \"/api/v1/health\";\n\n        try {\n            ResponseEntity<String> response = restTemplate.getForEntity(endpoint, String.class);\n            return response.getStatusCode().is2xxSuccessful();\n        } catch (Exception e) {\n            logger.error(\"Python backend health check failed: {}\", e.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Extract clean error message from Python backend JSON response\n     *\n     * @param responseBody JSON response body from Python\n     * @return Extracted error message or default message\n     */\n    private String extractPythonErrorMessage(String responseBody) {\n        try {\n            // Parse JSON response to extract \"message\" field\n            // Looking for: {\"detail\":{\"status\":500,\"message\":\"Error here\",\"code\":\"ERROR_CODE\"}}\n            if (responseBody.contains(\"\\\"message\\\":\\\"\")) {\n                int start = responseBody.indexOf(\"\\\"message\\\":\\\"\") + 11;\n                int end = responseBody.indexOf(\"\\\"\", start);\n                if (start > 0 && end > start) {\n                    return responseBody.substring(start, end);\n                }\n            }\n        } catch (Exception e) {\n            logger.warn(\"Failed to parse Python error message: {}\", e.getMessage());\n        }\n        return \"Failed to communicate with face recognition service\";\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\RoleService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/RoleService.java",
      "filename": "RoleService.java",
      "size_bytes": 5707,
      "lines": 124,
      "last_modified": "2025-10-29T20:56:54.622182",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.dto.mapper.RoleMapper;\nimport com.fuacs.backend.dto.request.RoleCreateRequest;\nimport com.fuacs.backend.dto.request.RoleSearchRequest;\nimport com.fuacs.backend.dto.request.RoleUpdateRequest;\nimport com.fuacs.backend.dto.response.RoleDTO;\nimport com.fuacs.backend.entity.Permission;\nimport com.fuacs.backend.entity.Role;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.PermissionRepository;\nimport com.fuacs.backend.repository.RoleRepository;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n@Service\npublic class RoleService {\n\n    private final RoleRepository roleRepository;\n    private final PermissionRepository permissionRepository;\n    private final RoleMapper roleMapper;\n\n    public RoleService(RoleRepository roleRepository,\n                       PermissionRepository permissionRepository,\n                       RoleMapper roleMapper) {\n        this.roleRepository = roleRepository;\n        this.permissionRepository = permissionRepository;\n        this.roleMapper = roleMapper;\n    }\n\n    @Transactional(readOnly = true)\n    public List<RoleDTO> findAll(RoleSearchRequest request) {\n        org.springframework.data.domain.Sort.Direction direction =\n                \"desc\".equalsIgnoreCase(request.getSort()) ? org.springframework.data.domain.Sort.Direction.DESC : org.springframework.data.domain.Sort.Direction.ASC;\n        String sortBy = (request.getSortBy() == null || request.getSortBy().isBlank()) ? \"name\" : request.getSortBy();\n        org.springframework.data.domain.Pageable pageable = org.springframework.data.domain.PageRequest.of(\n                request.getPage(),\n                request.getPageSize(),\n                org.springframework.data.domain.Sort.by(direction, sortBy)\n        );\n\n        return roleRepository\n                .searchRoles(request.getSearch(), request.getActive(), request.getExclude(), pageable)\n                .stream()\n                .map(roleMapper::toDTO)\n                .collect(Collectors.toList());\n    }\n\n    public Long countAll(RoleSearchRequest request) {\n        return roleRepository.countAllRoles(request.getSearch(), request.getActive(), request.getExclude());\n    }\n\n    @Transactional\n    public RoleDTO create(RoleCreateRequest request) {\n        if (roleRepository.existsByName(request.getName()))\n            throw new BadRequestException(\"Role name already exists: \" + request.getName(), ErrorCode.ROLE_NAME_EXISTS);\n\n        Role role = roleMapper.toEntity(request);\n        role.setActive(true);\n\n        //TODO: check assign restricted permission\n        Set<Permission> permissions = fetchPermissions(request.getPermissionIds());\n        role.setPermissions(permissions);\n\n        Role savedRole = roleRepository.save(role);\n        return roleMapper.toDTO(savedRole);\n    }\n\n    @Transactional(readOnly = true)\n    public RoleDTO findById(Short id) {\n        return roleRepository.findById(id)\n                .map(roleMapper::toDTO)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Role not found: \" + id, ErrorCode.ROLE_NOT_FOUND));\n    }\n\n    @Transactional\n    public RoleDTO update(Short id, RoleUpdateRequest request) {\n        Role existingRole = roleRepository.findUpdatableRoleById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Role not found or role not allowed to update: \" + id, ErrorCode.ROLE_NOT_FOUND));\n        if (!existingRole.getName().equals(request.getName())\n                && roleRepository.existsByName(request.getName()))\n            throw new BadRequestException(\"Role name already exists: \" + request.getName(), ErrorCode.ROLE_NAME_EXISTS);\n        existingRole.setName(request.getName());\n        existingRole.setActive(request.getActive());\n        //TODO: check assign restricted permission\n        Set<Permission> permissions = fetchPermissions(request.getPermissionIds());\n        existingRole.setPermissions(permissions);\n\n        return roleMapper.toDTO(roleRepository.save(existingRole));\n    }\n\n    @Transactional\n    public void delete(Short id) {\n        if (!roleRepository.existsById(id)) {\n            throw new ResourceNotFoundException(\"Role not found: \" + id, ErrorCode.ROLE_NOT_FOUND);\n        }\n        try {\n            roleRepository.deleteById(id);\n        } catch (DataIntegrityViolationException e) {\n            // This exception is thrown when a foreign key constraint is violated.\n            throw new BadRequestException(\"Cannot delete role. It is currently in use by other records (e.g., users).\", ErrorCode.ROLE_CONSTRAINT);\n        }\n    }\n\n    private Set<Permission> fetchPermissions(Set<Short> permissionIds) {\n        if (permissionIds == null || permissionIds.isEmpty()) {\n            return new java.util.HashSet<>();  // Return mutable empty set instead of immutable Set.of()\n        }\n        List<Permission> foundPermissions = permissionRepository.findAllById(permissionIds);\n\n        if (foundPermissions.size() != permissionIds.size()) {\n            // Optional: throw a specific exception if a Permission is not found\n            // For simplicity, we just return the ones we found here.\n        }\n        return new java.util.HashSet<>(foundPermissions);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\RoomService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/RoomService.java",
      "filename": "RoomService.java",
      "size_bytes": 20516,
      "lines": 427,
      "last_modified": "2025-11-21T19:16:59.618157",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.dto.mapper.RoomMapper;\nimport com.fuacs.backend.dto.mapper.SlotMapper;\nimport com.fuacs.backend.dto.request.RoomCreateRequest;\nimport com.fuacs.backend.dto.request.RoomCsvRow;\nimport com.fuacs.backend.dto.request.RoomSearchRequest;\nimport com.fuacs.backend.dto.request.RoomUpdateRequest;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.dto.response.RoomDTO;\nimport com.fuacs.backend.dto.response.SlotDTO;\nimport com.fuacs.backend.entity.Room;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.RoomRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n/**\n * Service xử lý business logic cho Room (phòng học/thi).\n * Cung cấp các chức năng:\n * - Search thông thường: Lấy danh sách phòng với filters như keyword, isActive, hasCamera\n * - Search theo staff: Lấy phòng mà staff có slot, kèm usage statistics và upcoming slots\n * - CRUD: Tạo, đọc, cập nhật, xóa phòng với validation đầy đủ\n * - CSV Import: Nhập phòng hàng loạt với chiến lược thành công một phần (các dòng hợp lệ được xử lý, dòng lỗi được báo cáo)\n *\n * Tất cả thao tác thay đổi dữ liệu đều chạy trong transaction để đảm bảo tính nhất quán.\n *\n * @see Room\n * @see RoomDTO\n * @see RoomRepository\n */\n@Service\npublic class RoomService {\n\n    private static final Logger logger = LoggerFactory.getLogger(RoomService.class);\n\n    private final RoomRepository roomRepository;\n    private final RoomMapper roomMapper;\n    private final SlotRepository slotRepository;\n    private final SlotMapper slotMapper;\n    private final CsvParserService csvParserService;\n\n    public RoomService(RoomRepository roomRepository,\n            RoomMapper roomMapper,\n            SlotRepository slotRepository,\n            SlotMapper slotMapper,\n            CsvParserService csvParserService) {\n        this.roomRepository = roomRepository;\n        this.roomMapper = roomMapper;\n        this.slotRepository = slotRepository;\n        this.slotMapper = slotMapper;\n        this.csvParserService = csvParserService;\n    }\n\n    /**\n     * Tìm kiếm phòng với filters (keyword, isActive, hasCamera, pagination, sorting).\n     *\n     * @param request Chứa filters và pagination\n     * @return Danh sách RoomDTO với camera statistics\n     */\n    public List<RoomDTO> search(RoomSearchRequest request) {\n        // Gọi repository search - hỗ trợ filters: keyword (name/location), isActive, hasCamera, sorting\n        // Ví dụ: keyword=\"30\", isActive=true, hasCamera=true → 301, 302, 303\n        return new ArrayList<>(roomRepository.search(request));\n    }\n\n    /**\n     * Đếm tổng số phòng thỏa filters (dùng tính total pages cho pagination).\n     *\n     * @param request Chứa filters (không bao gồm pagination)\n     * @return Tổng số phòng\n     */\n    public Long count(RoomSearchRequest request) {\n        // Ví dụ: 45 phòng active có camera, pageSize=10 → totalPages = 5\n        return roomRepository.count(request);\n    }\n\n    /**\n     * Tìm kiếm phòng theo staff ID (chỉ phòng mà staff có slot).\n     * Kết quả kèm usageCount, lastUsedAt, và 3 upcomingSlots.\n     *\n     * @param staffId ID của staff (Lecturer/Supervisor)\n     * @param request Chứa filters: search, isActive, semesterId, startDate, endDate, pagination\n     * @return Danh sách RoomDTO với usage statistics\n     */\n    public List<RoomDTO> searchByStaffId(Integer staffId, RoomSearchRequest request) {\n        List<RoomDTO> rooms;\n        LocalDate start = null, end = null;\n\n        // Parse startDate: \"YYYY-MM-DD\" → LocalDate (vd: \"2024-12-01\" → LocalDate(2024, 12, 1))\n        if (request.getStartDate() != null && !request.getStartDate().isBlank()) {\n            try { start = LocalDate.parse(request.getStartDate()); } catch (Exception e) {\n                throw new com.fuacs.backend.exception.BadRequestException(\"Invalid date format. Expected YYYY-MM-DD\", com.fuacs.backend.constant.ErrorCode.INVALID_DATE_FORMAT);\n            }\n        }\n\n        // Parse endDate: \"YYYY-MM-DD\" → LocalDate (vd: \"2024-12-31\" → LocalDate(2024, 12, 31))\n        if (request.getEndDate() != null && !request.getEndDate().isBlank()) {\n            try { end = LocalDate.parse(request.getEndDate()); } catch (Exception e) {\n                throw new com.fuacs.backend.exception.BadRequestException(\"Invalid date format. Expected YYYY-MM-DD\", com.fuacs.backend.constant.ErrorCode.INVALID_DATE_FORMAT);\n            }\n        }\n\n        // Gọi repository method tương ứng:\n        // - Có date range (01/12-31/12) → searchByStaffIdWithDateRange (chỉ slot trong tháng 12)\n        // - Không có date range → searchByStaffId (tất cả slot từ trước đến nay)\n        if (start != null || end != null) {\n            rooms = new ArrayList<>(roomRepository.searchByStaffIdWithDateRange(staffId, request, start, end));\n        } else {\n            rooms = new ArrayList<>(roomRepository.searchByStaffId(staffId, request));\n        }\n\n        // Lấy 3 slot sắp tới cho mỗi phòng (startTime > now)\n        // Map<roomId, List<SlotDTO>> để gán vào RoomDTO.upcomingSlots\n        LocalDateTime now = LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        Map<Short, List<SlotDTO>> upcomingByRoom = rooms.stream()\n                .collect(Collectors.toMap(RoomDTO::getId, r -> {\n                    // Lấy 3 slot gần nhất (page 0, size 3) - vd: 301 có 10 slot → chỉ lấy 3 đầu\n                    var page = org.springframework.data.domain.PageRequest.of(0, 3);\n                    var slots = slotRepository.findByStaff_IdAndRoom_IdAndStartTimeAfterOrderByStartTimeAsc(\n                            staffId, r.getId(), now, page);\n                    return slots.stream().map(slotMapper::toDTO).collect(Collectors.toList());\n                }));\n\n        // Gán upcomingSlots vào từng RoomDTO (vd: 301 → [21/12, 23/12, 25/12], Lab-A1 → [])\n        rooms.forEach(r -> r.setUpcomingSlots(upcomingByRoom.getOrDefault(r.getId(), List.of())));\n        return rooms;\n    }\n\n    /**\n     * Đếm tổng số phòng thỏa staff-scoped filters (dùng tính total pages).\n     *\n     * @param staffId ID của staff\n     * @param request Chứa filters: search, isActive, semesterId, startDate, endDate\n     * @return Tổng số phòng mà staff có slot\n     */\n    public Long countByStaffId(Integer staffId, RoomSearchRequest request) {\n        LocalDate start = null, end = null;\n\n        // Parse dates: \"YYYY-MM-DD\" → LocalDate\n        if (request.getStartDate() != null && !request.getStartDate().isBlank()) {\n            try { start = LocalDate.parse(request.getStartDate()); } catch (Exception e) {\n                throw new com.fuacs.backend.exception.BadRequestException(\"Invalid date format. Expected YYYY-MM-DD\", com.fuacs.backend.constant.ErrorCode.INVALID_DATE_FORMAT);\n            }\n        }\n        if (request.getEndDate() != null && !request.getEndDate().isBlank()) {\n            try { end = LocalDate.parse(request.getEndDate()); } catch (Exception e) {\n                throw new com.fuacs.backend.exception.BadRequestException(\"Invalid date format. Expected YYYY-MM-DD\", com.fuacs.backend.constant.ErrorCode.INVALID_DATE_FORMAT);\n            }\n        }\n\n        // Gọi method tương ứng: có/không có date range\n        if (start != null || end != null) {\n            return roomRepository.countByStaffIdWithDateRange(staffId, request, start, end);\n        }\n        return roomRepository.countByStaffId(staffId, request);\n    }\n\n    /**\n     * Tìm phòng theo ID kèm camera statistics (totalCameras, activeCameras).\n     *\n     * @param id ID phòng\n     * @return RoomDTO với camera stats\n     * @throws ResourceNotFoundException nếu không tìm thấy\n     */\n    @Transactional(readOnly = true)\n    public RoomDTO findById(Short id) {\n        Room room = roomRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Room not found: \" + id, ErrorCode.ROOM_NOT_FOUND));\n\n        // Map entity → DTO và set camera statistics\n        // Vd: 301 có 3 camera (2 active, 1 inactive) → totalCameras=3, activeCameras=2\n        RoomDTO roomDTO = roomMapper.toDTO(room);\n        roomDTO.setTotalCameras(Math.toIntExact(roomRepository.countAllCamerasByRoomId(id)));\n        roomDTO.setActiveCameras(Math.toIntExact(roomRepository.countActiveCamerasByRoomId(id)));\n        return roomDTO;\n    }\n\n    /**\n     * Tạo phòng mới (kiểm tra tên phải unique).\n     *\n     * @param request Chứa name, location\n     * @return RoomDTO mới với ID\n     * @throws ResourceExistsException nếu tên đã tồn tại\n     */\n    @Transactional\n    public RoomDTO create(RoomCreateRequest request) {\n        // Kiểm tra tên unique - vd: đã có \"301\" → không cho tạo \"301\" nữa\n        if (roomRepository.existsByName(request.getName())) {\n            throw new ResourceExistsException(\"Room name exists: \" + request.getName(), ErrorCode.ROOM_NAME_EXISTS);\n        }\n        Room room = roomMapper.toEntity(request);\n        return roomMapper.toDTO(roomRepository.save(room));\n    }\n\n    /**\n     * Cập nhật phòng (kiểm tra tên unique khi đổi, kiểm tra camera/slot khi tắt).\n     *\n     * @param id ID phòng\n     * @param request Chứa name, location, isActive\n     * @return RoomDTO đã cập nhật\n     * @throws ResourceNotFoundException nếu không tìm thấy\n     * @throws ResourceExistsException nếu tên mới trùng phòng khác\n     * @throws OperationNotAllowedException nếu tắt phòng có camera/slot active\n     */\n    @Transactional\n    public RoomDTO update(Short id, RoomUpdateRequest request) {\n        Room existing = roomRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Room not found: \" + id, ErrorCode.ROOM_NOT_FOUND));\n\n        // Nếu đổi tên → kiểm tra tên mới unique (vd: 301→302, phải check 302 chưa tồn tại)\n        if (!existing.getName().equals(request.getName())) {\n            if (roomRepository.existsByNameAndIdNot(request.getName(), id)) {\n                throw new ResourceExistsException(\"Room name already exists: \" + request.getName(),\n                        ErrorCode.ROOM_NAME_EXISTS);\n            }\n        }\n\n        // Nếu tắt phòng (active: true→false) → phải không có camera/slot active\n        if (existing.getActive() && !request.getActive()) {\n            // Check camera active - vd: 301 có 2 camera active → không cho tắt\n            long activeCameras = roomRepository.countActiveCamerasByRoomId(id);\n            if (activeCameras > 0) {\n                throw new OperationNotAllowedException(\n                        \"Cannot deactivate room with \" + activeCameras + \" active cameras. Deactivate cameras first.\",\n                        ErrorCode.ROOM_HAS_ACTIVE_CAMERAS);\n            }\n\n            // Check slot sắp diễn ra (startTime >= now) - vd: 301 có slot 21/12, 23/12 → không cho tắt\n            long activeSlots = roomRepository.countActiveSlotsByRoomId(id, LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\")));\n            if (activeSlots > 0) {\n                throw new OperationNotAllowedException(\"Cannot deactivate room with ongoing or future slots\",\n                        ErrorCode.ROOM_HAS_ACTIVE_SLOTS);\n            }\n        }\n\n        roomMapper.updateRoomFromRequest(request, existing);\n        return roomMapper.toDTO(roomRepository.save(existing));\n    }\n\n    /**\n     * Xóa phòng (hard delete - kiểm tra không có camera, slot tương lai, FK constraints).\n     *\n     * @param id ID phòng\n     * @throws ResourceNotFoundException nếu không tìm thấy\n     * @throws OperationNotAllowedException nếu có camera, slot tương lai, hoặc FK violation\n     */\n    @Transactional\n    public void delete(Short id) {\n        if (!roomRepository.existsById(id)) {\n            throw new ResourceNotFoundException(\"Room not found: \" + id, ErrorCode.ROOM_NOT_FOUND);\n        }\n\n        // Không cho xóa nếu có camera (kể cả inactive) - vd: 301 có 3 camera → phải xóa camera trước\n        long camerasCount = roomRepository.countAllCamerasByRoomId(id);\n        if (camerasCount > 0) {\n            throw new OperationNotAllowedException(\"Cannot delete room with cameras. Remove cameras first\",\n                    ErrorCode.ROOM_HAS_CAMERAS);\n        }\n\n        // Không cho xóa nếu có slot tương lai (startTime > now) - vd: 301 có slot 21/12 → không cho xóa\n        long futureSlots = roomRepository.countFutureSlotsByRoomId(id, LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\")));\n        if (futureSlots > 0) {\n            throw new OperationNotAllowedException(\"Cannot delete room with scheduled slots\",\n                    ErrorCode.ROOM_HAS_SCHEDULED_SLOTS);\n        }\n\n        // Xóa - nếu bị FK constraint (vd: 302 có attendance_records cũ) → throw exception\n        try {\n            roomRepository.deleteById(id);\n        } catch (DataIntegrityViolationException e) {\n            throw new OperationNotAllowedException(\"Cannot delete room. It is currently in use by other records.\",\n                    ErrorCode.FOREIGN_KEY_CONSTRAINT_VIOLATION);\n        }\n    }\n\n    /**\n     * Import phòng từ CSV hàng loạt (partial success strategy).\n     * Modes: ADD_ONLY (bỏ qua trùng) | ADD_AND_UPDATE (upsert).\n     *\n     * @param file CSV file (format: name, location)\n     * @param modeStr \"add_only\" hoặc \"add_and_update\"\n     * @return ImportResultDTO với successCount, failureCount, errors\n     * @throws BadRequestException nếu mode invalid hoặc file lỗi\n     */\n    public ImportResultDTO importFromCsv(MultipartFile file, String modeStr) {\n        logger.info(\"Starting room CSV import with mode: {}\", modeStr);\n\n        // Parse mode string → ImportMode enum\n        ImportMode mode;\n        try {\n            mode = ImportMode.fromString(modeStr);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), ErrorCode.INVALID_IMPORT_MODE);\n        }\n\n        // Parse CSV file → List<RoomCsvRow>\n        List<RoomCsvRow> rows;\n        try {\n            rows = csvParserService.parseRoomCsv(file);\n        } catch (IOException e) {\n            throw new BadRequestException(\"Failed to process CSV file: \" + e.getMessage(), ErrorCode.FILE_PROCESSING_ERROR);\n        }\n        logger.info(\"Parsed {} rows from CSV\", rows.size());\n\n        // Deduplicate theo name (giữ dòng đầu, bỏ dòng sau) - vd: dòng 5,12,45 cùng \"301\" → giữ dòng 5\n        Map<String, RoomCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (RoomCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getName(), row);\n        }\n        logger.info(\"After deduplication: {} unique rooms\", uniqueRows.size());\n\n        // Xử lý từng dòng riêng biệt (partial success: lỗi dòng này không ảnh hưởng dòng khác)\n        // Vd: 100 dòng → 80 thành công, 20 lỗi → result: successCount=80, errors=[20 lỗi chi tiết]\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (RoomCsvRow row : uniqueRows.values()) {\n            try {\n                // processOneRoomRow chạy trong transaction riêng (REQUIRES_NEW)\n                processOneRoomRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                logger.warn(\"Failed to process row {}: {}\", row.getRowNumber(), e.getMessage());\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()\n                ));\n            }\n        }\n\n        logger.info(\"Room import completed: {} successful, {} failed\", successCount, errors.size());\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Xử lý 1 dòng CSV trong transaction riêng (REQUIRES_NEW).\n     * Logic: ADD_ONLY (skip existing) | ADD_AND_UPDATE (upsert).\n     *\n     * @param row RoomCsvRow (name, location)\n     * @param mode ADD_ONLY hoặc ADD_AND_UPDATE\n     * @throws BadRequestException nếu row invalid\n     * @throws ResourceExistsException nếu ADD_ONLY và tên đã tồn tại\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneRoomRow(RoomCsvRow row, ImportMode mode) {\n        // Validate row - vd: name rỗng → throw BadRequestException\n        if (!row.isValid()) {\n            throw new BadRequestException(\"Invalid row data\", ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Check tên phòng đã tồn tại chưa\n        Room existing = roomRepository.findByName(row.getName());\n\n        if (existing != null) {\n            // Đã tồn tại → kiểm tra mode\n            if (mode == ImportMode.ADD_ONLY) {\n                // ADD_ONLY: skip existing - vd: 302 đã có → throw để bỏ qua dòng này\n                throw new ResourceExistsException(\n                        \"Room name already exists: \" + row.getName(),\n                        ErrorCode.ROOM_NAME_EXISTS\n                );\n            }\n\n            // ADD_AND_UPDATE: update existing - vd: 302 có location=\"Tầng 3\" → update thành giá trị mới\n            Room room = existing;\n            room.setLocation(row.getLocation());\n            if (row.getIsActive() != null) {\n                room.setActive(row.getIsActive());\n            }\n            room.setUpdatedAt(Instant.now());\n            roomRepository.save(room);\n        } else {\n            // Chưa tồn tại → tạo mới - vd: 305 chưa có → tạo mới\n            Room room = new Room();\n            room.setName(row.getName());\n            room.setLocation(row.getLocation());\n            // If status provided → use it; else default to true on create\n            room.setActive(row.getIsActive() != null ? row.getIsActive() : true);\n            room.setCreatedAt(Instant.now());\n            roomRepository.save(room);\n        }\n    }\n\n    /**\n     * Trích xuất error code từ exception (dùng cho ImportErrorDTO).\n     *\n     * @param e Exception\n     * @return Error code string (vd: \"ROOM_NAME_EXISTS\", \"UNKNOWN_ERROR\")\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\SemesterService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/SemesterService.java",
      "filename": "SemesterService.java",
      "size_bytes": 14692,
      "lines": 324,
      "last_modified": "2025-11-21T21:39:22.529044",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.dto.mapper.SemesterMapper;\nimport com.fuacs.backend.dto.request.SemesterCreateRequest;\nimport com.fuacs.backend.dto.request.SemesterCsvRow;\nimport com.fuacs.backend.dto.request.SemesterSearchRequest;\nimport com.fuacs.backend.dto.request.SemesterUpdateRequest;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.entity.Semester;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.InvalidDateException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.SemesterRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Service\npublic class SemesterService {\n\n    private static final Logger logger = LoggerFactory.getLogger(SemesterService.class);\n\n    private final SemesterRepository semesterRepository;\n    private final SemesterMapper semesterMapper;\n    private final CsvParserService csvParserService;\n\n    public SemesterService(SemesterRepository semesterRepository,\n            SemesterMapper semesterMapper,\n            CsvParserService csvParserService) {\n        this.semesterRepository = semesterRepository;\n        this.semesterMapper = semesterMapper;\n        this.csvParserService = csvParserService;\n    }\n\n    public List<SemesterDTO> search(SemesterSearchRequest request) {\n        return new ArrayList<>(semesterRepository.search(request));\n    }\n\n    public Long count(SemesterSearchRequest request) {\n        return semesterRepository.count(request);\n    }\n\n    @Transactional(readOnly = true)\n    public SemesterDTO findById(Short id) {\n        Semester semester = semesterRepository.findById(id)\n                .orElseThrow(\n                        () -> new ResourceNotFoundException(\"Semester not found: \" + id, ErrorCode.SEMESTER_NOT_FOUND));\n        SemesterDTO semesterDTO = semesterMapper.toDTO(semester);\n        semesterDTO.setTotalClass((short) semester.getAcademicClasses().size());\n        return semesterDTO;\n    }\n\n    @Transactional\n    public SemesterDTO create(SemesterCreateRequest request) {\n        if (!request.getStartDate().isBefore(request.getEndDate())) {\n            throw new InvalidDateException(\"Start date must be before end date\", ErrorCode.SEMESTER_INVALID_DATE_RANGE);\n        }\n        if (semesterRepository.existsByCode(request.getCode())) {\n            throw new ResourceExistsException(\"Semester code exists: \" + request.getCode(),\n                    ErrorCode.SEMESTER_CODE_EXISTS);\n        }\n        if (semesterRepository.existsByName(request.getName())) {\n            throw new ResourceExistsException(\"Semester name exists: \" + request.getName(),\n                    ErrorCode.SEMESTER_NAME_EXISTS);\n        }\n        if (semesterRepository.existsByDateRangeOverlap(request.getStartDate(), request.getEndDate())) {\n            throw new ResourceExistsException(\"A semester with overlapping date range already exists\",\n                    ErrorCode.SEMESTER_DATE_RANGE_EXISTS);\n        }\n        Semester semester = semesterMapper.toEntity(request);\n        Semester saved = semesterRepository.save(semester);\n        SemesterDTO dto = semesterMapper.toDTO(saved);\n        dto.setTotalClass((short) 0); // New semester has no classes yet\n        return dto;\n    }\n\n    @Transactional\n    public SemesterDTO update(Short id, SemesterUpdateRequest request) {\n        Semester existing = semesterRepository.findById(id).orElseThrow(\n                () -> new ResourceNotFoundException(\"Semester not found: \" + id, ErrorCode.SEMESTER_NOT_FOUND));\n        if (!request.getStartDate().isBefore(request.getEndDate())) {\n            throw new InvalidDateException(\"Start date must be before end date\", ErrorCode.SEMESTER_INVALID_DATE_RANGE);\n        }\n        if (!existing.getCode().equals(request.getCode())) {\n            if (semesterRepository.existsByCodeAndIdNot(request.getCode(), id)) {\n                throw new ResourceExistsException(\"Semester code exists: \" + request.getCode(),\n                        ErrorCode.SEMESTER_CODE_EXISTS);\n            }\n        }\n        if (!existing.getName().equals(request.getName())) {\n            if (semesterRepository.existsByNameAndIdNot(request.getName(), id)) {\n                throw new ResourceExistsException(\"Semester name already exists: \" + request.getName(),\n                        ErrorCode.SEMESTER_NAME_EXISTS);\n            }\n        }\n        if (!existing.getStartDate().equals(request.getStartDate())\n                || !existing.getEndDate().equals(request.getEndDate())) {\n            if (semesterRepository.existsByDateRangeOverlapAndIdNot(request.getStartDate(), request.getEndDate(),\n                    id)) {\n                throw new ResourceExistsException(\"A semester with overlapping date range already exists\",\n                        ErrorCode.SEMESTER_DATE_RANGE_EXISTS);\n            }\n        }\n\n        LocalDate today = LocalDate.now();\n        boolean isOngoing = !today.isBefore(existing.getStartDate()) && !today.isAfter(existing.getEndDate());\n        if (isOngoing) {\n            // Kỳ học đang diễn ra không cho update start/end date\n            if (!existing.getStartDate().equals(request.getStartDate()) ||\n                    !existing.getEndDate().equals(request.getEndDate()) ||\n                    !existing.getActive().equals(request.getActive())) {\n                throw new OperationNotAllowedException(\n                        \"Cannot modify dates or active status of an ongoing semester. Only name and code can be updated.\",\n                        ErrorCode.SEMESTER_ONGOING_CANNOT_BE_MODIFIED);\n            }\n        }\n        semesterMapper.updateSemesterFromRequest(request, existing);\n        Semester saved = semesterRepository.save(existing);\n        SemesterDTO dto = semesterMapper.toDTO(saved);\n        // dto.setTotalClass((short) saved.getAcademicClasses().size());\n        return dto;\n    }\n\n    @Transactional\n    public void delete(Short id) {\n        if (!semesterRepository.existsById(id)) {\n            throw new ResourceNotFoundException(\"Semester not found: \" + id, ErrorCode.SEMESTER_NOT_FOUND);\n        }\n        long totalClasses = semesterRepository.countClassesBySemesterId(id);\n        if (totalClasses > 0) {\n            throw new OperationNotAllowedException(\n                    \"Cannot delete semester with \" + totalClasses + \" classes. Delete all classes first.\",\n                    ErrorCode.SEMESTER_HAS_CLASSES);\n        }\n        try {\n            semesterRepository.deleteById(id);\n        } catch (DataIntegrityViolationException e) {\n            throw new OperationNotAllowedException(\"Cannot delete semester. It is currently in use by other records.\",\n                    ErrorCode.FOREIGN_KEY_CONSTRAINT_VIOLATION);\n        }\n    }\n\n    /**\n     * Import semesters from CSV file with partial success pattern.\n     * Supports AddOnly and AddAndUpdate modes.\n     *\n     * Note: No @Transactional here to avoid rollback-only conflict.\n     * Each row is processed in its own REQUIRES_NEW transaction.\n     *\n     * @param file    CSV file containing semesters\n     * @param modeStr Import mode (\"AddOnly\" or \"AddAndUpdate\")\n     * @return ImportResultDTO with success/failure counts and errors\n     */\n    public ImportResultDTO importFromCsv(MultipartFile file, String modeStr) {\n        logger.info(\"Starting semester CSV import with mode: {}\", modeStr);\n\n        // Parse mode\n        ImportMode mode;\n        try {\n            mode = ImportMode.fromString(modeStr);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), ErrorCode.INVALID_IMPORT_MODE);\n        }\n\n        // Parse CSV\n        List<SemesterCsvRow> rows;\n        try {\n            rows = csvParserService.parseSemesterCsv(file);\n        } catch (IOException e) {\n            throw new BadRequestException(\"Failed to process CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        logger.info(\"Parsed {} rows from CSV\", rows.size());\n\n        // Deduplicate within file by code (business key)\n        Map<String, SemesterCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (SemesterCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getCode(), row);\n        }\n\n        logger.info(\"After deduplication: {} unique semesters\", uniqueRows.size());\n\n        // Process rows with partial success\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (SemesterCsvRow row : uniqueRows.values()) {\n            try {\n                processOneSemesterRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                logger.warn(\"Failed to process row {}: {}\", row.getRowNumber(), e.getMessage());\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()));\n            }\n        }\n\n        logger.info(\"Semester import completed: {} successful, {} failed\", successCount, errors.size());\n\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Process a single semester row in a separate transaction.\n     * This ensures one row's failure doesn't affect others (partial success).\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneSemesterRow(SemesterCsvRow row, ImportMode mode) {\n        // Validate row\n        if (!row.isValid()) {\n            throw new BadRequestException(\"Invalid row data\", ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Validate date range\n        LocalDate startDate = row.getStartDate();\n        LocalDate endDate = row.getEndDate();\n        if (!startDate.isBefore(endDate)) {\n            throw new InvalidDateException(\n                    \"Start date must be before end date\",\n                    ErrorCode.SEMESTER_INVALID_DATE_RANGE);\n        }\n\n        // Check if semester exists\n        Semester existing = semesterRepository.findByCode(row.getCode());\n\n        if (existing != null) {\n            if (mode == ImportMode.ADD_ONLY) {\n                throw new ResourceExistsException(\n                        \"Semester code already exists: \" + row.getCode(),\n                        ErrorCode.SEMESTER_CODE_EXISTS);\n            }\n\n            // AddAndUpdate mode: Update existing semester\n            Semester semester = existing;\n\n            // Check name uniqueness if changing name\n            if (!semester.getName().equals(row.getName()) && semesterRepository.existsByName(row.getName())) {\n                throw new ResourceExistsException(\n                        \"Semester name already exists: \" + row.getName(),\n                        ErrorCode.SEMESTER_NAME_EXISTS);\n            }\n\n            // Check date range overlap if changing dates\n            if ((!semester.getStartDate().equals(startDate) || !semester.getEndDate().equals(endDate))) {\n                if (semesterRepository.existsByDateRangeOverlapAndIdNot(startDate, endDate, semester.getId())) {\n                    throw new ResourceExistsException(\n                            \"A semester with overlapping date range already exists\",\n                            ErrorCode.SEMESTER_DATE_RANGE_EXISTS);\n                }\n            }\n\n            semester.setName(row.getName());\n            semester.setStartDate(startDate);\n            semester.setEndDate(endDate);\n            semester.setActive(row.getActive());\n            semester.setUpdatedAt(Instant.now());\n            semesterRepository.save(semester);\n\n        } else {\n            // Check name uniqueness for new record\n            if (semesterRepository.existsByName(row.getName())) {\n                throw new ResourceExistsException(\n                        \"Semester name already exists: \" + row.getName(),\n                        ErrorCode.SEMESTER_NAME_EXISTS);\n            }\n\n            // Check date range overlap for new record\n            if (semesterRepository.existsByDateRangeOverlap(startDate, endDate)) {\n                throw new ResourceExistsException(\n                        \"A semester with overlapping date range already exists\",\n                        ErrorCode.SEMESTER_DATE_RANGE_EXISTS);\n            }\n\n            // Create new semester\n            Semester semester = new Semester();\n            semester.setCode(row.getCode());\n            semester.setName(row.getName());\n            semester.setStartDate(startDate);\n            semester.setEndDate(endDate);\n            semester.setActive(row.getActive());\n            semester.setCreatedAt(Instant.now());\n            semesterRepository.save(semester);\n        }\n    }\n\n    /**\n     * Extract error code from exception.\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        } else if (e instanceof InvalidDateException) {\n            return ((InvalidDateException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\SlotService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/SlotService.java",
      "filename": "SlotService.java",
      "size_bytes": 106987,
      "lines": 2232,
      "last_modified": "2025-11-23T10:22:30.458874",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.constant.enums.AttendanceMethod;\nimport com.fuacs.backend.constant.enums.AttendanceStatus;\nimport com.fuacs.backend.constant.enums.Role;\nimport com.fuacs.backend.constant.enums.ScanMode;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.dto.mapper.SlotMapper;\nimport com.fuacs.backend.dto.request.ExamSlotCsvRow;\nimport com.fuacs.backend.dto.request.SlotAttendanceSubmissionRequest;\nimport com.fuacs.backend.dto.request.SlotCategoryUpdateRequest;\nimport com.fuacs.backend.dto.request.SlotCreateRequest;\nimport com.fuacs.backend.dto.request.SlotCsvRow;\nimport com.fuacs.backend.dto.request.SlotSearchRequest;\nimport com.fuacs.backend.dto.request.SlotUpdateRequest;\nimport com.fuacs.backend.dto.response.AttendanceStatsDTO;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.dto.response.SessionStatusResponse;\nimport com.fuacs.backend.dto.response.SlotAttendanceSubmissionResponse;\nimport com.fuacs.backend.dto.response.SlotDTO;\nimport com.fuacs.backend.dto.response.SlotRosterItemDTO;\nimport com.fuacs.backend.entity.AcademicClass;\nimport com.fuacs.backend.entity.AttendanceRecord;\nimport com.fuacs.backend.entity.EnrollmentId;\nimport com.fuacs.backend.entity.ExamAttendance;\nimport com.fuacs.backend.entity.ExamSlotSubject;\nimport com.fuacs.backend.entity.Semester;\nimport com.fuacs.backend.entity.Slot;\nimport com.fuacs.backend.entity.Subject;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.AttendanceRecordRepository;\nimport com.fuacs.backend.repository.ClassRepository;\nimport com.fuacs.backend.repository.EnrollmentRepository;\nimport com.fuacs.backend.repository.ExamAttendanceRepository;\nimport com.fuacs.backend.repository.ExamSlotSubjectRepository;\nimport com.fuacs.backend.repository.ExamSlotParticipantRepository;\nimport com.fuacs.backend.repository.RoomRepository;\nimport com.fuacs.backend.repository.SemesterRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport com.fuacs.backend.repository.SubjectRepository;\nimport com.fuacs.backend.repository.UserRepository;\nimport com.fuacs.backend.util.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\nimport com.fuacs.backend.realtime.SseHub;\nimport com.fuacs.backend.dto.realtime.AttendanceUpdateEvent;\n\nimport java.io.IOException;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n@Service\npublic class SlotService {\n\n    private static final Logger logger = LoggerFactory.getLogger(SlotService.class);\n\n    private final SlotRepository slotRepository;\n    private final ClassRepository classRepository;\n    private final RoomRepository roomRepository;\n    private final SemesterRepository semesterRepository;\n    private final UserRepository userRepository;\n    private final SlotMapper slotMapper;\n    private final AttendanceRecordRepository attendanceRecordRepository;\n    private final ExamAttendanceRepository examAttendanceRepository;\n    private final SlotSessionService slotSessionService;\n    private final SubjectRepository subjectRepository;\n    private final ExamSlotSubjectRepository examSlotSubjectRepository;\n    private final ExamSlotParticipantRepository examSlotParticipantRepository;\n    private final CsvParserService csvParserService;\n    private final EnrollmentRepository enrollmentRepository;\n    private final SseHub sseHub;\n\n    public SlotService(SlotRepository slotRepository,\n                       ClassRepository classRepository,\n                       RoomRepository roomRepository,\n                       SemesterRepository semesterRepository,\n                       UserRepository userRepository,\n                       SlotMapper slotMapper,\n                       AttendanceRecordRepository attendanceRecordRepository,\n                       ExamAttendanceRepository examAttendanceRepository,\n                       SlotSessionService slotSessionService,\n                       SubjectRepository subjectRepository,\n                       ExamSlotSubjectRepository examSlotSubjectRepository,\n                       ExamSlotParticipantRepository examSlotParticipantRepository,\n                       CsvParserService csvParserService,\n                       EnrollmentRepository enrollmentRepository,\n            SseHub sseHub) {\n        this.slotRepository = slotRepository;\n        this.classRepository = classRepository;\n        this.roomRepository = roomRepository;\n        this.semesterRepository = semesterRepository;\n        this.userRepository = userRepository;\n        this.slotMapper = slotMapper;\n        this.attendanceRecordRepository = attendanceRecordRepository;\n        this.examAttendanceRepository = examAttendanceRepository;\n        this.slotSessionService = slotSessionService;\n        this.subjectRepository = subjectRepository;\n        this.examSlotSubjectRepository = examSlotSubjectRepository;\n        this.examSlotParticipantRepository = examSlotParticipantRepository;\n        this.csvParserService = csvParserService;\n        this.enrollmentRepository = enrollmentRepository;\n        this.sseHub = sseHub;\n    }\n\n    @Transactional(readOnly = true)\n    public List<SlotDTO> findAll(SlotSearchRequest request) {\n        List<SlotDTO> slots = slotRepository.search(request);\n\n        // Populate attendance stats for each slot\n        slots.forEach(slot -> {\n            try {\n                if (slot.getId() != null) {\n                    AttendanceStatsDTO stats = slotRepository.getAttendanceStats(slot.getId());\n\n                    // Copy to individual fields for API response\n                    if (stats != null) {\n                        slot.setTotalStudent(stats.getTotal());\n                        slot.setTotalPresentStudent(stats.getPresent());\n                        slot.setTotalAbsentStudent(stats.getAbsent());\n                        slot.setTotalNotYetStudent(stats.getNotYet());\n                    }\n                }\n            } catch (Exception e) {\n                System.err.println(\"ERROR getting attendance stats for slot \" + slot.getId() + \": \" + e.getMessage());\n                // Continue without attendance stats for this slot\n            }\n        });\n\n        return slots;\n    }\n\n    @Transactional(readOnly = true)\n    public Long count(SlotSearchRequest request) {\n        return slotRepository.count(request);\n    }\n\n    @Transactional(readOnly = true)\n    public List<SlotDTO> searchByStaffId(Integer staffId, SlotSearchRequest request) {\n        // Set staffUserId in request to ensure consistency\n        request.setStaffUserId(staffId);\n        List<SlotDTO> slots = slotRepository.search(request);\n\n        // Populate attendance stats for each slot\n        slots.forEach(slot -> {\n            try {\n                if (slot.getId() != null) {\n                    AttendanceStatsDTO stats = slotRepository.getAttendanceStats(slot.getId());\n\n                    // Copy to individual fields for API response\n                    if (stats != null) {\n                        slot.setTotalStudent(stats.getTotal());\n                        slot.setTotalPresentStudent(stats.getPresent());\n                        slot.setTotalAbsentStudent(stats.getAbsent());\n                        slot.setTotalNotYetStudent(stats.getNotYet());\n                    }\n                }\n            } catch (Exception e) {\n                System.err.println(\"ERROR getting attendance stats for slot \" + slot.getId() + \": \" + e.getMessage());\n                // Continue without attendance stats for this slot\n            }\n        });\n\n        return slots;\n    }\n\n    @Transactional(readOnly = true)\n    public Long countByStaffId(Integer staffId, SlotSearchRequest request) {\n        // Set staffUserId in request to ensure consistency\n        request.setStaffUserId(staffId);\n        return slotRepository.count(request);\n    }\n\n    @Transactional(readOnly = true)\n    public List<SlotDTO> searchByStudentId(Integer studentId, SlotSearchRequest request) {\n        request.setStudentUserId(studentId);\n        List<SlotDTO> slots = slotRepository.searchByStudentId(request);\n\n        // Populate student-specific attendance status for each slot (optional field)\n        if (!slots.isEmpty()) {\n            populateStudentAttendanceStatuses(slots, studentId);\n        }\n\n        return slots;\n    }\n\n    /**\n     * Populate attendance status for a specific student across multiple slots.\n     * This is an optional field only populated when querying slots for a specific student.\n     * Does NOT affect other API contexts (lecturer view, admin view, etc.)\n     *\n     * @param slots List of SlotDTOs to populate\n     * @param studentId The student user ID to fetch attendance for\n     */\n    private void populateStudentAttendanceStatuses(List<SlotDTO> slots, Integer studentId) {\n        // Extract all slot IDs\n        List<Integer> slotIds = slots.stream()\n                .map(SlotDTO::getId)\n                .collect(java.util.stream.Collectors.toList());\n\n        // Query regular attendance statuses (for LECTURE/LECTURE_WITH_PT slots)\n        List<Object[]> regularResults = attendanceRecordRepository\n                .findStatusesBySlotIdsAndStudent(slotIds, studentId);\n\n        java.util.Map<Integer, com.fuacs.backend.constant.enums.AttendanceStatus> regularStatusMap =\n                regularResults.stream()\n                        .collect(java.util.stream.Collectors.toMap(\n                                row -> (Integer) row[0],\n                                row -> (com.fuacs.backend.constant.enums.AttendanceStatus) row[1],\n                                (existing, replacement) -> existing  // Keep first if duplicate\n                        ));\n\n        // Query exam attendance statuses (for FINAL_EXAM slots)\n        List<Object[]> examResults = examAttendanceRepository\n                .findStatusesBySlotIdsAndStudent(slotIds, studentId);\n\n        java.util.Map<Integer, com.fuacs.backend.constant.enums.AttendanceStatus> examStatusMap =\n                examResults.stream()\n                        .collect(java.util.stream.Collectors.toMap(\n                                row -> (Integer) row[0],\n                                row -> (com.fuacs.backend.constant.enums.AttendanceStatus) row[1],\n                                (existing, replacement) -> existing\n                        ));\n\n        // Populate DTOs with appropriate status based on slot category\n        for (SlotDTO slot : slots) {\n            if (slot.getSlotCategory() == com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM) {\n                // For FINAL_EXAM: use exam attendance status\n                slot.setStudentAttendanceStatus(examStatusMap.get(slot.getId()));\n            } else {\n                // For LECTURE/LECTURE_WITH_PT: use regular attendance status\n                slot.setStudentAttendanceStatus(regularStatusMap.get(slot.getId()));\n            }\n            // Note: If no attendance record exists, status remains null (expected behavior)\n        }\n    }\n\n    @Transactional(readOnly = true)\n    public Long countByStudentId(Integer studentId, SlotSearchRequest request) {\n        request.setStudentUserId(studentId);\n        return slotRepository.countByStudentId(request);\n    }\n\n    @Transactional(readOnly = true)\n    public SlotDTO findById(Integer id) {\n        Slot slot = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n        return slotMapper.toDTO(slot);\n    }\n\n    @Transactional\n    public SlotDTO create(SlotCreateRequest request) {\n        // Validate time range\n        if (!isEndTimeAfterStartTime(request.getStartTime(), request.getEndTime())) {\n            throw new BadRequestException(\"End time must be after start time\", ErrorCode.INVALID_TIME_RANGE);\n        }\n\n        // Validate slot duration\n        Duration duration = Duration.between(request.getStartTime(), request.getEndTime());\n        long minutes = duration.toMinutes();\n        if (minutes < 30 || minutes > 240) {\n            throw new BadRequestException(\"Slot duration must be between 30 minutes and 4 hours\",\n                    ErrorCode.INVALID_SLOT_DURATION);\n        }\n\n        // Validate slotCategory and class/semester requirements\n        if (request.getSlotCategory() == SlotCategory.FINAL_EXAM) {\n            if (request.getClassId() != null) {\n                throw new BadRequestException(\"FINAL_EXAM slots cannot have a classId. Use semesterId instead\",\n                        ErrorCode.INVALID_SLOT_CATEGORY);\n            }\n            if (request.getSemesterId() == null) {\n                throw new BadRequestException(\"Semester ID is required for FINAL_EXAM slots\",\n                        ErrorCode.SLOT_SEMESTER_ID_REQUIRED);\n            }\n        } else {\n            // LECTURE or LECTURE_WITH_PT\n            if (request.getClassId() == null) {\n                throw new BadRequestException(\"Class ID is required for LECTURE and LECTURE_WITH_PT slots\",\n                        ErrorCode.SLOT_CLASS_ID_REQUIRED);\n            }\n        }\n\n        // Check for room time conflicts\n        if (slotRepository.existsByRoomAndTimeRange(request.getRoomId(), request.getStartTime(), request.getEndTime(),\n                null)) {\n            throw new BadRequestException(\"Room is already booked for the specified time range\",\n                    ErrorCode.ROOM_TIME_CONFLICT);\n        }\n\n        // Check for staff time conflicts\n        if (slotRepository.existsByStaffAndTimeRange(request.getStaffUserId(), request.getStartTime(),\n                request.getEndTime(), null)) {\n            throw new BadRequestException(\"Staff is already assigned to another slot for the specified time range\",\n                    ErrorCode.STAFF_TIME_CONFLICT);\n        }\n\n        // Fetch and validate entities (to avoid duplicate queries and transient object\n        // issues)\n        AcademicClass academicClass = null;\n        Semester semester = null;\n\n        // Validate and fetch semester (required for all slot types)\n        semester = semesterRepository.findById(request.getSemesterId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Semester not found: \" + request.getSemesterId(),\n                        ErrorCode.SEMESTER_NOT_FOUND));\n        if (!semester.getActive()) {\n            throw new BadRequestException(\"Cannot create slot with inactive semester\",\n                    ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n        }\n\n        // Validate slot time falls within semester date range\n        validateSlotTimeWithinSemester(request.getStartTime(), request.getEndTime(), semester);\n\n        // Validate and fetch class if provided (for LECTURE/LECTURE_WITH_PT)\n        if (request.getClassId() != null) {\n            academicClass = classRepository.findById(request.getClassId())\n                    .orElseThrow(() -> new ResourceNotFoundException(\"Class not found: \" + request.getClassId(),\n                            ErrorCode.CLASS_NOT_FOUND));\n            if (!academicClass.getActive()) {\n                throw new BadRequestException(\"Cannot create slot with inactive class\",\n                        ErrorCode.INACTIVE_CLASS_NOT_ALLOWED);\n            }\n\n            // Validate that class belongs to the specified semester\n            if (!academicClass.getSemester().getId().equals(request.getSemesterId())) {\n                throw new BadRequestException(\n                        \"Class does not belong to the specified semester. Class is in semester: \"\n                                + academicClass.getSemester().getName(),\n                        ErrorCode.CLASS_SEMESTER_MISMATCH);\n            }\n        }\n\n        // Validate and fetch room\n        var room = roomRepository.findById(request.getRoomId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Room not found: \" + request.getRoomId(),\n                        ErrorCode.ROOM_NOT_FOUND));\n        if (!room.getActive()) {\n            throw new BadRequestException(\"Cannot create slot with inactive room\", ErrorCode.INACTIVE_ROOM_NOT_ALLOWED);\n        }\n\n        // Validate and fetch staff\n        var staff = userRepository.findById(request.getStaffUserId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"User not found: \" + request.getStaffUserId(),\n                        ErrorCode.USER_NOT_FOUND));\n        if (!staff.getActive()) {\n            throw new BadRequestException(\"Cannot create slot with inactive staff\",\n                    ErrorCode.INACTIVE_STAFF_NOT_ALLOWED);\n        }\n\n        // Validate staff has LECTURER or SUPERVISOR role\n        boolean hasValidRole = staff.getRoles().stream()\n                .anyMatch(role -> role.getName().equals(\"LECTURER\") || role.getName().equals(\"SUPERVISOR\"));\n        if (!hasValidRole) {\n            throw new BadRequestException(\"Staff must have LECTURER or SUPERVISOR role to be assigned to a slot\",\n                    ErrorCode.INVALID_STAFF_ROLE_FOR_SLOT);\n        }\n\n        // Create slot entity using mapper\n        Slot slot = slotMapper.toEntity(request);\n\n        // Set fetched entities to avoid TransientObjectException\n        // All slots have semester\n        slot.setSemester(semester);\n\n        // LECTURE/LECTURE_WITH_PT also have class, FINAL_EXAM does not\n        if (request.getSlotCategory() == SlotCategory.FINAL_EXAM) {\n            slot.setAcademicClass(null);\n        } else {\n            slot.setAcademicClass(academicClass);\n        }\n\n        slot.setRoom(room);\n        slot.setStaff(staff);\n\n        Slot savedSlot = slotRepository.save(slot);\n\n        // Handle subjects for FINAL_EXAM slots (if provided)\n        if (request.getSlotCategory() == SlotCategory.FINAL_EXAM\n                && request.getSubjectIds() != null\n                && !request.getSubjectIds().isEmpty()) {\n\n            for (Short subjectId : request.getSubjectIds()) {\n                // Validate subject exists and is active\n                Subject subject = subjectRepository.findById(subjectId)\n                        .orElseThrow(() -> new ResourceNotFoundException(\n                                \"Subject with ID \" + subjectId + \" not found\",\n                                ErrorCode.SUBJECT_NOT_FOUND));\n\n                if (!subject.getActive()) {\n                    throw new BadRequestException(\n                            \"Cannot assign inactive subject: \" + subject.getName(),\n                            ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n                }\n\n                // Check if subject already assigned to this slot\n                if (examSlotSubjectRepository.existsBySlotIdAndSubjectIdAndIsActiveTrue(\n                        savedSlot.getId(), subjectId.intValue())) {\n                    // Skip duplicates silently (idempotent operation)\n                    continue;\n                }\n\n                // Create exam slot subject association\n                ExamSlotSubject examSlotSubject = new ExamSlotSubject();\n                examSlotSubject.setSlot(savedSlot);\n                examSlotSubject.setSubject(subject);\n                examSlotSubject.setIsActive(true); // Explicitly set for new records\n                examSlotSubjectRepository.save(examSlotSubject);\n            }\n        }\n\n        // Eager creation: Create initial attendance records for all students\n        createInitialAttendanceRecords(savedSlot);\n\n        return slotMapper.toDTO(savedSlot);\n    }\n\n    @Transactional\n    public SlotDTO update(Integer id, SlotUpdateRequest request) {\n        Slot existing = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n\n        // Validate time range\n        if (!isEndTimeAfterStartTime(request.getStartTime(), request.getEndTime())) {\n            throw new BadRequestException(\"End time must be after start time\", ErrorCode.INVALID_TIME_RANGE);\n        }\n\n        // Validate slot duration\n        Duration duration = Duration.between(request.getStartTime(), request.getEndTime());\n        long minutes = duration.toMinutes();\n        if (minutes < 30 || minutes > 240) {\n            throw new BadRequestException(\"Slot duration must be between 30 minutes and 4 hours\",\n                    ErrorCode.INVALID_SLOT_DURATION);\n        }\n\n        // Validate slotCategory and class/semester requirements\n        if (request.getSlotCategory() == SlotCategory.FINAL_EXAM) {\n            if (request.getClassId() != null) {\n                throw new BadRequestException(\"FINAL_EXAM slots cannot have a classId. Use semesterId instead\",\n                        ErrorCode.INVALID_SLOT_CATEGORY);\n            }\n            if (request.getSemesterId() == null) {\n                throw new BadRequestException(\"Semester ID is required for FINAL_EXAM slots\",\n                        ErrorCode.SLOT_SEMESTER_ID_REQUIRED);\n            }\n        } else {\n            // LECTURE or LECTURE_WITH_PT\n            if (request.getClassId() == null) {\n                throw new BadRequestException(\"Class ID is required for LECTURE and LECTURE_WITH_PT slots\",\n                        ErrorCode.SLOT_CLASS_ID_REQUIRED);\n            }\n        }\n\n        // Check for room time conflicts\n        if (slotRepository.existsByRoomAndTimeRange(request.getRoomId(), request.getStartTime(), request.getEndTime(),\n                id)) {\n            throw new BadRequestException(\"Room is already booked for the specified time range\",\n                    ErrorCode.ROOM_TIME_CONFLICT);\n        }\n\n        // Check for staff time conflicts\n        if (slotRepository.existsByStaffAndTimeRange(request.getStaffUserId(), request.getStartTime(),\n                request.getEndTime(), id)) {\n            throw new BadRequestException(\"Staff is already assigned to another slot for the specified time range\",\n                    ErrorCode.STAFF_TIME_CONFLICT);\n        }\n\n        // Validate class if provided\n        if (request.getClassId() != null) {\n            if (!classRepository.existsById(request.getClassId())) {\n                throw new ResourceNotFoundException(\"Class not found: \" + request.getClassId(),\n                        ErrorCode.CLASS_NOT_FOUND);\n            }\n            var classOpt = classRepository.findById(request.getClassId());\n            if (classOpt.isPresent() && !classOpt.get().getActive()) {\n                throw new BadRequestException(\"Cannot update slot with inactive class\",\n                        ErrorCode.INACTIVE_CLASS_NOT_ALLOWED);\n            }\n        }\n\n        // Validate semester if provided (for FINAL_EXAM)\n        Semester finalSemester = existing.getSemester();  // Default to existing semester\n        if (request.getSemesterId() != null) {\n            if (!semesterRepository.existsById(request.getSemesterId())) {\n                throw new ResourceNotFoundException(\"Semester not found: \" + request.getSemesterId(),\n                        ErrorCode.SEMESTER_NOT_FOUND);\n            }\n            var semesterOpt = semesterRepository.findById(request.getSemesterId());\n            if (semesterOpt.isPresent() && !semesterOpt.get().getActive()) {\n                throw new BadRequestException(\"Cannot update slot with inactive semester\",\n                        ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n            }\n            finalSemester = semesterOpt.get();  // Update final semester\n        }\n\n        // Validate slot time falls within semester date range\n        // Use updated times or existing times\n        LocalDateTime finalStartTime = request.getStartTime();\n        LocalDateTime finalEndTime = request.getEndTime();\n\n        if (finalSemester != null) {\n            validateSlotTimeWithinSemester(finalStartTime, finalEndTime, finalSemester);\n        }\n\n        // Validate room\n        if (!roomRepository.existsById(request.getRoomId())) {\n            throw new ResourceNotFoundException(\"Room not found: \" + request.getRoomId(), ErrorCode.ROOM_NOT_FOUND);\n        }\n        var roomOpt = roomRepository.findById(request.getRoomId());\n        if (roomOpt.isPresent() && !roomOpt.get().getActive()) {\n            throw new BadRequestException(\"Cannot update slot with inactive room\", ErrorCode.INACTIVE_ROOM_NOT_ALLOWED);\n        }\n\n        // Validate staff\n        if (!userRepository.existsById(request.getStaffUserId())) {\n            throw new ResourceNotFoundException(\"User not found: \" + request.getStaffUserId(),\n                    ErrorCode.USER_NOT_FOUND);\n        }\n        var userOpt = userRepository.findById(request.getStaffUserId());\n        if (userOpt.isPresent() && !userOpt.get().getActive()) {\n            throw new BadRequestException(\"Cannot update slot with inactive staff\",\n                    ErrorCode.INACTIVE_STAFF_NOT_ALLOWED);\n        }\n\n        // Validate staff has LECTURER or SUPERVISOR role\n        if (userOpt.isPresent()) {\n            boolean hasValidRole = userOpt.get().getRoles().stream()\n                    .anyMatch(role -> role.getName().equals(\"LECTURER\") || role.getName().equals(\"SUPERVISOR\"));\n            if (!hasValidRole) {\n                throw new BadRequestException(\"Staff must have LECTURER or SUPERVISOR role to be assigned to a slot\",\n                        ErrorCode.INVALID_STAFF_ROLE_FOR_SLOT);\n            }\n        }\n\n        // Check if current time (Vietnam timezone) is after slot end time\n        ZonedDateTime nowVN = ZonedDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        ZonedDateTime slotEndTimeVN = existing.getEndTime().atZone(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n\n        if (nowVN.isAfter(slotEndTimeVN)) {\n            // Check if user is DATA_OPERATOR (admin) - they can bypass time restriction\n            boolean isAdmin = SecurityUtil.getUserAuthentication()\n                    .map(auth -> auth.hasRole(\"DATA_OPERATOR\"))\n                    .orElse(false);\n\n            // Only block non-admin users\n            if (!isAdmin) {\n                throw new OperationNotAllowedException(\n                        \"Cannot update slot after end time has passed. Slot ended at: \" + existing.getEndTime(),\n                        ErrorCode.CANNOT_UPDATE_SLOT_AFTER_END_TIME);\n            }\n            // Admin bypasses - continue with update\n        }\n\n        // Check if trying to deactivate slot with active dependencies\n        if (existing.getActive() && !request.getActive()) {\n            LocalDateTime now = LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n\n            // Check 1: Slot must not have started yet\n            if (now.isAfter(existing.getStartTime()) || now.equals(existing.getStartTime())) {\n                throw new OperationNotAllowedException(\n                        \"Cannot deactivate slot that has started or already passed\",\n                        ErrorCode.SLOT_ALREADY_STARTED_OR_PASSED);\n            }\n\n            // Check 2: No actual attendance data (PRESENT/ABSENT only, NOT_YET is OK)\n            long actualAttendance = slotRepository.countActualAttendanceRecordsBySlotId(id);\n            long actualExamAttendance = slotRepository.countActualExamAttendanceRecordsBySlotId(id);\n\n            if (actualAttendance > 0 || actualExamAttendance > 0) {\n                throw new OperationNotAllowedException(\n                        String.format(\"Cannot deactivate slot with actual attendance data. Found %d regular and %d exam attendance records (PRESENT/ABSENT)\",\n                                     actualAttendance, actualExamAttendance),\n                        ErrorCode.SLOT_HAS_ACTUAL_ATTENDANCE_DATA);\n            }\n        }\n\n        // Block updating inactive slot (except reactivating)\n        if (!existing.getActive() && !request.getActive()) {\n            throw new BadRequestException(\n                    \"Cannot update inactive slot. Please reactivate the slot first.\",\n                    ErrorCode.INACTIVE_SLOT_NOT_ALLOWED);\n        }\n\n        // Update fields\n        existing.setTitle(request.getTitle());\n        existing.setDescription(request.getDescription());\n        existing.setStartTime(request.getStartTime());\n        existing.setEndTime(request.getEndTime());\n        existing.setSlotCategory(request.getSlotCategory());\n        existing.setActive(request.getActive());\n\n        // Update references\n        existing.setAcademicClass(\n                request.getClassId() != null ? classRepository.findById(request.getClassId()).orElse(null) : null);\n        existing.setSemester(\n                request.getSemesterId() != null ? semesterRepository.findById(request.getSemesterId()).orElse(null)\n                        : null);\n        existing.setRoom(roomRepository.findById(request.getRoomId()).orElse(null));\n        existing.setStaff(userRepository.findById(request.getStaffUserId()).orElse(null));\n\n        // Handle subjects for FINAL_EXAM slots\n        if (existing.getSlotCategory() == SlotCategory.FINAL_EXAM && request.getSubjectIds() != null) {\n            updateExamSlotSubjects(existing, request.getSubjectIds());\n        }\n\n        Slot savedSlot = slotRepository.save(existing);\n        SlotDTO dto = slotMapper.toDTO(savedSlot);\n\n        // Load and set subjects for FINAL_EXAM slots\n        if (savedSlot.getSlotCategory() == SlotCategory.FINAL_EXAM) {\n            dto.setExamSubjects(examSlotSubjectRepository.findSubjectsBySlotId(savedSlot.getId()));\n        }\n\n        return dto;\n    }\n\n    /**\n     * Updates subjects for FINAL_EXAM slot by comparing current vs new subjects.\n     * - Removes subjects not in new list (validates no participants)\n     * - Adds subjects in new list but not currently assigned\n     */\n    private void updateExamSlotSubjects(Slot slot, List<Short> newSubjectIds) {\n        // 1. Get current subjects\n        List<ExamSlotSubject> currentSubjects = examSlotSubjectRepository\n                .findBySlotIdAndIsActiveTrue(slot.getId());\n\n        Set<Short> currentIds = currentSubjects.stream()\n                .map(ess -> ess.getSubject().getId())\n                .collect(Collectors.toSet());\n\n        Set<Short> newIds = new HashSet<>(newSubjectIds);\n\n        // 2. Calculate diff\n        Set<Short> toRemove = new HashSet<>(currentIds);\n        toRemove.removeAll(newIds); // Subjects to remove\n\n        Set<Short> toAdd = new HashSet<>(newIds);\n        toAdd.removeAll(currentIds); // Subjects to add\n\n        // 3. Remove subjects (CHECK PARTICIPANTS FIRST!)\n        for (Short subjectId : toRemove) {\n            ExamSlotSubject ess = currentSubjects.stream()\n                    .filter(s -> s.getSubject().getId().equals(subjectId))\n                    .findFirst()\n                    .orElseThrow();\n\n            // Check if subject has enrolled participants using existing repository method\n            Long participantCount = examSlotSubjectRepository.countActiveParticipants(ess.getId());\n\n            if (participantCount > 0) {\n                throw new OperationNotAllowedException(\n                        \"Cannot remove subject \" + ess.getSubject().getCode() +\n                        \". It has \" + participantCount + \" enrolled participant(s)\",\n                        ErrorCode.EXAM_SLOT_SUBJECT_HAS_PARTICIPANTS);\n            }\n\n            // Safe to remove (soft delete by setting isActive = false)\n            ess.setIsActive(false);\n            examSlotSubjectRepository.save(ess);\n        }\n\n        // 4. Add new subjects\n        for (Short subjectId : toAdd) {\n            Subject subject = subjectRepository.findById(subjectId)\n                    .orElseThrow(() -> new ResourceNotFoundException(\n                            \"Subject not found: \" + subjectId,\n                            ErrorCode.SUBJECT_NOT_FOUND));\n\n            if (!subject.getActive()) {\n                throw new BadRequestException(\n                        \"Cannot assign inactive subject: \" + subjectId,\n                        ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n            }\n\n            // Check if already exists (might be soft-deleted)\n            ExamSlotSubject existing = examSlotSubjectRepository\n                    .findBySlotIdAndSubjectId(slot.getId(), subjectId.intValue())\n                    .orElse(null);\n\n            if (existing != null) {\n                // Re-activate if soft-deleted\n                existing.setIsActive(true);\n                examSlotSubjectRepository.save(existing);\n            } else {\n                // Create new\n                ExamSlotSubject newEss = new ExamSlotSubject();\n                newEss.setSlot(slot);\n                newEss.setSubject(subject);\n                examSlotSubjectRepository.save(newEss);\n            }\n        }\n    }\n\n    @Transactional\n    public SlotDTO updateSlotCategory(Integer id, SlotCategoryUpdateRequest request, Integer currentUserId) {\n        Slot existing = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n\n        // Check if current user is assigned to this slot\n        if (!existing.getStaff().getId().equals(currentUserId)) {\n            throw new OperationNotAllowedException(\"You can only update slots for classes you are assigned to\",\n                    ErrorCode.NOT_ASSIGNED_TO_CLASS);\n        }\n\n        SlotCategory currentCategory = existing.getSlotCategory();\n        SlotCategory newCategory = request.getSlotCategory();\n\n        boolean hasFinalExamPermission = com.fuacs.backend.util.SecurityUtil.getUserAuthentication()\n                .map(com.fuacs.backend.config.UserAuthentication::getPermissions)\n                .map(p -> p.contains(\"SLOT_UPDATE_FINAL_EXAM\") || p.contains(\"SLOT_CREATE_FINAL_EXAM\"))\n                .orElse(false);\n\n        // Validate category transition\n        if (!isValidCategoryTransition(currentCategory, newCategory, hasFinalExamPermission)) {\n            throw new BadRequestException(\n                    \"Cannot change slot category. Only LECTURE ↔ LECTURE_WITH_PT transitions are allowed for lecturers\",\n                    ErrorCode.INVALID_SLOT_CATEGORY_TRANSITION);\n        }\n\n        // CATEGORY TRANSITION VALIDATION: LECTURE_WITH_PT → LECTURE\n        if (currentCategory == SlotCategory.LECTURE_WITH_PT && newCategory == SlotCategory.LECTURE) {\n            // Check if any exam attendance records have status PRESENT or ABSENT\n            Long examDataCount = examAttendanceRepository.countBySlotIdAndStatusNot(id, AttendanceStatus.NOT_YET);\n\n            if (examDataCount > 0) {\n                // Exam attendance data exists - block the transition\n                throw new BadRequestException(\n                    String.format(\"Cannot change category to LECTURE - %d student(s) have PRESENT/ABSENT exam attendance. \" +\n                                 \"Please delete or reset exam attendance first.\", examDataCount),\n                    ErrorCode.CANNOT_CHANGE_CATEGORY_EXAM_DATA_EXISTS\n                );\n            } else {\n                // All exam attendance records are NOT_YET - safe to delete them\n                examAttendanceRepository.deleteBySlotId(id);\n                logger.info(\"Deleted all NOT_YET exam attendance records for slot {} during category change\", id);\n            }\n        }\n\n        existing.setSlotCategory(newCategory);\n        return slotMapper.toDTO(slotRepository.save(existing));\n    }\n\n    @Transactional\n    public void delete(Integer id) {\n        Slot slot = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n\n        // Check 1: Slot must not have started yet (Vietnam timezone)\n        ZonedDateTime nowVN = ZonedDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        ZonedDateTime slotStartVN = slot.getStartTime().atZone(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n\n        if (nowVN.isAfter(slotStartVN) || nowVN.isEqual(slotStartVN)) {\n            throw new OperationNotAllowedException(\n                    \"Cannot delete slot. Slot has already started or is starting now.\",\n                    ErrorCode.SLOT_ALREADY_STARTED);\n        }\n\n        // Cascade delete all attendance records (slot hasn't started, so only NOT_YET records exist)\n        List<AttendanceRecord> notYetRecords = attendanceRecordRepository\n                .findBySlotIdAndStatus(id, AttendanceStatus.NOT_YET);\n        if (!notYetRecords.isEmpty()) {\n            attendanceRecordRepository.deleteAll(notYetRecords);\n            logger.info(\"Deleted {} NOT_YET attendance records for slot {}\", notYetRecords.size(), id);\n        }\n\n        List<ExamAttendance> notYetExamRecords = examAttendanceRepository\n                .findBySlotIdAndStatus(id, AttendanceStatus.NOT_YET);\n        if (!notYetExamRecords.isEmpty()) {\n            examAttendanceRepository.deleteAll(notYetExamRecords);\n            logger.info(\"Deleted {} NOT_YET exam attendance records for slot {}\", notYetExamRecords.size(), id);\n        }\n\n        // Step 4: Delete slot\n        try {\n            slotRepository.deleteById(id);\n            logger.info(\"Successfully deleted slot {}\", id);\n        } catch (DataIntegrityViolationException e) {\n            throw new OperationNotAllowedException(\n                    \"Cannot delete slot. It is currently in use by other records.\",\n                    ErrorCode.SLOT_HAS_DEPENDENCIES);\n        }\n    }\n\n    @Transactional\n    public SessionStatusResponse startAttendanceSession(Integer id, Integer currentUserId) {\n        Slot slot = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n\n        // Check if current user is assigned to this slot\n        if (!slot.getStaff().getId().equals(currentUserId)) {\n            throw new OperationNotAllowedException(\"You can only start sessions for slots assigned to you\",\n                    ErrorCode.SLOT_NOT_ASSIGNED_TO_USER);\n        }\n\n        // MUTUAL EXCLUSION: Check if exam session is running\n        if (slot.getExamSessionStatus() == com.fuacs.backend.constant.enums.SessionStatus.RUNNING) {\n            throw new OperationNotAllowedException(\n                    \"Cannot start Regular session while Exam session is running. Please stop Exam session first.\",\n                    ErrorCode.EXAM_SESSION_RUNNING);\n        }\n\n        // Validate session status - cannot start if already running\n        if (slot.getSessionStatus() == com.fuacs.backend.constant.enums.SessionStatus.RUNNING) {\n            throw new BadRequestException(\n                    \"Session is already running. Please stop the current session first.\",\n                    ErrorCode.SESSION_ALREADY_RUNNING);\n        }\n\n        // Validate session status - if already stopped with scans, must use rescan\n        if (slot.getSessionStatus() == com.fuacs.backend.constant.enums.SessionStatus.STOPPED \n                && slot.getScanCount() > 0) {\n            throw new BadRequestException(\n                    \"Cannot start new session. Use rescan instead.\",\n                    ErrorCode.USE_RESCAN_INSTEAD);\n        }\n\n        // Update session metadata before starting\n        slot.setSessionStatus(com.fuacs.backend.constant.enums.SessionStatus.RUNNING);\n        slot.setScanCount(slot.getScanCount() + 1);\n        slotRepository.save(slot);\n\n        // Delegate to SlotSessionService for Python backend integration with INITIAL mode\n        SessionStatusResponse response = slotSessionService.startSession(id, currentUserId, ScanMode.INITIAL);\n\n        return response;\n    }\n\n    @Transactional\n    public SessionStatusResponse triggerRescan(Integer id, Integer currentUserId) {\n        Slot slot = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n\n        // Check if current user is assigned to this slot\n        if (!slot.getStaff().getId().equals(currentUserId)) {\n            throw new OperationNotAllowedException(\"You can only trigger re-scans for slots assigned to you\",\n                    ErrorCode.SLOT_NOT_ASSIGNED_TO_USER);\n        }\n\n        // Validate session status - cannot rescan if session is running\n        if (slot.getSessionStatus() == com.fuacs.backend.constant.enums.SessionStatus.RUNNING) {\n            throw new BadRequestException(\n                    \"Cannot rescan while session is running. Please stop the session first.\",\n                    ErrorCode.SESSION_RUNNING);\n        }\n\n        // Validate scan count - cannot rescan before initial scan\n        if (slot.getScanCount() == 0) {\n            throw new BadRequestException(\n                    \"Cannot rescan before initial scan. Use start session instead.\",\n                    ErrorCode.NO_INITIAL_SCAN);\n        }\n\n        // Update session metadata before rescanning\n        slot.setSessionStatus(com.fuacs.backend.constant.enums.SessionStatus.RUNNING);\n        slot.setScanCount(slot.getScanCount() + 1);\n        slotRepository.save(slot);\n\n        // Delegate to SlotSessionService with RESCAN mode\n        SessionStatusResponse response = slotSessionService.startSession(id, currentUserId, ScanMode.RESCAN);\n\n        return response;\n    }\n\n    @Transactional\n    public SessionStatusResponse stopAttendanceSession(Integer id, Integer currentUserId) {\n        Slot slot = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n\n        // Check if current user is assigned to this slot\n        if (!slot.getStaff().getId().equals(currentUserId)) {\n            throw new OperationNotAllowedException(\"You can only stop sessions for slots assigned to you\",\n                    ErrorCode.SLOT_NOT_ASSIGNED_TO_USER);\n        }\n\n        // Delegate to SlotSessionService for Python backend integration\n        SessionStatusResponse response = slotSessionService.stopSession(id, currentUserId);\n\n        return response;\n    }\n\n    // ========== Exam Session Methods (LECTURE_WITH_PT & FINAL_EXAM) ==========\n\n    @Transactional\n    public SessionStatusResponse startExamSession(Integer id, Integer currentUserId) {\n        Slot slot = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n\n        // Check if current user is assigned to this slot\n        if (!slot.getStaff().getId().equals(currentUserId)) {\n            throw new OperationNotAllowedException(\"You can only start exam sessions for slots assigned to you\",\n                    ErrorCode.SLOT_NOT_ASSIGNED_TO_USER);\n        }\n\n        // MUTUAL EXCLUSION: Check if regular session is running\n        if (slot.getSessionStatus() == com.fuacs.backend.constant.enums.SessionStatus.RUNNING) {\n            throw new OperationNotAllowedException(\n                    \"Cannot start Exam session while Regular session is running. Please stop Regular session first.\",\n                    ErrorCode.REGULAR_SESSION_RUNNING);\n        }\n\n        // Validate exam session status - cannot start if already running\n        if (slot.getExamSessionStatus() == com.fuacs.backend.constant.enums.SessionStatus.RUNNING) {\n            throw new BadRequestException(\n                    \"Exam session is already running. Please stop the current exam session first.\",\n                    ErrorCode.EXAM_SESSION_ALREADY_RUNNING);\n        }\n\n        // Validate exam session status - if already stopped with scans, must use rescan-exam\n        if (slot.getExamSessionStatus() == com.fuacs.backend.constant.enums.SessionStatus.STOPPED\n                && slot.getExamScanCount() > 0) {\n            throw new BadRequestException(\n                    \"Cannot start new exam session. Use rescan-exam instead.\",\n                    ErrorCode.USE_EXAM_RESCAN_INSTEAD);\n        }\n\n        // Update exam session metadata before starting\n        slot.setExamSessionStatus(com.fuacs.backend.constant.enums.SessionStatus.RUNNING);\n        slot.setExamScanCount(slot.getExamScanCount() + 1);\n        slotRepository.save(slot);\n\n        // Delegate to SlotSessionService for Python backend integration\n        SessionStatusResponse response = slotSessionService.startExamSession(id, currentUserId);\n\n        return response;\n    }\n\n    @Transactional\n    public SessionStatusResponse stopExamSession(Integer id, Integer currentUserId) {\n        Slot slot = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n\n        // Check if current user is assigned to this slot\n        if (!slot.getStaff().getId().equals(currentUserId)) {\n            throw new OperationNotAllowedException(\"You can only stop exam sessions for slots assigned to you\",\n                    ErrorCode.SLOT_NOT_ASSIGNED_TO_USER);\n        }\n\n        // Delegate to SlotSessionService for Python backend integration\n        SessionStatusResponse response = slotSessionService.stopExamSession(id, currentUserId);\n\n        return response;\n    }\n\n    @Transactional\n    public SessionStatusResponse rescanExam(Integer id, Integer currentUserId) {\n        Slot slot = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n\n        // Check if current user is assigned to this slot\n        if (!slot.getStaff().getId().equals(currentUserId)) {\n            throw new OperationNotAllowedException(\"You can only trigger exam re-scans for slots assigned to you\",\n                    ErrorCode.SLOT_NOT_ASSIGNED_TO_USER);\n        }\n\n        // Validate exam session status - cannot rescan if session is running\n        if (slot.getExamSessionStatus() == com.fuacs.backend.constant.enums.SessionStatus.RUNNING) {\n            throw new BadRequestException(\n                    \"Cannot rescan while exam session is running. Please stop the exam session first.\",\n                    ErrorCode.EXAM_SESSION_RUNNING);\n        }\n\n        // Validate exam scan count - cannot rescan before initial scan\n        if (slot.getExamScanCount() == 0) {\n            throw new BadRequestException(\n                    \"Cannot rescan before initial exam scan. Use start-exam-session instead.\",\n                    ErrorCode.NO_INITIAL_EXAM_SCAN);\n        }\n\n        // Update exam session metadata before rescanning\n        slot.setExamSessionStatus(com.fuacs.backend.constant.enums.SessionStatus.RUNNING);\n        slot.setExamScanCount(slot.getExamScanCount() + 1);\n        slotRepository.save(slot);\n\n        // Delegate to SlotSessionService with EXAM RESCAN mode\n        SessionStatusResponse response = slotSessionService.rescanExamSession(id, currentUserId);\n\n        return response;\n    }\n\n    @Transactional\n    public List<com.fuacs.backend.dto.response.SlotRosterItemDTO> getSlotRoster(Integer id, Integer currentUserId) {\n        Slot slot = slotRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Slot not found: \" + id, ErrorCode.SLOT_NOT_FOUND));\n\n        boolean isAssignedStaff = slot.getStaff().getId().equals(currentUserId);\n        boolean hasDataOperatorRole = SecurityUtil.getUserAuthentication()\n                .map(auth -> auth.hasRole(Role.DATA_OPERATOR.toString()))\n                .orElse(false);\n\n        if (!isAssignedStaff && !hasDataOperatorRole) {\n            throw new OperationNotAllowedException(\"You are not assigned to this slot and cannot view its roster\",\n                    ErrorCode.NOT_ASSIGNED_TO_SLOT);\n        }\n\n        // Get roster from repository\n        List<com.fuacs.backend.dto.response.SlotRosterItemDTO> roster = slotRepository.getSlotRoster(id);\n\n        // Lazy fallback: Ensure all students have attendance records\n        int created = ensureAttendanceRecordsExist(slot, roster);\n\n        // If we created any records, re-query to get the updated roster with recordIds\n        if (created > 0) {\n            roster = slotRepository.getSlotRoster(id);\n            logger.info(\"Re-queried roster after creating {} missing attendance records\", created);\n        }\n\n        return roster;\n    }\n\n    public List<SlotDTO> searchByClassId(Short classId, SlotSearchRequest request) {\n        return slotRepository.searchByClassId(classId, request);\n    }\n\n    public Long countByClassId(Short classId, SlotSearchRequest request) {\n        return slotRepository.countByClassId(classId, request);\n    }\n\n    public List<SlotDTO> searchByRoomId(Short classId, SlotSearchRequest request) {\n        return slotRepository.searchByRoomId(classId, request);\n    }\n\n    public Long countByRoomId(Short classId, SlotSearchRequest request) {\n        return slotRepository.countByRoomId(classId, request);\n    }\n\n    private boolean isEndTimeAfterStartTime(LocalDateTime startTime, LocalDateTime endTime) {\n        return endTime.isAfter(startTime);\n    }\n\n    /**\n     * Validates that slot time falls within semester date range.\n     *\n     * @param slotStartTime Slot start time (LocalDateTime)\n     * @param slotEndTime Slot end time (LocalDateTime)\n     * @param semester Semester entity with startDate and endDate\n     * @throws BadRequestException if slot time is outside semester range\n     */\n    private void validateSlotTimeWithinSemester(\n            LocalDateTime slotStartTime,\n            LocalDateTime slotEndTime,\n            Semester semester) {\n\n        // Convert LocalDateTime to LocalDate for comparison\n        LocalDate slotStartDate = slotStartTime.toLocalDate();\n        LocalDate slotEndDate = slotEndTime.toLocalDate();\n\n        LocalDate semesterStartDate = semester.getStartDate();\n        LocalDate semesterEndDate = semester.getEndDate();\n\n        // Check if slot start date is before semester start\n        if (slotStartDate.isBefore(semesterStartDate)) {\n            throw new BadRequestException(\n                String.format(\n                    \"Slot start date (%s) is before semester start date (%s). \" +\n                    \"Slot must be within semester date range: %s to %s\",\n                    slotStartDate, semesterStartDate, semesterStartDate, semesterEndDate\n                ),\n                ErrorCode.SLOT_OUTSIDE_SEMESTER_RANGE\n            );\n        }\n\n        // Check if slot end date is after semester end\n        if (slotEndDate.isAfter(semesterEndDate)) {\n            throw new BadRequestException(\n                String.format(\n                    \"Slot end date (%s) is after semester end date (%s). \" +\n                    \"Slot must be within semester date range: %s to %s\",\n                    slotEndDate, semesterEndDate, semesterStartDate, semesterEndDate\n                ),\n                ErrorCode.SLOT_OUTSIDE_SEMESTER_RANGE\n            );\n        }\n    }\n\n    private boolean isValidCategoryTransition(SlotCategory current, SlotCategory newCategory,\n                                              boolean allowFinalExamTransitions) {\n        // Allow LECTURE LECTURE_WITH_PT transitions\n        if ((current == SlotCategory.LECTURE && newCategory == SlotCategory.LECTURE_WITH_PT) ||\n                (current == SlotCategory.LECTURE_WITH_PT && newCategory == SlotCategory.LECTURE)) {\n            return true;\n        }\n\n        // Allow FINAL_EXAM transitions only when privileged\n        if (allowFinalExamTransitions) {\n            if ((current == SlotCategory.LECTURE_WITH_PT && newCategory == SlotCategory.FINAL_EXAM) ||\n                    (current == SlotCategory.FINAL_EXAM && newCategory == SlotCategory.LECTURE_WITH_PT) ||\n                    (current == SlotCategory.LECTURE && newCategory == SlotCategory.FINAL_EXAM) ||\n                    (current == SlotCategory.FINAL_EXAM && newCategory == SlotCategory.LECTURE)) {\n                return true;\n            }\n        }\n\n        // No change is valid\n        return current == newCategory;\n    }\n\n    /**\n     * Import slots from CSV file with partial success pattern.\n     * Supports AddOnly and AddAndUpdate modes.\n     * NO @Transactional here to avoid rollback-only conflict.\n     *\n     * @param file    CSV file with format:\n     *                title,start_time,end_time,slot_category,class_code,semester_code,room_name,staff_username\n     * @param modeStr Import mode (\"AddOnly\" or \"AddAndUpdate\")\n     * @return ImportResultDTO with success/failure counts and error details\n     */\n    public ImportResultDTO importFromCsv(MultipartFile file, String modeStr) {\n        logger.info(\"Starting slot CSV import with mode: {}\", modeStr);\n\n        // Parse mode\n        ImportMode mode;\n        try {\n            mode = ImportMode.fromString(modeStr);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), ErrorCode.INVALID_IMPORT_MODE);\n        }\n\n        // Parse CSV\n        List<SlotCsvRow> rows;\n        try {\n            rows = csvParserService.parseSlotCsv(file);\n        } catch (IOException e) {\n            throw new BadRequestException(\"Failed to process CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        logger.info(\"Parsed {} rows from CSV\", rows.size());\n\n        // Deduplicate within file by business key\n        Map<String, SlotCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (SlotCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getUniqueKey(), row);\n        }\n\n        logger.info(\"After deduplication: {} unique slots\", uniqueRows.size());\n\n        // Process rows with partial success\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (SlotCsvRow row : uniqueRows.values()) {\n            try {\n                processOneSlotRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                logger.warn(\"Failed to process row {}: {}\", row.getRowNumber(), e.getMessage());\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()));\n            }\n        }\n\n        logger.info(\"Slot import completed: {} successful, {} failed\", successCount, errors.size());\n\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Process a single slot row in a separate transaction.\n     * This ensures one row's failure doesn't affect others (partial success).\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneSlotRow(SlotCsvRow row, ImportMode mode) {\n        // Validate row\n        String validationError = row.getValidationError();\n        if (validationError != null) {\n            throw new BadRequestException(validationError, ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Parse datetime\n        LocalDateTime startTime = row.getStartTime();\n        LocalDateTime endTime = row.getEndTime();\n        if (startTime == null || endTime == null) {\n            throw new BadRequestException(\"Invalid datetime format\", ErrorCode.INVALID_TIME_FORMAT);\n        }\n\n        // Validate time range\n        if (!isEndTimeAfterStartTime(startTime, endTime)) {\n            throw new BadRequestException(\"End time must be after start time\", ErrorCode.START_TIME_AFTER_END_TIME);\n        }\n\n        // Validate slot duration (30 mins to 4 hours)\n        Duration duration = Duration.between(startTime, endTime);\n        long minutes = duration.toMinutes();\n        if (minutes < 30 || minutes > 240) {\n            throw new BadRequestException(\"Slot duration must be between 30 minutes and 4 hours\",\n                    ErrorCode.INVALID_SLOT_DURATION);\n        }\n\n        // Parse slot category\n        SlotCategory slotCategory;\n        try {\n            slotCategory = SlotCategory.valueOf(row.getSlotCategory());\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(\"Invalid slot category: \" + row.getSlotCategory(),\n                    ErrorCode.INVALID_SLOT_CATEGORY);\n        }\n\n        // Find semester\n        Semester semester = semesterRepository.findByCode(row.getSemesterCode());\n        if (semester == null) {\n            throw new ResourceNotFoundException(\n                    \"Semester not found with code: \" + row.getSemesterCode(),\n                    ErrorCode.SEMESTER_NOT_FOUND);\n        }\n        if (!semester.getActive()) {\n            throw new BadRequestException(\"Cannot create slot with inactive semester\",\n                    ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n        }\n\n        // Find room\n        var room = roomRepository.findByName(row.getRoomName());\n        if (room == null) {\n            throw new ResourceNotFoundException(\n                    \"Room not found with name: \" + row.getRoomName(),\n                    ErrorCode.ROOM_NOT_FOUND);\n        }\n        if (!room.getActive()) {\n            throw new BadRequestException(\"Cannot create slot with inactive room\",\n                    ErrorCode.INACTIVE_ROOM_NOT_ALLOWED);\n        }\n\n        // Find staff (eagerly fetch roles to avoid LazyInitializationException)\n        var staff = userRepository.findByUsernameWithRoles(row.getStaffUsername())\n                .orElseThrow(() -> new ResourceNotFoundException(\n                        \"Staff not found with username: \" + row.getStaffUsername(),\n                        ErrorCode.STAFF_NOT_FOUND));\n        if (!staff.getActive()) {\n            throw new BadRequestException(\"Cannot create slot with inactive staff\",\n                    ErrorCode.INACTIVE_STAFF_NOT_ALLOWED);\n        }\n\n        // Validate staff has LECTURER or SUPERVISOR role\n        boolean hasValidRole = staff.getRoles().stream()\n                .anyMatch(role -> role.getName().equals(\"LECTURER\") || role.getName().equals(\"SUPERVISOR\"));\n        if (!hasValidRole) {\n            throw new BadRequestException(\"Staff must have LECTURER or SUPERVISOR role\",\n                    ErrorCode.INVALID_STAFF_ROLE_FOR_SLOT);\n        }\n\n        // Find class (required for LECTURE/LECTURE_WITH_PT)\n        if (row.getClassCode() == null || row.getClassCode().trim().isEmpty()) {\n            throw new BadRequestException(\"Class code is required for LECTURE and LECTURE_WITH_PT slots\",\n                    ErrorCode.CLASS_ID_REQUIRED_FOR_LECTURE);\n        }\n\n        AcademicClass academicClass = classRepository.findByCodeAndSemesterCode(row.getClassCode(), row.getSemesterCode());\n        if (academicClass == null) {\n            throw new ResourceNotFoundException(\n                    \"Class not found for code \" + row.getClassCode() + \" and semester \" + row.getSemesterCode(),\n                    ErrorCode.CLASS_NOT_FOUND);\n        }\n        if (!academicClass.getActive()) {\n            throw new BadRequestException(\"Cannot create slot with inactive class\",\n                    ErrorCode.INACTIVE_CLASS_NOT_ALLOWED);\n        }\n\n        // Check for room time conflicts\n        if (slotRepository.existsByRoomAndTimeRange(room.getId(), startTime, endTime, null)) {\n            throw new BadRequestException(\"Room is already booked for the specified time range\",\n                    ErrorCode.ROOM_TIME_CONFLICT);\n        }\n\n        // Check for staff time conflicts\n        if (slotRepository.existsByStaffAndTimeRange(staff.getId(), startTime, endTime, null)) {\n            throw new BadRequestException(\"Staff is already assigned to another slot for the specified time range\",\n                    ErrorCode.STAFF_TIME_CONFLICT);\n        }\n\n        // Create new slot (no update logic for simplicity - business key is complex)\n        Slot slot = new Slot();\n        slot.setTitle(row.getTitle() != null && !row.getTitle().isEmpty() ? row.getTitle() : null);\n        slot.setStartTime(startTime);\n        slot.setEndTime(endTime);\n        slot.setSlotCategory(slotCategory);\n        slot.setSemester(semester);\n        slot.setRoom(room);\n        slot.setStaff(staff);\n        slot.setAcademicClass(academicClass); // null for FINAL_EXAM\n        slot.setActive(true);\n        slot.setCreatedAt(Instant.now());\n        slot.setUpdatedAt(Instant.now());\n\n        Slot savedSlot = slotRepository.save(slot);\n\n        // Eager creation: Create initial attendance records for all students\n        createInitialAttendanceRecords(savedSlot);\n    }\n\n    /**\n     * Import FINAL_EXAM slots from CSV file with partial success pattern.\n     * Supports AddOnly and AddAndUpdate modes.\n     * NO @Transactional here to avoid rollback-only conflict.\n     *\n     * @param file    CSV file with format:\n     *                title,start_time,end_time,slot_category,semester_code,room_name,staff_username,subject_codes\n     * @param modeStr Import mode (\"AddOnly\" or \"AddAndUpdate\")\n     * @return ImportResultDTO with success/failure counts and error details\n     */\n    public ImportResultDTO importExamSlotsFromCsv(MultipartFile file, String modeStr) {\n        logger.info(\"Starting exam slot CSV import with mode: {}\", modeStr);\n\n        // Parse mode\n        ImportMode mode;\n        try {\n            mode = ImportMode.fromString(modeStr);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), ErrorCode.INVALID_IMPORT_MODE);\n        }\n\n        // Parse CSV\n        List<ExamSlotCsvRow> rows;\n        try {\n            rows = csvParserService.parseExamSlotCsv(file);\n        } catch (IOException e) {\n            throw new BadRequestException(\"Failed to process CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        logger.info(\"Parsed {} rows from CSV\", rows.size());\n\n        // Deduplicate within file by business key\n        Map<String, ExamSlotCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (ExamSlotCsvRow row : rows) {\n            String key = row.getSemesterCode() + \"|\" + row.getStartTimeStr() + \"|\" + row.getRoomName() + \"|\" + row.getStaffUsername();\n            uniqueRows.putIfAbsent(key, row);\n        }\n\n        logger.info(\"After deduplication: {} unique exam slots\", uniqueRows.size());\n\n        // Process rows with partial success\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (ExamSlotCsvRow row : uniqueRows.values()) {\n            try {\n                processOneExamSlotRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                logger.warn(\"Failed to process row {}: {}\", row.getRowNumber(), e.getMessage());\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()));\n            }\n        }\n\n        logger.info(\"Exam slot import completed: {} successful, {} failed\", successCount, errors.size());\n\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Process a single exam slot row in a separate transaction.\n     * This ensures one row's failure doesn't affect others (partial success).\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneExamSlotRow(ExamSlotCsvRow row, ImportMode mode) {\n        // Parse datetime\n        LocalDateTime startTime = row.getStartTime();\n        LocalDateTime endTime = row.getEndTime();\n        if (startTime == null || endTime == null) {\n            throw new BadRequestException(\"Invalid datetime format\", ErrorCode.INVALID_TIME_FORMAT);\n        }\n\n        // Validate time range\n        if (!isEndTimeAfterStartTime(startTime, endTime)) {\n            throw new BadRequestException(\"End time must be after start time\", ErrorCode.START_TIME_AFTER_END_TIME);\n        }\n\n        // Validate slot duration (30 mins to 4 hours)\n        Duration duration = Duration.between(startTime, endTime);\n        long minutes = duration.toMinutes();\n        if (minutes < 30 || minutes > 240) {\n            throw new BadRequestException(\"Slot duration must be between 30 minutes and 4 hours\",\n                    ErrorCode.INVALID_SLOT_DURATION);\n        }\n\n        // Parse slot category (should be FINAL_EXAM)\n        SlotCategory slotCategory;\n        try {\n            slotCategory = SlotCategory.valueOf(row.getSlotCategory());\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(\"Invalid slot category: \" + row.getSlotCategory(),\n                    ErrorCode.INVALID_SLOT_CATEGORY);\n        }\n\n        if (slotCategory != SlotCategory.FINAL_EXAM) {\n            throw new BadRequestException(\"Exam slot import only supports FINAL_EXAM category\",\n                    ErrorCode.INVALID_SLOT_CATEGORY);\n        }\n\n        // Find semester\n        Semester semester = semesterRepository.findByCode(row.getSemesterCode());\n        if (semester == null) {\n            throw new ResourceNotFoundException(\n                    \"Semester not found with code: \" + row.getSemesterCode(),\n                    ErrorCode.SEMESTER_NOT_FOUND);\n        }\n        if (!semester.getActive()) {\n            throw new BadRequestException(\"Cannot create slot with inactive semester\",\n                    ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n        }\n\n        // Find room\n        var room = roomRepository.findByName(row.getRoomName());\n        if (room == null) {\n            throw new ResourceNotFoundException(\n                    \"Room not found with name: \" + row.getRoomName(),\n                    ErrorCode.ROOM_NOT_FOUND);\n        }\n        if (!room.getActive()) {\n            throw new BadRequestException(\"Cannot create slot with inactive room\",\n                    ErrorCode.INACTIVE_ROOM_NOT_ALLOWED);\n        }\n\n        // Find staff (eagerly fetch roles to avoid LazyInitializationException)\n        var staff = userRepository.findByUsernameWithRoles(row.getStaffUsername())\n                .orElseThrow(() -> new ResourceNotFoundException(\n                        \"Staff not found with username: \" + row.getStaffUsername(),\n                        ErrorCode.STAFF_NOT_FOUND));\n        if (!staff.getActive()) {\n            throw new BadRequestException(\"Cannot create slot with inactive staff\",\n                    ErrorCode.INACTIVE_STAFF_NOT_ALLOWED);\n        }\n\n        // Validate staff has LECTURER or SUPERVISOR role\n        boolean hasValidRole = staff.getRoles().stream()\n                .anyMatch(role -> role.getName().equals(\"LECTURER\") || role.getName().equals(\"SUPERVISOR\"));\n        if (!hasValidRole) {\n            throw new BadRequestException(\"Staff must have LECTURER or SUPERVISOR role\",\n                    ErrorCode.INVALID_STAFF_ROLE_FOR_SLOT);\n        }\n\n        // Validate subject_codes is not empty\n        List<String> subjectCodes = row.getSubjectCodeList();\n        if (subjectCodes.isEmpty()) {\n            throw new BadRequestException(\"subject_codes is required for FINAL_EXAM slots\",\n                    ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Check for room time conflicts\n        if (slotRepository.existsByRoomAndTimeRange(room.getId(), startTime, endTime, null)) {\n            throw new BadRequestException(\"Room is already booked for the specified time range\",\n                    ErrorCode.ROOM_TIME_CONFLICT);\n        }\n\n        // Check for staff time conflicts\n        if (slotRepository.existsByStaffAndTimeRange(staff.getId(), startTime, endTime, null)) {\n            throw new BadRequestException(\"Staff is already assigned to another slot for the specified time range\",\n                    ErrorCode.STAFF_TIME_CONFLICT);\n        }\n\n        // Create new exam slot (no class_id for FINAL_EXAM)\n        Slot slot = new Slot();\n        slot.setTitle(row.getTitle() != null && !row.getTitle().isEmpty() ? row.getTitle() : null);\n        slot.setStartTime(startTime);\n        slot.setEndTime(endTime);\n        slot.setSlotCategory(slotCategory);\n        slot.setSemester(semester);\n        slot.setRoom(room);\n        slot.setStaff(staff);\n        slot.setAcademicClass(null); // null for FINAL_EXAM\n        slot.setActive(true);\n        slot.setCreatedAt(Instant.now());\n        slot.setUpdatedAt(Instant.now());\n\n        Slot savedSlot = slotRepository.save(slot);\n\n        // Assign subjects to exam slot\n\n        for (String subjectCode : subjectCodes) {\n            // Find subject by code\n            Subject subject = subjectRepository.findByCode(subjectCode);\n            if (subject == null) {\n                throw new ResourceNotFoundException(\n                        \"Subject not found with code: \" + subjectCode,\n                        ErrorCode.SUBJECT_NOT_FOUND);\n            }\n\n            // Validate subject is active\n            if (!subject.getActive()) {\n                throw new BadRequestException(\n                        \"Cannot assign inactive subject: \" + subjectCode,\n                        ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n            }\n\n            // Check duplicate (defensive check)\n            Optional<ExamSlotSubject> existing = examSlotSubjectRepository\n                    .findBySlotIdAndSubjectId(savedSlot.getId(), subject.getId().intValue());\n            if (existing.isPresent() && existing.get().getIsActive()) {\n                throw new BadRequestException(\n                        \"Duplicate subject code in subject_codes: \" + subjectCode,\n                        ErrorCode.DUPLICATE_SUBJECTS_NOT_ALLOWED);\n            }\n\n            // Create or reactivate ExamSlotSubject\n            ExamSlotSubject examSlotSubject;\n            if (existing.isPresent()) {\n                examSlotSubject = existing.get();\n                examSlotSubject.setIsActive(true);\n            } else {\n                examSlotSubject = new ExamSlotSubject();\n                examSlotSubject.setSlot(savedSlot);\n                examSlotSubject.setSubject(subject);\n            }\n\n            examSlotSubjectRepository.save(examSlotSubject);\n        }\n\n        // Eager creation: Create initial exam attendance records for assigned participants\n        createInitialAttendanceRecords(savedSlot);\n\n    }\n\n    /**\n     * Extract error code from exception.\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n\n    @Transactional\n    public SlotAttendanceSubmissionResponse submitAttendance(Integer slotId,\n                                                             SlotAttendanceSubmissionRequest request, Integer currentUserId) {\n        // Validate slot exists\n        Slot slot = slotRepository.findById(slotId)\n                .orElseThrow(\n                        () -> new ResourceNotFoundException(\"Slot not found: \" + slotId, ErrorCode.SLOT_NOT_FOUND));\n\n        // Validate submissions array is not empty (already validated by @NotEmpty, but\n        // double-check)\n        if (request.getSubmissions() == null || request.getSubmissions().isEmpty()) {\n            throw new BadRequestException(\"Submissions array cannot be empty\", ErrorCode.EMPTY_SUBMISSIONS_ARRAY);\n        }\n\n        // Validate max submissions (already validated by @Size, but double-check)\n        if (request.getSubmissions().size() > 100) {\n            throw new BadRequestException(\"Maximum 100 submissions per request\", ErrorCode.TOO_MANY_SUBMISSIONS);\n        }\n\n        // Check authorization: either assigned staff OR Data Operator (after cutoff)\n        boolean isAssignedStaff = slot.getStaff().getId().equals(currentUserId);\n        boolean hasManualPermission = SecurityUtil.getUserAuthentication()\n                .map(com.fuacs.backend.config.UserAuthentication::getPermissions)\n                .map(p -> p.contains(\"ATTENDANCE_STATUS_UPDATE_MANUAL\"))\n                .orElse(false);\n\n        if (!isAssignedStaff && !hasManualPermission) {\n            throw new OperationNotAllowedException(\n                    \"You are not assigned to this slot and do not have permission to edit attendance\",\n                    ErrorCode.NOT_ASSIGNED_TO_SLOT);\n        }\n\n        // Validate edit window at slot level\n        validateEditWindowForSubmission(slot, isAssignedStaff, hasManualPermission);\n\n        // Get current user for remark creation\n        User currentUser = userRepository.findById(currentUserId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"User not found: \" + currentUserId,\n                        ErrorCode.USER_NOT_FOUND));\n\n        // Process submissions with partial success pattern\n        List<SlotAttendanceSubmissionResponse.AttendanceSubmissionResult> results = new ArrayList<>();\n        int successCount = 0;\n        int failureCount = 0;\n\n        // Track students who were explicitly set to non-NOT_YET status\n        // These should be excluded from bulk conversion\n        java.util.List<Integer> nonNotYetStudentIds = new java.util.ArrayList<>();\n\n        for (SlotAttendanceSubmissionRequest.AttendanceSubmissionItem submission : request.getSubmissions()) {\n            SlotAttendanceSubmissionResponse.AttendanceSubmissionResult result = new SlotAttendanceSubmissionResponse.AttendanceSubmissionResult();\n            result.setStudentUserId(submission.getStudentUserId());\n            result.setSuccess(false);\n\n            try {\n                // Process single submission\n                SlotAttendanceSubmissionResponse.UpdatedAttendanceRecords updatedRecords = processSingleSubmission(\n                        slot, submission, currentUser, isAssignedStaff, hasManualPermission, request.getAttendanceType());\n\n                result.setSuccess(true);\n                result.setUpdatedRecords(updatedRecords);\n                // Publish SSE updates for affected records\n                if (updatedRecords.getRegularAttendance() != null) {\n                    var r = updatedRecords.getRegularAttendance();\n                    tryPublish(slot.getId(), submission.getStudentUserId(), \"regular\",\n                            r.getId(), r.getStatus(), r.getMethod(),\n                            r.getRecordedAt() != null ? r.getRecordedAt().toString() : null, null);\n                }\n                if (updatedRecords.getExamAttendance() != null) {\n                    var e = updatedRecords.getExamAttendance();\n                    tryPublish(slot.getId(), submission.getStudentUserId(), \"exam\",\n                            e.getId(), e.getStatus(), e.getMethod(),\n                            e.getRecordedAt() != null ? e.getRecordedAt().toString() : null, null);\n                }\n                successCount++;\n\n                // Only exclude from bulk conversion if status is NOT \"not_yet\"\n                // Students with NOT_YET status (even with remark updates) should be included in bulk conversion\n                if (submission.getStatus() != AttendanceStatus.NOT_YET) {\n                    nonNotYetStudentIds.add(submission.getStudentUserId());\n                }\n            } catch (Exception e) {\n                result.setSuccess(false);\n                result.setErrorCode(extractErrorCode(e));\n                result.setErrorMessage(e.getMessage());\n                failureCount++;\n                logger.warn(\"Failed to process attendance submission for student {}: {}\", submission.getStudentUserId(),\n                        e.getMessage());\n            }\n\n            results.add(result);\n        }\n\n        // After processing all submissions, handle notYetResolution if provided\n        // This bulk-converts all remaining NOT_YET students (including those with remark-only updates)\n        if (request.getNotYetResolution() != null) {\n            int convertedCount = processNotYetResolution(slot, request.getNotYetResolution(),\n                                                          nonNotYetStudentIds, request.getAttendanceType());\n            logger.info(\"Batch converted {} NOT_YET students to {} for slot {}\",\n                        convertedCount, request.getNotYetResolution(), slot.getId());\n        }\n\n        // Clear all needs_review flags for this slot after successful submission\n        // This indicates that staff has reviewed and finalized all attendance records\n        List<AttendanceRecord> regularRecordsWithFlags = attendanceRecordRepository\n                .findBySlotIdAndNeedsReview(slot.getId(), true);\n        if (!regularRecordsWithFlags.isEmpty()) {\n            for (AttendanceRecord record : regularRecordsWithFlags) {\n                record.setNeedsReview(false);\n            }\n            attendanceRecordRepository.saveAll(regularRecordsWithFlags);\n            logger.info(\"Cleared needs_review flags for {} regular attendance records in slot {}\",\n                    regularRecordsWithFlags.size(), slot.getId());\n        }\n\n        List<ExamAttendance> examRecordsWithFlags = examAttendanceRepository\n                .findBySlotIdAndNeedsReview(slot.getId(), true);\n        if (!examRecordsWithFlags.isEmpty()) {\n            for (ExamAttendance record : examRecordsWithFlags) {\n                record.setNeedsReview(false);\n            }\n            examAttendanceRepository.saveAll(examRecordsWithFlags);\n            logger.info(\"Cleared needs_review flags for {} exam attendance records in slot {}\",\n                    examRecordsWithFlags.size(), slot.getId());\n        }\n\n        SlotAttendanceSubmissionResponse response = new SlotAttendanceSubmissionResponse(successCount, failureCount,\n                results);\n\n        return response;\n    }\n\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected SlotAttendanceSubmissionResponse.UpdatedAttendanceRecords processSingleSubmission(\n            Slot slot,\n            SlotAttendanceSubmissionRequest.AttendanceSubmissionItem submission,\n            User currentUser,\n            boolean isAssignedStaff,\n            boolean hasManualPermission,\n            String attendanceType) {\n\n        Integer studentUserId = submission.getStudentUserId();\n        AttendanceStatus newStatus = submission.getStatus();\n        String remark = submission.getRemark();\n\n        SlotAttendanceSubmissionResponse.UpdatedAttendanceRecords updatedRecords = new SlotAttendanceSubmissionResponse.UpdatedAttendanceRecords();\n\n        // Determine which attendance records to update based on slotCategory and attendanceType\n        SlotCategory slotCategory = slot.getSlotCategory();\n\n        if (slotCategory == SlotCategory.LECTURE) {\n            // Update attendance_records only\n            AttendanceRecord attendanceRecord = attendanceRecordRepository.findBySlotIdAndStudentUserId(\n                    slot.getId(), studentUserId);\n\n            // Graceful handling: Create record if missing (final safety net)\n            if (attendanceRecord == null) {\n                User student = userRepository.getReferenceById(studentUserId);\n                attendanceRecord = new AttendanceRecord();\n                attendanceRecord.setSlot(slot);\n                attendanceRecord.setStudent(student);\n                attendanceRecord.setStatus(AttendanceStatus.NOT_YET);\n                attendanceRecord.setMethod(AttendanceMethod.MANUAL);\n                attendanceRecord.setRecordedAt(Instant.now());\n                attendanceRecord = attendanceRecordRepository.save(attendanceRecord);\n                logger.warn(\"Created missing attendance record for student {} in slot {} during submission\",\n                        studentUserId, slot.getId());\n            }\n\n            // Validate student is enrolled (for class-based slots)\n            if (slot.getAcademicClass() != null) {\n                Short classId = slot.getAcademicClass().getId();\n                EnrollmentId enrollmentId = new EnrollmentId(classId, studentUserId);\n                boolean enrolled = enrollmentRepository.existsByIdAndIsEnrolled(enrollmentId, true);\n                if (!enrolled) {\n                    throw new OperationNotAllowedException(\"Student is not enrolled in this class\",\n                            ErrorCode.STUDENT_NOT_ENROLLED_IN_CLASS);\n                }\n            }\n\n            // Update attendance record\n            attendanceRecord.setStatus(newStatus);\n            attendanceRecord.setMethod(AttendanceMethod.MANUAL);\n            attendanceRecord.setRecordedAt(Instant.now());\n\n            // Set remark inline (overwrites existing remark)\n            if (remark != null && !remark.trim().isEmpty()) {\n                attendanceRecord.setRemark(remark.trim());\n            }\n\n            attendanceRecord = attendanceRecordRepository.save(attendanceRecord);\n\n            // Build response\n            SlotAttendanceSubmissionResponse.AttendanceRecordInfo regularInfo = new SlotAttendanceSubmissionResponse.AttendanceRecordInfo(\n                    attendanceRecord.getId(),\n                    attendanceRecord.getStatus().name().toLowerCase(),\n                    attendanceRecord.getMethod().name().toLowerCase(),\n                    attendanceRecord.getRecordedAt());\n            updatedRecords.setRegularAttendance(regularInfo);\n            updatedRecords.setExamAttendance(null);\n\n        } else if (slotCategory == SlotCategory.LECTURE_WITH_PT) {\n            // Check attendanceType to determine which record(s) to update\n            boolean updateRegular = (attendanceType == null || attendanceType.isEmpty() || \"REGULAR\".equalsIgnoreCase(attendanceType));\n            boolean updateExam = (attendanceType == null || attendanceType.isEmpty() || \"EXAM\".equalsIgnoreCase(attendanceType));\n\n            AttendanceRecord attendanceRecord = null;\n            ExamAttendance examAttendance = null;\n\n            // Validate student is enrolled (common for both)\n            if (slot.getAcademicClass() != null) {\n                Short classId = slot.getAcademicClass().getId();\n                EnrollmentId enrollmentId = new EnrollmentId(classId, studentUserId);\n                boolean enrolled = enrollmentRepository.existsByIdAndIsEnrolled(enrollmentId, true);\n                if (!enrolled) {\n                    throw new OperationNotAllowedException(\"Student is not enrolled in this class\",\n                            ErrorCode.STUDENT_NOT_ENROLLED_IN_CLASS);\n                }\n            }\n\n            // Update REGULAR attendance if needed\n            if (updateRegular) {\n                attendanceRecord = attendanceRecordRepository.findBySlotIdAndStudentUserId(\n                        slot.getId(), studentUserId);\n\n                // Graceful handling: Create record if missing (final safety net)\n                if (attendanceRecord == null) {\n                    User student = userRepository.getReferenceById(studentUserId);\n                    attendanceRecord = new AttendanceRecord();\n                    attendanceRecord.setSlot(slot);\n                    attendanceRecord.setStudent(student);\n                    attendanceRecord.setStatus(AttendanceStatus.NOT_YET);\n                    attendanceRecord.setMethod(AttendanceMethod.MANUAL);\n                    attendanceRecord.setRecordedAt(Instant.now());\n                    attendanceRecord = attendanceRecordRepository.save(attendanceRecord);\n                    logger.warn(\"Created missing attendance record for student {} in slot {} during submission\",\n                            studentUserId, slot.getId());\n                }\n\n                // Update attendance record\n                attendanceRecord.setStatus(newStatus);\n                attendanceRecord.setMethod(AttendanceMethod.MANUAL);\n                attendanceRecord.setRecordedAt(Instant.now());\n\n                // Set remark inline (overwrites existing remark)\n                if (remark != null && !remark.trim().isEmpty()) {\n                    attendanceRecord.setRemark(remark.trim());\n                }\n\n                attendanceRecord = attendanceRecordRepository.save(attendanceRecord);\n            }\n\n            // Update EXAM attendance if needed\n            if (updateExam) {\n                examAttendance = examAttendanceRepository.findBySlotIdAndStudentUserId(\n                        slot.getId(), studentUserId);\n\n                // Graceful handling: Create record if missing (final safety net)\n                if (examAttendance == null) {\n                    User student = userRepository.getReferenceById(studentUserId);\n                    examAttendance = new ExamAttendance();\n                    examAttendance.setSlot(slot);\n                    examAttendance.setStudent(student);\n                    examAttendance.setStatus(AttendanceStatus.NOT_YET);\n                    examAttendance.setMethod(AttendanceMethod.MANUAL);\n                    examAttendance.setRecordedAt(Instant.now());\n                    examAttendance = examAttendanceRepository.save(examAttendance);\n                    logger.warn(\"Created missing exam attendance record for student {} in slot {} during submission\",\n                            studentUserId, slot.getId());\n                }\n\n                // Update exam attendance\n                examAttendance.setStatus(newStatus);\n                examAttendance.setMethod(AttendanceMethod.MANUAL);\n                examAttendance.setRecordedAt(Instant.now());\n\n                // Set remark inline (overwrites existing remark)\n                if (remark != null && !remark.trim().isEmpty()) {\n                    examAttendance.setRemark(remark.trim());\n                }\n\n                examAttendance = examAttendanceRepository.save(examAttendance);\n            }\n\n            // Build response\n            SlotAttendanceSubmissionResponse.AttendanceRecordInfo regularInfo = null;\n            if (attendanceRecord != null) {\n                regularInfo = new SlotAttendanceSubmissionResponse.AttendanceRecordInfo(\n                        attendanceRecord.getId(),\n                        attendanceRecord.getStatus().name().toLowerCase(),\n                        attendanceRecord.getMethod().name().toLowerCase(),\n                        attendanceRecord.getRecordedAt());\n            }\n\n            SlotAttendanceSubmissionResponse.AttendanceRecordInfo examInfo = null;\n            if (examAttendance != null) {\n                examInfo = new SlotAttendanceSubmissionResponse.AttendanceRecordInfo(\n                        examAttendance.getId(),\n                        examAttendance.getStatus().name().toLowerCase(),\n                        examAttendance.getMethod().name().toLowerCase(),\n                        examAttendance.getRecordedAt());\n            }\n\n            updatedRecords.setRegularAttendance(regularInfo);\n            updatedRecords.setExamAttendance(examInfo);\n\n        } else if (slotCategory == SlotCategory.FINAL_EXAM) {\n            // Update exam_attendance only\n            ExamAttendance examAttendance = examAttendanceRepository.findBySlotIdAndStudentUserId(\n                    slot.getId(), studentUserId);\n\n            // Graceful handling: Create record if missing (final safety net)\n            if (examAttendance == null) {\n                User student = userRepository.getReferenceById(studentUserId);\n                examAttendance = new ExamAttendance();\n                examAttendance.setSlot(slot);\n                examAttendance.setStudent(student);\n                examAttendance.setStatus(AttendanceStatus.NOT_YET);\n                examAttendance.setMethod(AttendanceMethod.MANUAL);\n                examAttendance.setRecordedAt(Instant.now());\n                examAttendance = examAttendanceRepository.save(examAttendance);\n                logger.warn(\"Created missing exam attendance record for student {} in slot {} during submission\",\n                        studentUserId, slot.getId());\n            }\n\n            // Update exam attendance\n            examAttendance.setStatus(newStatus);\n            examAttendance.setMethod(AttendanceMethod.MANUAL);\n            examAttendance.setRecordedAt(Instant.now());\n\n            // Set remark inline (overwrites existing remark)\n            if (remark != null && !remark.trim().isEmpty()) {\n                examAttendance.setRemark(remark.trim());\n            }\n\n            examAttendance = examAttendanceRepository.save(examAttendance);\n\n            // Build response\n            SlotAttendanceSubmissionResponse.AttendanceRecordInfo examInfo = new SlotAttendanceSubmissionResponse.AttendanceRecordInfo(\n                    examAttendance.getId(),\n                    examAttendance.getStatus().name().toLowerCase(),\n                    examAttendance.getMethod().name().toLowerCase(),\n                    examAttendance.getRecordedAt());\n            updatedRecords.setRegularAttendance(null);\n            updatedRecords.setExamAttendance(examInfo);\n        }\n\n        return updatedRecords;\n    }\n\n    /**\n     * Bulk-convert all remaining NOT_YET students to the specified status.\n     * Excludes students already updated in the current submission.\n     *\n     * @param slot The slot to process\n     * @param resolution The resolution strategy (MARK_AS_ABSENT or MARK_AS_PRESENT)\n     * @param excludedStudentIds List of student IDs already updated in this submission\n     * @param attendanceType Which attendance type to update (for LECTURE_WITH_PT)\n     * @return Number of students converted\n     */\n    private int processNotYetResolution(Slot slot, com.fuacs.backend.constant.enums.NotYetResolution resolution,\n                                       List<Integer> excludedStudentIds, String attendanceType) {\n        // Determine target status\n        AttendanceStatus targetStatus = (resolution == com.fuacs.backend.constant.enums.NotYetResolution.MARK_AS_ABSENT)\n                ? AttendanceStatus.ABSENT\n                : AttendanceStatus.PRESENT;\n\n        Instant now = Instant.now();\n        int convertedCount = 0;\n        SlotCategory slotCategory = slot.getSlotCategory();\n\n        if (slotCategory == SlotCategory.LECTURE) {\n            // Update attendance_records only\n            List<AttendanceRecord> notYetRecords = attendanceRecordRepository\n                    .findBySlotIdAndStatus(slot.getId(), AttendanceStatus.NOT_YET);\n\n            // Filter out excluded students\n            List<AttendanceRecord> toUpdate = notYetRecords.stream()\n                    .filter(r -> !excludedStudentIds.contains(r.getStudent().getId()))\n                    .collect(Collectors.toList());\n\n            // Update records\n            for (AttendanceRecord record : toUpdate) {\n                record.setStatus(targetStatus);\n                record.setMethod(AttendanceMethod.MANUAL);\n                record.setRecordedAt(now);\n\n                // Publish SSE\n                tryPublish(slot.getId(), record.getStudent().getId(), \"regular\",\n                        record.getId(), targetStatus.name().toLowerCase(),\n                        AttendanceMethod.MANUAL.name().toLowerCase(),\n                        now.toString(), null);\n            }\n\n            if (!toUpdate.isEmpty()) {\n                attendanceRecordRepository.saveAll(toUpdate);\n                convertedCount += toUpdate.size();\n            }\n\n        } else if (slotCategory == SlotCategory.LECTURE_WITH_PT) {\n            // Determine which record(s) to update\n            boolean updateRegular = (attendanceType == null || attendanceType.isEmpty()\n                    || \"REGULAR\".equalsIgnoreCase(attendanceType));\n            boolean updateExam = (attendanceType == null || attendanceType.isEmpty()\n                    || \"EXAM\".equalsIgnoreCase(attendanceType));\n\n            // Update REGULAR attendance if needed\n            if (updateRegular) {\n                List<AttendanceRecord> notYetRecords = attendanceRecordRepository\n                        .findBySlotIdAndStatus(slot.getId(), AttendanceStatus.NOT_YET);\n\n                List<AttendanceRecord> toUpdate = notYetRecords.stream()\n                        .filter(r -> !excludedStudentIds.contains(r.getStudent().getId()))\n                        .collect(Collectors.toList());\n\n                for (AttendanceRecord record : toUpdate) {\n                    record.setStatus(targetStatus);\n                    record.setMethod(AttendanceMethod.MANUAL);\n                    record.setRecordedAt(now);\n\n                    tryPublish(slot.getId(), record.getStudent().getId(), \"regular\",\n                            record.getId(), targetStatus.name().toLowerCase(),\n                            AttendanceMethod.MANUAL.name().toLowerCase(),\n                            now.toString(), null);\n                }\n\n                if (!toUpdate.isEmpty()) {\n                    attendanceRecordRepository.saveAll(toUpdate);\n                    convertedCount += toUpdate.size();\n                }\n            }\n\n            // Update EXAM attendance if needed\n            if (updateExam) {\n                List<ExamAttendance> notYetRecords = examAttendanceRepository\n                        .findBySlotIdAndStatus(slot.getId(), AttendanceStatus.NOT_YET);\n\n                List<ExamAttendance> toUpdate = notYetRecords.stream()\n                        .filter(r -> !excludedStudentIds.contains(r.getStudent().getId()))\n                        .collect(Collectors.toList());\n\n                for (ExamAttendance record : toUpdate) {\n                    record.setStatus(targetStatus);\n                    record.setMethod(AttendanceMethod.MANUAL);\n                    record.setRecordedAt(now);\n\n                    tryPublish(slot.getId(), record.getStudent().getId(), \"exam\",\n                            record.getId(), targetStatus.name().toLowerCase(),\n                            AttendanceMethod.MANUAL.name().toLowerCase(),\n                            now.toString(), null);\n                }\n\n                if (!toUpdate.isEmpty()) {\n                    examAttendanceRepository.saveAll(toUpdate);\n                    convertedCount += toUpdate.size();\n                }\n            }\n\n        } else if (slotCategory == SlotCategory.FINAL_EXAM) {\n            // Update exam_attendance only\n            List<ExamAttendance> notYetRecords = examAttendanceRepository\n                    .findBySlotIdAndStatus(slot.getId(), AttendanceStatus.NOT_YET);\n\n            List<ExamAttendance> toUpdate = notYetRecords.stream()\n                    .filter(r -> !excludedStudentIds.contains(r.getStudent().getId()))\n                    .collect(Collectors.toList());\n\n            for (ExamAttendance record : toUpdate) {\n                record.setStatus(targetStatus);\n                record.setMethod(AttendanceMethod.MANUAL);\n                record.setRecordedAt(now);\n\n                tryPublish(slot.getId(), record.getStudent().getId(), \"exam\",\n                        record.getId(), targetStatus.name().toLowerCase(),\n                        AttendanceMethod.MANUAL.name().toLowerCase(),\n                        now.toString(), null);\n            }\n\n            if (!toUpdate.isEmpty()) {\n                examAttendanceRepository.saveAll(toUpdate);\n                convertedCount += toUpdate.size();\n            }\n        }\n\n        return convertedCount;\n    }\n\n    private void validateEditWindowForSubmission(Slot slot, boolean isAssignedStaff, boolean hasManualPermission) {\n        // Convert LocalDateTime to ZonedDateTime with Vietnam timezone\n        LocalDateTime slotStartTime = slot.getStartTime();\n        ZonedDateTime slotStartTimeVN = slotStartTime.atZone(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        LocalDate slotDateVN = slotStartTimeVN.toLocalDate();\n\n        // Create cutoff at 23:59:59 Vietnam time on the slot date\n        ZonedDateTime cutoffVN = slotDateVN.atTime(23, 59, 59).atZone(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n        ZonedDateTime nowVN = ZonedDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n\n        if (nowVN.isBefore(slotStartTimeVN)) {\n            throw new OperationNotAllowedException(\n                    \"Cannot edit attendance before slot start time\",\n                    ErrorCode.EDIT_BEFORE_SLOT_START);\n        }\n\n        if (nowVN.isAfter(cutoffVN)) {\n            // After cutoff: only Data Operator can edit\n            if (!hasManualPermission) {\n                throw new OperationNotAllowedException(\n                        \"Edit window has expired. Only Data Operator can edit attendance after 23:59:59 Vietnam time of slot date\",\n                        ErrorCode.EDIT_WINDOW_EXPIRED);\n            }\n        } else {\n            // Before cutoff: only assigned staff can edit\n            if (!isAssignedStaff) {\n                throw new OperationNotAllowedException(\n                        \"You are not assigned to this slot. Only assigned staff can edit attendance before the cutoff\",\n                        ErrorCode.NOT_ASSIGNED_TO_SLOT);\n            }\n        }\n    }\n\n    private void tryPublish(Integer slotId,\n                            Integer studentUserId,\n                            String kind,\n                            Long recordId,\n                            String status,\n                            String method,\n                            String recordedAt,\n                            String evidenceImageUrl) {\n        try {\n            AttendanceUpdateEvent evt = new AttendanceUpdateEvent(\n                    slotId,\n                    studentUserId,\n                    kind,\n                    recordId,\n                    status,\n                    method,\n                    recordedAt,\n                    evidenceImageUrl\n            );\n            sseHub.publishAttendanceUpdate(slotId, evt);\n        } catch (Exception e) {\n            logger.warn(\"Failed to publish SSE from submission: {}\", e.getMessage());\n        }\n    }\n\n    /**\n     * Helper: Create initial attendance records for a slot (eager creation).\n     * Called after slot is created. Uses roster query to get students, then creates missing records.\n     *\n     * @param slot The newly created slot\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void createInitialAttendanceRecords(Slot slot) {\n        try {\n            // Get roster to find students\n            List<SlotRosterItemDTO> roster = slotRepository.getSlotRoster(slot.getId());\n\n            if (roster.isEmpty()) {\n                return;\n            }\n\n            // Create missing attendance records\n            int created = ensureAttendanceRecordsExist(slot, roster);\n\n            if (created > 0) {\n                logger.info(\"Eager created {} attendance records for slot {}\", created, slot.getId());\n            }\n        } catch (Exception e) {\n            // Don't fail slot creation if attendance record creation fails\n            logger.error(\"Failed to create initial attendance records for slot {}: {}\", slot.getId(), e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Helper: Ensure all students in roster have attendance records (lazy fallback).\n     * Called from getSlotRoster() to handle edge cases like late enrollments or missing records.\n     *\n     * @param slot The slot\n     * @param roster The roster items (may have null attendance records)\n     * @return Number of records created\n     */\n    private int ensureAttendanceRecordsExist(Slot slot, List<SlotRosterItemDTO> roster) {\n        SlotCategory category = slot.getSlotCategory();\n\n        // Skip lazy creation for FINAL_EXAM - attendance records are created when adding participants\n        if (category == SlotCategory.FINAL_EXAM) {\n            return 0;\n        }\n\n        Instant now = Instant.now();\n        int createdCount = 0;\n\n        List<AttendanceRecord> attendanceRecordsToCreate = new ArrayList<>();\n        List<ExamAttendance> examAttendancesToCreate = new ArrayList<>();\n\n        for (SlotRosterItemDTO item : roster) {\n            Integer studentUserId = item.getStudent().getUserId();\n\n            // Check if regular attendance record is missing\n            if (category != SlotCategory.FINAL_EXAM && item.getRegularAttendance() == null) {\n                // Create missing regular attendance record\n                User student = userRepository.getReferenceById(studentUserId);\n                AttendanceRecord record = new AttendanceRecord();\n                record.setSlot(slot);\n                record.setStudent(student);\n                record.setStatus(AttendanceStatus.NOT_YET);\n                record.setMethod(AttendanceMethod.MANUAL);\n                record.setRecordedAt(now);\n                attendanceRecordsToCreate.add(record);\n            }\n\n            // Check if exam attendance record is missing\n            if (category != SlotCategory.LECTURE && item.getExamAttendance() == null) {\n                // Create missing exam attendance record\n                User student = userRepository.getReferenceById(studentUserId);\n                ExamAttendance record = new ExamAttendance();\n                record.setSlot(slot);\n                record.setStudent(student);\n                record.setStatus(AttendanceStatus.NOT_YET);\n                record.setMethod(AttendanceMethod.MANUAL);\n                record.setRecordedAt(now);\n                examAttendancesToCreate.add(record);\n            }\n        }\n\n        // Batch save missing records\n        if (!attendanceRecordsToCreate.isEmpty()) {\n            try {\n                attendanceRecordRepository.saveAll(attendanceRecordsToCreate);\n                createdCount += attendanceRecordsToCreate.size();\n            } catch (DataIntegrityViolationException e) {\n                // Ignore duplicate key violations (race condition with concurrent requests)\n            }\n        }\n\n        if (!examAttendancesToCreate.isEmpty()) {\n            try {\n                examAttendanceRepository.saveAll(examAttendancesToCreate);\n                createdCount += examAttendancesToCreate.size();\n            } catch (DataIntegrityViolationException e) {\n                // Ignore duplicate key violations (race condition with concurrent requests)\n            }\n        }\n\n        return createdCount;\n    }\n\n    /**\n     * Check if slot has any attendance records that have been marked (PRESENT or ABSENT).\n     * Used to determine if slot details should be view-only.\n     *\n     * Note: Ignores NOT_YET records as they are auto-created on first roster access.\n     * Only checks for records that have been actually marked by staff or auto-recognition.\n     */\n    @Transactional(readOnly = true)\n    public boolean hasAttendanceRecords(Integer slotId) {\n        // Check if slot exists\n        if (!slotRepository.existsById(slotId)) {\n            throw new ResourceNotFoundException(\"Slot not found with ID: \" + slotId, ErrorCode.SLOT_NOT_FOUND);\n        }\n\n        // Check regular attendance records with PRESENT or ABSENT status\n        Long regularPresentCount = attendanceRecordRepository.countBySlotIdAndStatus(slotId, AttendanceStatus.PRESENT);\n        Long regularAbsentCount = attendanceRecordRepository.countBySlotIdAndStatus(slotId, AttendanceStatus.ABSENT);\n\n        if (regularPresentCount > 0 || regularAbsentCount > 0) {\n            return true;\n        }\n\n        // Check exam attendance records with PRESENT or ABSENT status\n        Long examPresentCount = examAttendanceRepository.countBySlotIdAndStatus(slotId, AttendanceStatus.PRESENT);\n        Long examAbsentCount = examAttendanceRepository.countBySlotIdAndStatus(slotId, AttendanceStatus.ABSENT);\n\n        return examPresentCount > 0 || examAbsentCount > 0;\n    }\n\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\SlotSessionService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/SlotSessionService.java",
      "filename": "SlotSessionService.java",
      "size_bytes": 38165,
      "lines": 692,
      "last_modified": "2025-11-11T13:25:56.796596",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.config.FaceRecognitionProperties;\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.enums.ScanMode;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.dto.request.python.PythonStartSessionRequest;\nimport com.fuacs.backend.dto.response.PythonSessionResponse;\nimport com.fuacs.backend.dto.response.SessionStatusResponse;\nimport com.fuacs.backend.entity.Camera;\nimport com.fuacs.backend.entity.Enrollment;\nimport com.fuacs.backend.entity.ExamSlotParticipant;\nimport com.fuacs.backend.entity.Slot;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.AttendanceRecordRepository;\nimport com.fuacs.backend.repository.CameraRepository;\nimport com.fuacs.backend.repository.EnrollmentRepository;\nimport com.fuacs.backend.repository.ExamAttendanceRepository;\nimport com.fuacs.backend.repository.ExamSlotParticipantRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * Service for managing face recognition sessions\n * Orchestrates slot session lifecycle: start, stop, rescan, finalize\n */\n@Service\npublic class SlotSessionService {\n\n        private static final Logger logger = LoggerFactory.getLogger(SlotSessionService.class);\n\n        private final SlotRepository slotRepository;\n        private final EnrollmentRepository enrollmentRepository;\n        private final ExamSlotParticipantRepository examSlotParticipantRepository;\n        private final CameraRepository cameraRepository;\n        private final FaceEmbeddingService faceEmbeddingService;\n        private final PythonBackendClient pythonBackendClient;\n        private final AttendanceRecordService attendanceRecordService;\n        private final ExamAttendanceService examAttendanceService;\n        private final AttendanceRecordRepository attendanceRecordRepository;\n        private final ExamAttendanceRepository examAttendanceRepository;\n        private final FaceRecognitionProperties faceRecognitionProperties;\n\n        @Value(\"${server.port:8080}\")\n        private String serverPort;\n\n        public SlotSessionService(SlotRepository slotRepository,\n                        EnrollmentRepository enrollmentRepository,\n                        ExamSlotParticipantRepository examSlotParticipantRepository,\n                        CameraRepository cameraRepository,\n                        FaceEmbeddingService faceEmbeddingService,\n                        PythonBackendClient pythonBackendClient,\n                        AttendanceRecordService attendanceRecordService,\n                        ExamAttendanceService examAttendanceService,\n                        AttendanceRecordRepository attendanceRecordRepository,\n                        ExamAttendanceRepository examAttendanceRepository,\n                        FaceRecognitionProperties faceRecognitionProperties) {\n                this.slotRepository = slotRepository;\n                this.enrollmentRepository = enrollmentRepository;\n                this.examSlotParticipantRepository = examSlotParticipantRepository;\n                this.cameraRepository = cameraRepository;\n                this.faceEmbeddingService = faceEmbeddingService;\n                this.pythonBackendClient = pythonBackendClient;\n                this.attendanceRecordService = attendanceRecordService;\n                this.examAttendanceService = examAttendanceService;\n                this.attendanceRecordRepository = attendanceRecordRepository;\n                this.examAttendanceRepository = examAttendanceRepository;\n                this.faceRecognitionProperties = faceRecognitionProperties;\n        }\n\n        @Transactional\n        public SessionStatusResponse startSession(Integer slotId, Integer currentUserId, ScanMode mode) {\n                logger.info(\"Starting face recognition session: slotId={}, userId={}, mode={}\", slotId, currentUserId,\n                                mode);\n\n                // Step 1: Validate slot exists\n                Slot slot = slotRepository.findById(slotId)\n                                .orElseThrow(() -> new ResourceNotFoundException(\n                                                \"Slot not found: \" + slotId,\n                                                ErrorCode.SLOT_NOT_FOUND));\n\n                // Check user is assigned to this slot\n                if (!slot.getStaff().getId().equals(currentUserId)) {\n                        throw new OperationNotAllowedException(\n                                        \"You are not assigned to this slot\",\n                                        ErrorCode.NOT_ASSIGNED_TO_SLOT);\n                }\n\n                // Check if slot is active\n                if (!slot.getActive()) {\n                        throw new BadRequestException(\n                                        \"Cannot start session for inactive slot\",\n                                        ErrorCode.INACTIVE_SLOT_NOT_ALLOWED);\n                }\n\n                // Step 3: Get students with embeddings\n                List<StudentWithEmbedding> studentsWithEmbeddings = getStudentsWithEmbeddings(slot);\n\n                if (studentsWithEmbeddings.isEmpty()) {\n                        logger.warn(\"No students with active embeddings found for slotId={}\", slotId);\n                        throw new BadRequestException(\n                                        \"No students with face embeddings found for this slot\",\n                                        ErrorCode.STUDENT_NO_FACE_EMBEDDING);\n                }\n\n                logger.info(\"Found {} students with active embeddings for slotId={}\",\n                                studentsWithEmbeddings.size(), slotId);\n\n                // Step 4: Get active cameras for room\n                List<Camera> cameras = cameraRepository.findByRoom_Id(slot.getRoom().getId())\n                                .stream()\n                                .filter(Camera::getActive)\n                                .collect(java.util.stream.Collectors.toList());\n\n                if (cameras.isEmpty()) {\n                        throw new BadRequestException(\n                                        \"No active cameras configured for room: \" + slot.getRoom().getName(),\n                                        ErrorCode.CAMERA_NOT_FOUND);\n                }\n\n                logger.info(\"Found {} active cameras for room: {}\", cameras.size(), slot.getRoom().getName());\n\n                // Step 5: Build Python backend request\n                PythonStartSessionRequest pythonRequest = buildPythonRequest(\n                                slot,\n                                studentsWithEmbeddings,\n                                cameras,\n                                mode);\n\n                // Step 6: Call Python backend\n                PythonSessionResponse pythonResponse = pythonBackendClient.startRecognitionSession(pythonRequest);\n\n                // Step 7: Build and return response\n                SessionStatusResponse response = buildSessionStatusResponse(slot, pythonResponse,\n                                studentsWithEmbeddings.size());\n\n                return response;\n        }\n\n        /**\n         * Stop face recognition session for a slot\n         *\n         * @param slotId        Slot ID\n         * @param currentUserId Current user ID\n         * @return Session status with statistics\n         */\n        @Transactional\n        public SessionStatusResponse stopSession(Integer slotId, Integer currentUserId) {\n                logger.info(\"Stopping face recognition session: slotId={}, userId={}\", slotId, currentUserId);\n\n                // Validate slot and authorization\n                Slot slot = slotRepository.findById(slotId)\n                                .orElseThrow(() -> new ResourceNotFoundException(\n                                                \"Slot not found: \" + slotId,\n                                                ErrorCode.SLOT_NOT_FOUND));\n\n                if (!slot.getStaff().getId().equals(currentUserId)) {\n                        throw new OperationNotAllowedException(\n                                        \"You are not assigned to this slot\",\n                                        ErrorCode.NOT_ASSIGNED_TO_SLOT);\n                }\n\n                // Try to call Python backend to stop session (graceful degradation if service unavailable)\n                PythonSessionResponse pythonResponse = null;\n                try {\n                        pythonResponse = pythonBackendClient.stopRecognitionSession(slotId);\n                } catch (Exception e) {\n                        logger.warn(\"Failed to stop Python session (service may be down): slotId={}, error={}\",\n                                        slotId, e.getMessage());\n                        // Continue - will still update DB to STOPPED\n                }\n\n                // ALWAYS update session metadata (regardless of Python success/fail)\n                slot.setSessionStatus(com.fuacs.backend.constant.enums.SessionStatus.STOPPED);\n                slot.setLastSessionStoppedAt(java.time.Instant.now());\n                slotRepository.save(slot);\n\n                // NEW: Apply RESCAN review flags after session stops\n                // This logic sets needsReview flags based on attendance mismatches:\n                // - Sets needsReview=true for PRESENT students not detected (potential early departure)\n                // - Sets needsReview=true for ABSENT students detected (late arrival or manual error)\n                // - Clears needsReview=false for confirmed PRESENT students\n                if (pythonResponse != null && pythonResponse.getData() != null && \"RESCAN\".equals(pythonResponse.getData().getMode())) {\n                        List<Integer> recognizedStudentIds = pythonResponse.getData().getRecognizedStudentIds();\n\n                        // Convert to Set (handle null/empty list)\n                        Set<Integer> detectedStudentIds = recognizedStudentIds != null\n                                        ? new HashSet<>(recognizedStudentIds)\n                                        : new HashSet<>();\n\n                        logger.info(\"Applying RESCAN review flags: slot={}, detectedCount={}\",\n                                        slotId, detectedStudentIds.size());\n\n                        // Apply review flags for students with attendance mismatches\n                        Map<String, Object> reviewResult = attendanceRecordService.applyRescanReviewFlags(slot,\n                                        detectedStudentIds);\n\n                        logger.info(\"RESCAN review flags applied: {}\", reviewResult);\n                }\n                // Auto-finalize NOT_YET → ABSENT for INITIAL mode\n                // This prevents staff from forgetting to explicitly mark absent students\n                if (pythonResponse != null && pythonResponse.getData() != null && \"INITIAL\".equals(pythonResponse.getData().getMode())) {\n                        logger.info(\"Auto-finalizing NOT_YET students to ABSENT: slotId={}\", slotId);\n\n                        // Find all NOT_YET records for this slot\n                        List<com.fuacs.backend.entity.AttendanceRecord> notYetRecords =\n                                attendanceRecordRepository.findBySlotIdAndStatus(slotId,\n                                        com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET);\n\n                        int finalizedCount = 0;\n                        for (com.fuacs.backend.entity.AttendanceRecord record : notYetRecords) {\n                                record.setStatus(com.fuacs.backend.constant.enums.AttendanceStatus.ABSENT);\n                                record.setMethod(com.fuacs.backend.constant.enums.AttendanceMethod.SYSTEM_FINALIZE);\n                                record.setRecordedAt(java.time.Instant.now());\n                                finalizedCount++;\n                        }\n\n                        if (!notYetRecords.isEmpty()) {\n                                attendanceRecordRepository.saveAll(notYetRecords);\n                                logger.info(\"Auto-finalized {} NOT_YET students to ABSENT for slot {}\",\n                                        finalizedCount, slotId);\n                        }\n                }\n\n                // Build response\n                SessionStatusResponse response = new SessionStatusResponse();\n                response.setSlotId(slotId);\n                response.setSessionStatus(\"STOPPED\");\n                response.setMessage(pythonResponse != null\n                                ? \"Face recognition session stopped successfully\"\n                                : \"Session stopped (Python service unavailable)\");\n\n                // Set statistics only if Python response available\n                if (pythonResponse != null && pythonResponse.getData() != null) {\n                        response.setSessionStoppedAt(pythonResponse.getData().getSessionStoppedAt());\n                        response.setTotalRecognitions(pythonResponse.getData().getTotalRecognitions());\n                }\n\n                logger.info(\"Face recognition session stopped: slotId={}, pythonAvailable={}\",\n                                slotId, pythonResponse != null);\n\n                return response;\n        }\n\n        // ========== Exam Session Methods (LECTURE_WITH_PT & FINAL_EXAM) ==========\n\n        /**\n         * Start exam session for LECTURE_WITH_PT or FINAL_EXAM slots\n         * Similar to regular session but uses exam session fields\n         */\n        @Transactional\n        public SessionStatusResponse startExamSession(Integer slotId, Integer currentUserId) {\n                logger.info(\"Starting exam session: slotId={}, userId={}\", slotId, currentUserId);\n\n                // Validate slot and authorization\n                Slot slot = slotRepository.findById(slotId)\n                                .orElseThrow(() -> new ResourceNotFoundException(\n                                                \"Slot not found: \" + slotId,\n                                                ErrorCode.SLOT_NOT_FOUND));\n\n                if (!slot.getStaff().getId().equals(currentUserId)) {\n                        throw new OperationNotAllowedException(\n                                        \"You are not assigned to this slot\",\n                                        ErrorCode.NOT_ASSIGNED_TO_SLOT);\n                }\n\n                // Check if slot is active\n                if (!slot.getActive()) {\n                        throw new BadRequestException(\n                                        \"Cannot start exam session for inactive slot\",\n                                        ErrorCode.INACTIVE_SLOT_NOT_ALLOWED);\n                }\n\n                // Get students with active embeddings\n                List<StudentWithEmbedding> studentsWithEmbeddings = getStudentsWithEmbeddings(slot);\n                logger.info(\"Found {} students with active face embeddings for slot {}\",\n                                studentsWithEmbeddings.size(), slotId);\n\n                // Validate: Check if students list is empty\n                if (studentsWithEmbeddings.isEmpty()) {\n                        throw new BadRequestException(\n                                        \"Cannot start exam session: No enrolled students with valid face embeddings found for this slot.\",\n                                        ErrorCode.NO_STUDENTS_FOR_EXAM_SESSION);\n                }\n\n                // Validate: Get active cameras for room\n                List<Camera> cameras = cameraRepository.findByRoom_Id(slot.getRoom().getId())\n                                .stream()\n                                .filter(Camera::getActive)\n                                .collect(java.util.stream.Collectors.toList());\n\n                if (cameras.isEmpty()) {\n                        throw new BadRequestException(\n                                        \"No active cameras configured for room: \" + slot.getRoom().getName(),\n                                        ErrorCode.CAMERA_NOT_FOUND);\n                }\n\n                logger.info(\"Found {} active cameras for room: {}\", cameras.size(), slot.getRoom().getName());\n\n                // Build Python request with EXAM mode\n                PythonStartSessionRequest request = buildPythonRequestForExam(slot, studentsWithEmbeddings, \"INITIAL\");\n\n                // Call Python backend to start session\n                PythonSessionResponse pythonResponse;\n                try {\n                        pythonResponse = pythonBackendClient.startRecognitionSession(request);\n                } catch (Exception e) {\n                        logger.error(\"Failed to start Python exam session: slotId={}, error={}\", slotId, e.getMessage(), e);\n                        throw new BadRequestException(\n                                        \"Failed to start exam session: \" + e.getMessage(),\n                                        ErrorCode.SESSION_START_FAILED);\n                }\n\n                // Build response\n                SessionStatusResponse response = buildSessionStatusResponse(slot, pythonResponse,\n                                studentsWithEmbeddings.size());\n\n                return response;\n        }\n\n        /**\n         * Stop exam session\n         * Sets needsReview flags for attendance discrepancies\n         */\n        @Transactional\n        public SessionStatusResponse stopExamSession(Integer slotId, Integer currentUserId) {\n                logger.info(\"Stopping exam session: slotId={}, userId={}\", slotId, currentUserId);\n\n                // Validate slot and authorization\n                Slot slot = slotRepository.findById(slotId)\n                                .orElseThrow(() -> new ResourceNotFoundException(\n                                                \"Slot not found: \" + slotId,\n                                                ErrorCode.SLOT_NOT_FOUND));\n\n                if (!slot.getStaff().getId().equals(currentUserId)) {\n                        throw new OperationNotAllowedException(\n                                        \"You are not assigned to this slot\",\n                                        ErrorCode.NOT_ASSIGNED_TO_SLOT);\n                }\n\n                // Try to call Python backend to stop session\n                PythonSessionResponse pythonResponse = null;\n                try {\n                        pythonResponse = pythonBackendClient.stopRecognitionSession(slotId);\n                } catch (Exception e) {\n                        logger.warn(\"Failed to stop Python exam session (service may be down): slotId={}, error={}\",\n                                        slotId, e.getMessage());\n                        // Continue - will still update DB to STOPPED\n                }\n\n                // ALWAYS update exam session metadata\n                slot.setExamSessionStatus(com.fuacs.backend.constant.enums.SessionStatus.STOPPED);\n                slot.setLastExamSessionStoppedAt(java.time.Instant.now());\n                slotRepository.save(slot);\n\n                // NEW: Apply RESCAN review flags for EXAM sessions after session stops\n                // For EXAM: Only flag PRESENT students who were not detected (potential early departure)\n                if (pythonResponse != null && pythonResponse.getData() != null && \"RESCAN\".equals(pythonResponse.getData().getMode())) {\n                        List<Integer> recognizedStudentIds = pythonResponse.getData().getRecognizedStudentIds();\n\n                        // Convert to Set (handle null/empty list)\n                        Set<Integer> detectedStudentIds = recognizedStudentIds != null\n                                        ? new HashSet<>(recognizedStudentIds)\n                                        : new HashSet<>();\n\n                        logger.info(\"Applying RESCAN review flags (EXAM): slot={}, detectedCount={}\",\n                                        slotId, detectedStudentIds.size());\n\n                        // Apply review flags for students with attendance mismatches\n                        Map<String, Object> reviewResult = examAttendanceService.applyRescanReviewFlags(slot,\n                                        detectedStudentIds);\n\n                        logger.info(\"RESCAN review flags applied (EXAM): {}\", reviewResult);\n                }\n\n                // Auto-finalize NOT_YET → ABSENT for INITIAL mode\n                // This prevents supervisor from forgetting to explicitly mark absent students\n                if (pythonResponse != null && pythonResponse.getData() != null && \"INITIAL\".equals(pythonResponse.getData().getMode())) {\n                        logger.info(\"Auto-finalizing NOT_YET exam students to ABSENT: slotId={}\", slotId);\n\n                        // Find all NOT_YET records for this slot\n                        List<com.fuacs.backend.entity.ExamAttendance> notYetRecords =\n                                examAttendanceRepository.findBySlotIdAndStatus(slotId,\n                                        com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET);\n\n                        int finalizedCount = 0;\n                        for (com.fuacs.backend.entity.ExamAttendance record : notYetRecords) {\n                                record.setStatus(com.fuacs.backend.constant.enums.AttendanceStatus.ABSENT);\n                                record.setMethod(com.fuacs.backend.constant.enums.AttendanceMethod.SYSTEM_FINALIZE);\n                                record.setRecordedAt(java.time.Instant.now());\n                                finalizedCount++;\n                        }\n\n                        if (!notYetRecords.isEmpty()) {\n                                examAttendanceRepository.saveAll(notYetRecords);\n                                logger.info(\"Auto-finalized {} NOT_YET exam students to ABSENT for slot {}\",\n                                        finalizedCount, slotId);\n                        }\n                }\n\n                // Build response\n                SessionStatusResponse response = new SessionStatusResponse();\n                response.setSlotId(slotId);\n                response.setSessionStatus(\"STOPPED\");\n                response.setMessage(pythonResponse != null\n                                ? \"Exam session stopped successfully\"\n                                : \"Exam session stopped (Python service unavailable)\");\n\n                if (pythonResponse != null && pythonResponse.getData() != null) {\n                        response.setSessionStoppedAt(pythonResponse.getData().getSessionStoppedAt());\n                        response.setTotalRecognitions(pythonResponse.getData().getTotalRecognitions());\n                }\n\n                logger.info(\"Exam session stopped: slotId={}, pythonAvailable={}\",\n                                slotId, pythonResponse != null);\n\n                return response;\n        }\n\n        /**\n         * Rescan exam attendance\n         * Updates evidence images and sets needsReview flags on stop\n         */\n        @Transactional\n        public SessionStatusResponse rescanExamSession(Integer slotId, Integer currentUserId) {\n                logger.info(\"Starting exam rescan: slotId={}, userId={}\", slotId, currentUserId);\n\n                // Validate slot and authorization\n                Slot slot = slotRepository.findById(slotId)\n                                .orElseThrow(() -> new ResourceNotFoundException(\n                                                \"Slot not found: \" + slotId,\n                                                ErrorCode.SLOT_NOT_FOUND));\n\n                if (!slot.getStaff().getId().equals(currentUserId)) {\n                        throw new OperationNotAllowedException(\n                                        \"You are not assigned to this slot\",\n                                        ErrorCode.NOT_ASSIGNED_TO_SLOT);\n                }\n\n                // Get students with active embeddings\n                List<StudentWithEmbedding> studentsWithEmbeddings = getStudentsWithEmbeddings(slot);\n                logger.info(\"Found {} students with active face embeddings for exam rescan slot {}\",\n                                studentsWithEmbeddings.size(), slotId);\n\n                // Validate: Get active cameras for room\n                List<Camera> cameras = cameraRepository.findByRoom_Id(slot.getRoom().getId())\n                                .stream()\n                                .filter(Camera::getActive)\n                                .collect(java.util.stream.Collectors.toList());\n\n                if (cameras.isEmpty()) {\n                        throw new BadRequestException(\n                                        \"No active cameras configured for room: \" + slot.getRoom().getName(),\n                                        ErrorCode.CAMERA_NOT_FOUND);\n                }\n\n                logger.info(\"Found {} active cameras for room: {}\", cameras.size(), slot.getRoom().getName());\n\n                // Build Python request with EXAM RESCAN mode\n                PythonStartSessionRequest request = buildPythonRequestForExam(slot, studentsWithEmbeddings, \"RESCAN\");\n\n                // Call Python backend to start rescan\n                PythonSessionResponse pythonResponse;\n                try {\n                        pythonResponse = pythonBackendClient.startRecognitionSession(request);\n                } catch (Exception e) {\n                        logger.error(\"Failed to start Python exam rescan: slotId={}, error={}\", slotId, e.getMessage(), e);\n                        throw new BadRequestException(\n                                        \"Failed to start exam rescan: \" + e.getMessage(),\n                                        ErrorCode.SESSION_START_FAILED);\n                }\n\n                // Build response\n                SessionStatusResponse response = buildSessionStatusResponse(slot, pythonResponse,\n                                studentsWithEmbeddings.size());\n\n                return response;\n        }\n\n        /**\n         * Build Python request for EXAM session\n         * Sets callbackType to \"EXAM\" so Python service routes updates to exam_attendance table\n         */\n        private PythonStartSessionRequest buildPythonRequestForExam(Slot slot, List<StudentWithEmbedding> students,\n                        String mode) {\n                PythonStartSessionRequest request = new PythonStartSessionRequest();\n                request.setSlotId(slot.getId());\n                request.setRoomId(slot.getRoom().getId().shortValue());\n                request.setMode(ScanMode.valueOf(mode));\n                request.setCallbackType(\"EXAM\"); // Route to exam_attendance table\n\n                // Set cameras\n                List<PythonStartSessionRequest.CameraDTO> cameras = slot.getRoom().getCameras().stream()\n                                .filter(Camera::getActive)\n                                .map(cam -> new PythonStartSessionRequest.CameraDTO(\n                                                cam.getId().shortValue(),\n                                                cam.getName(),\n                                                cam.getRtspUrl()))\n                                .collect(Collectors.toList());\n                request.setCameras(cameras);\n\n                // Set student embeddings\n                List<PythonStartSessionRequest.StudentEmbeddingDTO> embeddings = students.stream()\n                                .map(s -> new PythonStartSessionRequest.StudentEmbeddingDTO(\n                                                s.userId(),\n                                                s.fullName(),\n                                                s.rollNumber(),\n                                                s.embeddingVector(),\n                                                s.embeddingVersion()))\n                                .collect(Collectors.toList());\n                request.setStudents(embeddings);\n\n                // Set config with callback URL\n                String callbackUrl = \"http://localhost:\" + serverPort + \"/api/v1/attendance/recognition-result\";\n                PythonStartSessionRequest.SessionConfigDTO config = new PythonStartSessionRequest.SessionConfigDTO(\n                                callbackUrl);\n                request.setConfig(config);\n\n                return request;\n        }\n\n        /**\n         * Get students with active face embeddings for a slot\n         * Handles both LECTURE/LECTURE_WITH_PT (enrolled students) and FINAL_EXAM (exam\n         * participants)\n         */\n        private List<StudentWithEmbedding> getStudentsWithEmbeddings(Slot slot) {\n                List<StudentWithEmbedding> result = new ArrayList<>();\n\n                if (slot.getSlotCategory() == SlotCategory.LECTURE ||\n                                slot.getSlotCategory() == SlotCategory.LECTURE_WITH_PT) {\n\n                        // Get enrolled students for class-based slots\n                        // TODO: Use custom query to get enrollments with student profiles efficiently\n                        // For now, we'll get from enrollments\n\n                        if (slot.getAcademicClass() == null) {\n                                logger.warn(\"LECTURE slot has no class assigned: slotId={}\", slot.getId());\n                                return result;\n                        }\n\n                        // This is a simplified version - in production, use custom repository method\n                        // to fetch enrollments with students in one query\n                        List<Enrollment> enrollments = enrollmentRepository.findAll().stream()\n                                        .filter(e -> e.getAcademicClass().getId()\n                                                        .equals(slot.getAcademicClass().getId()))\n                                        .filter(Enrollment::getEnrolled)\n                                        .collect(Collectors.toList());\n\n                        for (Enrollment enrollment : enrollments) {\n                                User student = enrollment.getStudent();\n\n                                // Get active embedding\n                                faceEmbeddingService.getActiveEmbedding(student.getId())\n                                                .ifPresent(embedding -> {\n                                                        result.add(new StudentWithEmbedding(\n                                                                        student.getId(),\n                                                                        student.getFullName(),\n                                                                        student.getUsername(), // rollNumber\n                                                                        embedding.getEmbeddingVector(),\n                                                                        embedding.getVersion()));\n                                                });\n                        }\n\n                } else if (slot.getSlotCategory() == SlotCategory.FINAL_EXAM) {\n                        // Get students from exam_slot_participants table\n                        List<ExamSlotParticipant> participants = examSlotParticipantRepository\n                                        .findBySlotIdWithStudents(slot.getId());\n\n                        if (participants.isEmpty()) {\n                                logger.warn(\"No enrolled participants found for FINAL_EXAM slot: {}\", slot.getId());\n                        }\n\n                        // Loop through participants and get embeddings\n                        for (ExamSlotParticipant participant : participants) {\n                                User student = participant.getStudentUser();\n\n                                // Get active embedding (Optional pattern)\n                                faceEmbeddingService.getActiveEmbedding(student.getId())\n                                                .ifPresent(embedding -> {\n                                                        result.add(new StudentWithEmbedding(\n                                                                        student.getId(),\n                                                                        student.getFullName(),\n                                                                        student.getUsername(), // rollNumber\n                                                                        embedding.getEmbeddingVector(),\n                                                                        embedding.getVersion()));\n                                                });\n                        }\n\n                        if (result.isEmpty()) {\n                                logger.warn(\"No students with embeddings found for FINAL_EXAM slot: {}\",\n                                                slot.getId());\n                        }\n                }\n\n                return result;\n        }\n\n        /**\n         * Build Python backend request\n         */\n        private PythonStartSessionRequest buildPythonRequest(Slot slot,\n                        List<StudentWithEmbedding> students,\n                        List<Camera> cameras,\n                        ScanMode mode) {\n                PythonStartSessionRequest request = new PythonStartSessionRequest();\n                request.setSlotId(slot.getId());\n                request.setRoomId(slot.getRoom().getId());\n                request.setMode(mode);\n\n                // Map students to Python DTO\n                List<PythonStartSessionRequest.StudentEmbeddingDTO> studentDTOs = students.stream()\n                                .map(s -> new PythonStartSessionRequest.StudentEmbeddingDTO(\n                                                s.userId(),\n                                                s.fullName(),\n                                                s.rollNumber(),\n                                                s.embeddingVector(),\n                                                s.embeddingVersion()))\n                                .collect(Collectors.toList());\n                request.setStudents(studentDTOs);\n\n                // Map cameras to Python DTO\n                List<PythonStartSessionRequest.CameraDTO> cameraDTOs = cameras.stream()\n                                .map(c -> new PythonStartSessionRequest.CameraDTO(\n                                                c.getId(),\n                                                c.getName(),\n                                                c.getRtspUrl()))\n                                .collect(Collectors.toList());\n                request.setCameras(cameraDTOs);\n\n                // Set config with callback URL and similarity threshold\n                String callbackUrl = \"http://localhost:\" + serverPort + \"/api/v1/attendance/recognition-result\";\n                PythonStartSessionRequest.SessionConfigDTO config = new PythonStartSessionRequest.SessionConfigDTO(\n                                callbackUrl);\n\n                // Use configured similarity threshold (from application.yaml or environment variable)\n                config.setSimilarityThreshold(faceRecognitionProperties.getSimilarityThreshold());\n\n                request.setConfig(config);\n\n                return request;\n        }\n\n        /**\n         * Build session status response from Python response\n         */\n        private SessionStatusResponse buildSessionStatusResponse(Slot slot,\n                        PythonSessionResponse pythonResponse,\n                        int totalStudentsWithEmbeddings) {\n                SessionStatusResponse response = new SessionStatusResponse();\n                response.setSlotId(slot.getId());\n                response.setRoomId(slot.getRoom().getId());\n                response.setSlotTitle(slot.getTitle());\n                response.setStudentsWithEmbeddings(totalStudentsWithEmbeddings);\n                response.setSessionStatus(\"STARTED\");\n                response.setMessage(\"Face recognition session started successfully\");\n\n                if (pythonResponse.getData() != null) {\n                        PythonSessionResponse.SessionDataDTO data = pythonResponse.getData();\n                        response.setTotalCameras(data.getTotalCameras());\n                        response.setActiveCameras(data.getActiveCameras());\n                        response.setFailedCameras(data.getFailedCameras());\n                        response.setSessionStartedAt(data.getSessionStartedAt());\n                }\n\n                return response;\n        }\n\n        // Helper record for passing student data\n        private record StudentWithEmbedding(\n                        Integer userId,\n                        String fullName,\n                        String rollNumber,\n                        float[] embeddingVector,\n                        Integer embeddingVersion) {\n        }\n\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\StaffProfileService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/StaffProfileService.java",
      "filename": "StaffProfileService.java",
      "size_bytes": 19279,
      "lines": 443,
      "last_modified": "2025-11-19T16:59:41.064432",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.config.UserAuthentication;\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.dto.mapper.StaffProfileMapper;\nimport com.fuacs.backend.dto.request.StaffProfileCreateRequest;\nimport com.fuacs.backend.dto.request.StaffProfileCsvRow;\nimport com.fuacs.backend.dto.request.StaffProfileSearchRequest;\nimport com.fuacs.backend.dto.request.StaffProfileUpdateRequest;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.dto.response.PagingResponse;\nimport com.fuacs.backend.dto.response.StaffProfileDTO;\nimport com.fuacs.backend.entity.Role;\nimport com.fuacs.backend.entity.Slot;\nimport com.fuacs.backend.entity.StaffProfile;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.RoleRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport com.fuacs.backend.repository.StaffProfileRepository;\nimport com.fuacs.backend.repository.UserRepository;\nimport com.fuacs.backend.util.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@Service\npublic class StaffProfileService {\n\n    private static final Logger logger = LoggerFactory.getLogger(StaffProfileService.class);\n\n    private final StaffProfileRepository staffProfileRepository;\n    private final UserRepository userRepository;\n    private final RoleRepository roleRepository;\n    private final PasswordEncoder passwordEncoder;\n    private final EmailService emailService;\n    private final SlotRepository slotRepository;\n    private final CsvParserService csvParserService;\n\n    public StaffProfileService(StaffProfileRepository staffProfileRepository,\n                               UserRepository userRepository,\n                               RoleRepository roleRepository,\n                               StaffProfileMapper staffProfileMapper,\n                               PasswordEncoder passwordEncoder,\n                               EmailService emailService,\n                               SlotRepository slotRepository,\n                               CsvParserService csvParserService) {\n        this.staffProfileRepository = staffProfileRepository;\n        this.userRepository = userRepository;\n        this.roleRepository = roleRepository;\n        this.passwordEncoder = passwordEncoder;\n        this.emailService = emailService;\n        this.slotRepository = slotRepository;\n        this.csvParserService = csvParserService;\n    }\n\n    public PagingResponse<StaffProfileDTO> search(StaffProfileSearchRequest request) {\n        List<StaffProfileDTO> staffProfiles = staffProfileRepository.search(request);\n        Long total = staffProfileRepository.count(request);\n        return PagingResponse.of(staffProfiles, total, request);\n    }\n\n    @Transactional\n    public StaffProfileDTO create(StaffProfileCreateRequest request) {\n        // Check username uniqueness FIRST (before staffCode) to provide better error messages\n        if (userRepository.existsByUsername(request.getUsername())) {\n            throw new ResourceExistsException(\"Username exists: \" + request.getUsername(),\n                    ErrorCode.USERNAME_EXISTS);\n        }\n\n        if (staffProfileRepository.existsByStaffCode(request.getStaffCode())) {\n            throw new ResourceExistsException(\"Staff code exists: \" + request.getStaffCode(),\n                    ErrorCode.STAFF_CODE_EXISTS);\n        }\n        if (userRepository.existsByEmail(request.getEmail())) {\n            throw new ResourceExistsException(\"Email exists: \" + request.getEmail(), ErrorCode.EMAIL_EXISTS);\n        }\n\n        // Validate roles\n        Set<Role> roles = validateRoles(request.getRoles(), false);\n\n        // Create user\n        User user = new User();\n        user.setFullName(request.getFullName());\n        user.setEmail(request.getEmail());\n        // Username is now taken from request, not auto-set to staffCode\n        user.setUsername(request.getUsername());\n\n        String password = request.getPassword();\n        boolean generated = false;\n        if (password == null || password.isBlank()) {\n            password = UUID.randomUUID().toString();\n            generated = true;\n        }\n        if (generated) {\n            emailService.sendPassword(user.getEmail(), password);\n        }\n        user.setPasswordHash(passwordEncoder.encode(password));\n        user.setRoles(roles);\n\n        User savedUser = userRepository.save(user);\n\n        // Create staff profile\n        StaffProfile staffProfile = new StaffProfile();\n        staffProfile.setStaffCode(request.getStaffCode());\n        staffProfile.setUser(savedUser);\n        StaffProfile savedProfile = staffProfileRepository.save(staffProfile);\n\n        // Create response\n        StaffProfileDTO response = new StaffProfileDTO();\n        response.setUserId(savedUser.getId());\n        response.setFullName(savedUser.getFullName());\n        response.setEmail(savedUser.getEmail());\n        response.setUsername(savedUser.getUsername());\n        response.setStaffCode(savedProfile.getStaffCode());\n        response.setRoles(roles.stream().map(Role::getName).collect(Collectors.toList()));\n        response.setActive(savedUser.getActive());\n        response.setCreatedAt(savedUser.getCreatedAt());\n        response.setUpdatedAt(savedUser.getUpdatedAt());\n\n        return response;\n    }\n\n    @Transactional\n    public StaffProfileDTO update(Integer id, StaffProfileUpdateRequest request) {\n        StaffProfile staffProfile = staffProfileRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Staff profile not found: \" + id,\n                        ErrorCode.STAFF_PROFILE_NOT_FOUND));\n\n        User user = staffProfile.getUser();\n\n        if (!staffProfile.getStaffCode().equals(request.getStaffCode()) &&\n                staffProfileRepository.existsByStaffCodeAndUserIdNot(request.getStaffCode(), id)) {\n            throw new ResourceExistsException(\"Staff code exists: \" + request.getStaffCode(),\n                    ErrorCode.STAFF_CODE_EXISTS);\n        }\n\n        if (!user.getEmail().equals(request.getEmail()) &&\n                userRepository.existsByEmailAndIdNot(request.getEmail(), user.getId())) {\n            throw new ResourceExistsException(\"Email already exists: \" + request.getEmail(), ErrorCode.EMAIL_EXISTS);\n        }\n\n        // Validate roles (cannot assign STUDENT role to staff)\n        Set<Role> roles = validateRoles(request.getRoles(), true);\n\n        // Update user\n        user.setFullName(request.getFullName());\n        user.setEmail(request.getEmail());\n        user.setUsername(request.getStaffCode());\n        user.setActive(request.getActive());\n        user.setRoles(roles);\n        User savedUser = userRepository.save(user);\n\n        // Update staff profile\n        staffProfile.setStaffCode(request.getStaffCode());\n        StaffProfile savedProfile = staffProfileRepository.save(staffProfile);\n\n        // Create response\n        StaffProfileDTO response = new StaffProfileDTO();\n        response.setUserId(savedUser.getId());\n        response.setFullName(savedUser.getFullName());\n        response.setEmail(savedUser.getEmail());\n        response.setUsername(savedUser.getUsername());\n        response.setStaffCode(savedProfile.getStaffCode());\n        response.setRoles(roles.stream().map(Role::getName).collect(Collectors.toList()));\n        response.setActive(savedUser.getActive());\n        response.setCreatedAt(savedUser.getCreatedAt());\n        response.setUpdatedAt(savedUser.getUpdatedAt());\n\n        return response;\n    }\n\n    @Transactional\n    public void delete(Integer id) {\n        StaffProfile staffProfile = staffProfileRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Staff profile not found: \" + id,\n                        ErrorCode.STAFF_PROFILE_NOT_FOUND));\n\n        User user = staffProfile.getUser();\n\n        // Check for active slots assigned to this staff\n        List<Slot> activeSlots = slotRepository.findByStaffUserId(user.getId());\n        if (!activeSlots.isEmpty()) {\n            throw new OperationNotAllowedException(\n                    \"Cannot delete staff profile with active assignments (classes, slots, etc.)\",\n                    ErrorCode.FOREIGN_KEY_CONSTRAINT_VIOLATION);\n        }\n\n        // If no active slots, proceed with deletion\n        staffProfileRepository.deleteById(id);\n        userRepository.deleteById(user.getId());\n    }\n\n    @Transactional(readOnly = true)\n    public StaffProfileDTO findById(Integer id) {\n        StaffProfile staffProfile = staffProfileRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Staff profile not found: \" + id,\n                        ErrorCode.STAFF_PROFILE_NOT_FOUND));\n\n        User user = staffProfile.getUser();\n\n        StaffProfileDTO response = new StaffProfileDTO();\n        response.setUserId(user.getId());\n        response.setFullName(user.getFullName());\n        response.setEmail(user.getEmail());\n        response.setUsername(user.getUsername());\n        response.setStaffCode(staffProfile.getStaffCode());\n        response.setRoles(user.getRoles().stream().map(Role::getName).collect(Collectors.toList()));\n        response.setActive(user.getActive());\n        response.setCreatedAt(user.getCreatedAt());\n        response.setUpdatedAt(user.getUpdatedAt());\n\n        return response;\n    }\n\n    private Set<Role> validateRoles(Set<String> roleNames, boolean isUpdate) {\n        if (roleNames == null || roleNames.isEmpty()) {\n            throw new BadRequestException(\"At least one role is required\", ErrorCode.ROLES_REQUIRED);\n        }\n        List<Role> roles = roleRepository.findByNameIn(roleNames);\n\n        // Validate missing roles\n        Set<String> foundNames = roles.stream()\n                .map(Role::getName)\n                .map(String::toUpperCase)\n                .collect(Collectors.toSet());\n\n        List<String> missing = roleNames.stream()\n                .filter(name -> !foundNames.contains(name.toUpperCase()))\n                .toList();\n\n        if (!missing.isEmpty()) {\n            throw new BadRequestException(\"Invalid roles: \" + String.join(\", \", missing), ErrorCode.INVALID_ROLE);\n        }\n\n        // Prevent assigning STUDENT role to staff\n        boolean hasStudent = roles.stream()\n                .anyMatch(role -> com.fuacs.backend.constant.enums.Role.STUDENT.name()\n                        .equalsIgnoreCase(role.getName()));\n\n        if (hasStudent) {\n            throw new BadRequestException(\"Cannot assign STUDENT role to staff\",\n                    ErrorCode.INVALID_ROLE);\n        }\n\n        return new HashSet<>(roles);\n    }\n\n    /**\n     * Import staff profiles from CSV file with partial success pattern.\n     * Supports AddOnly and AddAndUpdate modes.\n     * NO @Transactional here to avoid rollback-only conflict.\n     *\n     * @param file CSV file with format: full_name,email,staff_code,roles\n     * @param modeStr Import mode (\"AddOnly\" or \"AddAndUpdate\")\n     * @return ImportResultDTO with success/failure counts and error details\n     */\n    public ImportResultDTO importFromCsv(MultipartFile file, String modeStr) {\n        logger.info(\"Starting staff profile CSV import with mode: {}\", modeStr);\n\n        // Parse mode\n        ImportMode mode;\n        try {\n            mode = ImportMode.fromString(modeStr);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), ErrorCode.INVALID_IMPORT_MODE);\n        }\n\n        // Parse CSV\n        List<StaffProfileCsvRow> rows;\n        try {\n            rows = csvParserService.parseStaffProfileCsv(file);\n        } catch (IOException e) {\n            throw new BadRequestException(\"Failed to process CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        logger.info(\"Parsed {} rows from CSV\", rows.size());\n\n        // Deduplicate within file by business key (staff_code)\n        Map<String, StaffProfileCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (StaffProfileCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getUniqueKey(), row);\n        }\n\n        logger.info(\"After deduplication: {} unique staff profiles\", uniqueRows.size());\n\n        // Process rows with partial success\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (StaffProfileCsvRow row : uniqueRows.values()) {\n            try {\n                processOneStaffRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                logger.warn(\"Failed to process row {}: {}\", row.getRowNumber(), e.getMessage());\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()\n                ));\n            }\n        }\n\n        logger.info(\"Staff profile import completed: {} successful, {} failed\", successCount, errors.size());\n\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Process a single staff profile row in a separate transaction.\n     * This ensures one row's failure doesn't affect others (partial success).\n     * NOTE: Password is set to NULL (no email sent), user must reset password later.\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneStaffRow(StaffProfileCsvRow row, ImportMode mode) {\n        // Validate row\n        if (!row.isValid()) {\n            throw new BadRequestException(\"Invalid row data\", ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Parse and validate roles\n        List<String> roleList = row.getRoleList();\n        if (roleList.isEmpty()) {\n            throw new BadRequestException(\"At least one role is required\", ErrorCode.ROLES_REQUIRED);\n        }\n\n        // Validate roles exist and are not STUDENT (validation only)\n        validateRoles(new HashSet<>(roleList), false);\n\n        // Check if staff exists by staff code\n        StaffProfile existingProfile = staffProfileRepository.findByStaffCode(row.getStaffCode());\n\n        if (existingProfile != null) {\n            // Staff exists\n            if (mode == ImportMode.ADD_ONLY) {\n                throw new ResourceExistsException(\n                        \"Staff with code already exists: \" + row.getStaffCode(),\n                        ErrorCode.STAFF_CODE_EXISTS\n                );\n            }\n\n            // AddAndUpdate mode: Update existing staff\n            User existingUser = existingProfile.getUser();\n\n            // Check email uniqueness if changing\n            if (!existingUser.getEmail().equals(row.getEmail()) &&\n                    userRepository.existsByEmail(row.getEmail())) {\n                throw new ResourceExistsException(\"Email already exists: \" + row.getEmail(),\n                        ErrorCode.EMAIL_EXISTS);\n            }\n\n            // Update user fields\n            existingUser.setEmail(row.getEmail());\n            existingUser.setFullName(row.getFullName());\n            existingUser.setUsername(row.getStaffCode()); // Username is always staff_code\n\n            // Fetch fresh roles from repository to ensure they are in managed state\n            Set<String> roleNames = new HashSet<>(roleList);\n            List<Role> freshRoles = roleRepository.findByNameIn(roleNames);\n            existingUser.setRoles(new HashSet<>(freshRoles));\n\n            // Update password if provided\n            if (row.getPassword() != null && !row.getPassword().isEmpty()) {\n                existingUser.setPasswordHash(row.getPassword());\n            }\n\n            // Update status if provided\n            if (row.getIsActive() != null) {\n                existingUser.setActive(row.getIsActive());\n            }\n\n            existingUser.setUpdatedAt(Instant.now());\n            userRepository.save(existingUser);\n\n            // Staff profile doesn't need update (staff_code is the key)\n        } else {\n            // Create new staff profile\n\n            // Check uniqueness\n            if (userRepository.existsByEmail(row.getEmail())) {\n                throw new ResourceExistsException(\"Email already exists: \" + row.getEmail(),\n                        ErrorCode.EMAIL_EXISTS);\n            }\n\n            // Create user\n            User user = new User();\n            user.setUsername(row.getStaffCode()); // Username is always staff_code\n            user.setEmail(row.getEmail());\n            user.setFullName(row.getFullName());\n            user.setPasswordHash(row.getPassword() != null && !row.getPassword().isEmpty() ? row.getPassword() : null);\n            user.setActive(row.getIsActive() != null ? row.getIsActive() : true);\n            user.setCreatedAt(Instant.now());\n            user.setUpdatedAt(Instant.now());\n\n            // Fetch fresh roles from repository to ensure they are in managed state\n            Set<String> roleNames = new HashSet<>(roleList);\n            List<Role> freshRoles = roleRepository.findByNameIn(roleNames);\n            user.setRoles(new HashSet<>(freshRoles));\n\n            user = userRepository.save(user);\n\n            // Create staff profile\n            StaffProfile profile = new StaffProfile();\n            profile.setUser(user);\n            profile.setStaffCode(row.getStaffCode());\n            staffProfileRepository.save(profile);\n\n        }\n    }\n\n    /**\n     * Extract error code from exception.\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\StudentDashboardService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/StudentDashboardService.java",
      "filename": "StudentDashboardService.java",
      "size_bytes": 8672,
      "lines": 186,
      "last_modified": "2025-11-21T19:16:59.620537",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.dto.mapper.StudentDashboardMapper;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.dto.response.StudentDashboardResponse;\nimport com.fuacs.backend.dto.response.StudentSlotDTO;\nimport com.fuacs.backend.dto.response.StudentSubjectDTO;\nimport com.fuacs.backend.entity.Semester;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.EnrollmentRepository;\nimport com.fuacs.backend.repository.SemesterRepository;\nimport com.fuacs.backend.repository.SlotRepository;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * Service for Student Dashboard functionality.\n * Provides raw data for upcoming learning slots, exam slots, and current semester subjects.\n */\n@Service\n@Transactional(readOnly = true)\npublic class StudentDashboardService {\n\n    private static final Logger logger = LoggerFactory.getLogger(StudentDashboardService.class);\n\n    private final SlotRepository slotRepository;\n    private final EnrollmentRepository enrollmentRepository;\n    private final SemesterRepository semesterRepository;\n    private final StudentProfileRepository studentProfileRepository;\n    private final StudentDashboardMapper studentDashboardMapper;\n\n    public StudentDashboardService(SlotRepository slotRepository,\n                                   EnrollmentRepository enrollmentRepository,\n                                   SemesterRepository semesterRepository,\n                                   StudentProfileRepository studentProfileRepository,\n                                   StudentDashboardMapper studentDashboardMapper) {\n        this.slotRepository = slotRepository;\n        this.enrollmentRepository = enrollmentRepository;\n        this.semesterRepository = semesterRepository;\n        this.studentProfileRepository = studentProfileRepository;\n        this.studentDashboardMapper = studentDashboardMapper;\n    }\n\n    /**\n     * Retrieves dashboard data for a student with optional semester filtering.\n     * Returns raw data including upcoming learning slots, exam slots, and subjects.\n     *\n     * @param studentUserId The ID of the student user\n     * @param semesterId Optional semester ID for filtering (null = current semester)\n     * @return StudentDashboardResponse containing all dashboard data\n     * @throws BadRequestException if studentUserId is invalid\n     * @throws ResourceNotFoundException if student profile is not found\n     */\n    public StudentDashboardResponse getDashboardData(Integer studentUserId, Short semesterId) {\n        // Validate input parameters\n        if (studentUserId == null || studentUserId <= 0) {\n            throw new BadRequestException(\"Invalid student user ID. Student user ID must be positive\", ErrorCode.BAD_REQUEST);\n        }\n\n        try {\n            // Verify student exists\n            if (!studentProfileRepository.existsById(studentUserId)) {\n                throw new ResourceNotFoundException(\"Student profile not found: \" + studentUserId, ErrorCode.STUDENT_PROFILE_NOT_FOUND);\n            }\n\n            // Get current time for filtering upcoming slots\n            LocalDateTime currentTime = LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n\n            // 1. Determine effective semester\n            Short effectiveSemesterId = semesterId;\n            if (effectiveSemesterId == null) {\n                // Default to current semester\n                try {\n                    List<Semester> currentSemesters = semesterRepository.findCurrentSemesters();\n                    if (!currentSemesters.isEmpty()) {\n                        effectiveSemesterId = currentSemesters.get(0).getId();\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"Error finding current semester: {}\", e.getMessage());\n                    // Continue with null - valid scenario\n                }\n            }\n\n            // 2. Get all semesters for dropdown\n            List<SemesterDTO> semesterDTOs = Collections.emptyList();\n            try {\n                List<Semester> allSemesters = semesterRepository.findAll();\n                semesterDTOs = allSemesters.stream()\n                        .map(s -> new SemesterDTO(\n                                s.getId(),\n                                s.getName(),\n                                s.getCode(),\n                                s.getStartDate(),\n                                s.getEndDate(),\n                                s.getActive()\n                        ))\n                        .collect(Collectors.toList());\n            } catch (Exception e) {\n                logger.warn(\"Error retrieving semesters: {}\", e.getMessage());\n            }\n\n            // 3. Query next scheduled day slots (dynamic - finds the next day with any slots)\n            List<StudentSlotDTO> nextDaySlots = Collections.emptyList();\n            try {\n                nextDaySlots = slotRepository.findNextDaySlotsByStudentId(\n                        studentUserId,\n                        effectiveSemesterId,\n                        currentTime\n                );\n            } catch (Exception e) {\n                logger.warn(\"Error retrieving next day slots: {}\", e.getMessage());\n                // Continue with empty list\n            }\n\n            // 5. Query upcoming slots with semester filter\n            List<StudentSlotDTO> upcomingLearningSlots = Collections.emptyList();\n            try {\n                upcomingLearningSlots = slotRepository.findUpcomingLearningSlotsBySemester(\n                        studentUserId,\n                        effectiveSemesterId,\n                        currentTime\n                );\n            } catch (Exception e) {\n                logger.warn(\"Error retrieving upcoming learning slots: {}\", e.getMessage());\n                // Continue with empty list\n            }\n\n            List<StudentSlotDTO> upcomingExamSlots = Collections.emptyList();\n            try {\n                upcomingExamSlots = slotRepository.findUpcomingExamSlotsBySemester(\n                        studentUserId,\n                        effectiveSemesterId,\n                        currentTime\n                );\n            } catch (Exception e) {\n                logger.warn(\"Error retrieving upcoming exam slots: {}\", e.getMessage());\n                // Continue with empty list\n            }\n\n            // 6. Query semester subjects\n            List<StudentSubjectDTO> currentSemesterSubjects = Collections.emptyList();\n            if (effectiveSemesterId != null) {\n                try {\n                    currentSemesterSubjects = enrollmentRepository.findCurrentSemesterSubjectsByStudentId(\n                            studentUserId,\n                            effectiveSemesterId\n                    );\n                } catch (Exception e) {\n                    logger.warn(\"Error retrieving semester subjects: {}\", e.getMessage());\n                }\n            }\n\n            // 7. Build and return response\n            StudentDashboardResponse response = StudentDashboardResponse.builder()\n                    .semesters(semesterDTOs)\n                    .selectedSemesterId(effectiveSemesterId)\n                    .nextDaySlots(nextDaySlots)\n                    .upcomingLearningSlots(upcomingLearningSlots)\n                    .upcomingExamSlots(upcomingExamSlots)\n                    .currentSemesterSubjects(currentSemesterSubjects)\n                    .currentSemesterId(effectiveSemesterId)  // Keep for backward compatibility\n                    .build();\n\n            return response;\n\n        } catch (BadRequestException e) {\n            // Re-throw known exceptions as-is\n            throw e;\n        } catch (Exception e) {\n            logger.error(\"Unexpected error retrieving dashboard data for student {}: {}\", studentUserId, e.getMessage(), e);\n            throw new BadRequestException(\"Failed to retrieve student dashboard data: \" + e.getMessage(), ErrorCode.UNKNOWN_ERROR);\n        }\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\StudentPhotoService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/StudentPhotoService.java",
      "filename": "StudentPhotoService.java",
      "size_bytes": 2989,
      "lines": 78,
      "last_modified": "2025-11-11T16:48:15.151299",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.entity.StudentProfile;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\n@Service\npublic class StudentPhotoService {\n\n    private static final Logger logger = LoggerFactory.getLogger(StudentPhotoService.class);\n    private static final String PHOTO_BASE_DIR = \"./uploads/student-photos\";\n\n    private final StudentProfileRepository studentProfileRepository;\n\n    public StudentPhotoService(StudentProfileRepository studentProfileRepository) {\n        this.studentProfileRepository = studentProfileRepository;\n    }\n\n    /**\n     * Save photo vào user folder: ./uploads/student-photos/{userId}/{rollNumber}_profile.jpg\n     *\n     * @param sourcePath Path to source image (trong temp folder)\n     * @param userId Student user ID\n     * @param rollNumber Student roll number (dùng cho filename)\n     * @return baseUrl (filename only, không có path)\n     */\n    public String savePhotoToUserFolder(Path sourcePath, Integer userId, String rollNumber) throws IOException {\n        // Create user folder nếu chưa tồn tại\n        Path userFolder = Paths.get(PHOTO_BASE_DIR, userId.toString());\n        Files.createDirectories(userFolder);\n\n        // Determine file extension từ source\n        String sourceFilename = sourcePath.getFileName().toString();\n        String extension = sourceFilename.substring(sourceFilename.lastIndexOf('.'));\n\n        // Filename format: {rollNumber}_profile.{ext}\n        String filename = rollNumber + \"_profile\" + extension;\n        Path destPath = userFolder.resolve(filename);\n\n        // Copy file (replace nếu đã tồn tại)\n        Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);\n\n        logger.info(\"Saved photo for userId={}: {}\", userId, destPath);\n\n        // Return baseUrl (chỉ filename)\n        return filename;\n    }\n\n    /**\n     * Update student_profiles.base_url\n     */\n    public void updateStudentProfilePhoto(Integer userId, String baseUrl) {\n        StudentProfile profile = studentProfileRepository.findById(userId)\n            .orElseThrow(() -> new RuntimeException(\"Student profile not found\"));\n\n        profile.setBaseUrl(baseUrl);\n        studentProfileRepository.save(profile);\n\n        logger.info(\"Updated base_url for userId={}: {}\", userId, baseUrl);\n    }\n\n    /**\n     * Check if student already has photo (for AddOnly mode)\n     */\n    public boolean hasExistingPhoto(Integer userId) {\n        return studentProfileRepository.findById(userId)\n            .map(profile -> profile.getBaseUrl() != null && !profile.getBaseUrl().isEmpty())\n            .orElse(false);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\StudentProfileService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/StudentProfileService.java",
      "filename": "StudentProfileService.java",
      "size_bytes": 19190,
      "lines": 434,
      "last_modified": "2025-11-11T17:52:41.180150",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.constant.enums.Role;\nimport com.fuacs.backend.dto.mapper.StudentProfileMapper;\nimport com.fuacs.backend.dto.mapper.UserMapper;\nimport com.fuacs.backend.dto.request.StudentProfileCreateRequest;\nimport com.fuacs.backend.dto.request.StudentProfileCsvRow;\nimport com.fuacs.backend.dto.request.StudentProfileSearchRequest;\nimport com.fuacs.backend.dto.request.StudentProfileUpdateRequest;\nimport com.fuacs.backend.dto.request.StudentSemesterSearchRequest;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.dto.response.StudentProfileDTO;\nimport com.fuacs.backend.dto.response.StudentSemesterDTO;\nimport com.fuacs.backend.entity.Major;\nimport com.fuacs.backend.entity.StudentProfile;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.MajorRepository;\nimport com.fuacs.backend.repository.RoleRepository;\nimport com.fuacs.backend.repository.StudentProfileRepository;\nimport com.fuacs.backend.repository.UserRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.util.*;\n\n@Service\npublic class StudentProfileService {\n\n    private static final Logger logger = LoggerFactory.getLogger(StudentProfileService.class);\n\n    private final StudentProfileRepository studentRepository;\n    private final MajorRepository majorRepository;\n    private final UserMapper userMapper;\n    private final StudentProfileMapper studentProfileMapper;\n    private final PasswordEncoder passwordEncoder;\n    private final EmailService emailService;\n    private final RoleRepository roleRepository;\n    private final UserRepository userRepository;\n    private final SemesterService semesterService;\n    private final MajorService majorService;\n    private final CsvParserService csvParserService;\n\n    public StudentProfileService(StudentProfileRepository studentRepository,\n            MajorRepository majorRepository,\n            UserMapper userMapper,\n            StudentProfileMapper studentProfileMapper,\n            PasswordEncoder passwordEncoder,\n            EmailService emailService,\n            RoleRepository roleRepository,\n            UserRepository userRepository,\n            SemesterService semesterService,\n            MajorService majorService,\n            CsvParserService csvParserService) {\n        this.studentRepository = studentRepository;\n        this.majorRepository = majorRepository;\n        this.userMapper = userMapper;\n        this.studentProfileMapper = studentProfileMapper;\n        this.passwordEncoder = passwordEncoder;\n        this.emailService = emailService;\n        this.roleRepository = roleRepository;\n        this.userRepository = userRepository;\n        this.semesterService = semesterService;\n        this.majorService = majorService;\n        this.csvParserService = csvParserService;\n    }\n\n    public List<StudentProfileDTO> search(StudentProfileSearchRequest request) {\n        return studentRepository.search(request);\n    }\n\n    public Long count(StudentProfileSearchRequest request) {\n        return studentRepository.count(request);\n    }\n\n    @Transactional(readOnly = true)\n    public StudentProfileDTO findById(Integer userId) {\n        StudentProfile studentProfile = studentRepository.findById(userId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Student profile not found: \" + userId,\n                        ErrorCode.STUDENT_PROFILE_NOT_FOUND));\n\n        StudentProfileDTO dto = studentProfileMapper.toDTO(studentProfile);\n        dto.setRoles(Set.of(Role.STUDENT.toString()));\n        // TODO: Query hasActiveEmbedding from face_embeddings table\n        // For now, hardcode to false\n        dto.setHasActiveEmbedding(false);\n        dto.setCanUseFaceRecognition(false);\n\n        return dto;\n    }\n\n    @Transactional\n    public StudentProfileDTO create(StudentProfileCreateRequest request) {\n        if (studentRepository.existsByRollNumber(request.getRollNumber())) {\n            throw new ResourceExistsException(\"Roll number already exists: \" + request.getRollNumber(),\n                    ErrorCode.ROLL_NUMBER_EXISTS);\n        }\n        if (userRepository.existsByEmail(request.getEmail())) {\n            throw new ResourceExistsException(\"Email already exists: \" + request.getEmail(), ErrorCode.EMAIL_EXISTS);\n        }\n        if (userRepository.existsByUsername(request.getUsername())) {\n            throw new ResourceExistsException(\"Username already exists: \" + request.getUsername(), ErrorCode.USERNAME_EXISTS);\n        }\n        Major major = majorRepository.findById(request.getMajorId())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Major not found: \" + request.getMajorId(),\n                        ErrorCode.MAJOR_NOT_FOUND));\n\n        User user = new User();\n        user.setUsername(request.getUsername());\n        user.setEmail(request.getEmail());\n        user.setFullName(request.getFullName());\n\n        String password = UUID.randomUUID().toString();\n        // Password is generated; do not accept password from client for security\n        emailService.sendPassword(request.getEmail(), password);\n\n        user.setPasswordHash(passwordEncoder.encode(password));\n        user.setRoles(Set.of(roleRepository\n                .findByName(Role.STUDENT.toString())\n                .orElseThrow(() -> new ResourceNotFoundException(\"Student role not found\", ErrorCode.ROLE_NOT_FOUND))));\n        user = userRepository.save(user);\n\n        // Create student profile\n        StudentProfile profile = new StudentProfile();\n        profile.setUser(user);\n        profile.setMajor(major);\n        profile.setRollNumber(request.getRollNumber());\n        profile = studentRepository.save(profile);\n\n        // Create response DTO\n        StudentProfileDTO dto = studentProfileMapper.toDTO(profile);\n        dto.setRoles(Set.of(Role.STUDENT.toString()));\n        dto.setHasActiveEmbedding(false);\n        dto.setCanUseFaceRecognition(false);\n\n        return dto;\n    }\n\n    @Transactional\n    public StudentProfileDTO update(Integer userId, StudentProfileUpdateRequest request) {\n        StudentProfile studentProfile = studentRepository.findById(userId)\n                .orElseThrow(() -> new ResourceNotFoundException(\"Student profile not found: \" + userId,\n                        ErrorCode.STUDENT_PROFILE_NOT_FOUND));\n\n        User existingUser = studentProfile.getUser();\n\n        if (!existingUser.getEmail().equals(request.getEmail()) &&\n                userRepository.existsByEmail(request.getEmail())) {\n            throw new ResourceExistsException(\"Email already exists: \" + request.getEmail(), ErrorCode.EMAIL_EXISTS);\n        }\n\n        if (!studentProfile.getRollNumber().equals(request.getRollNumber()) &&\n                studentRepository.existsByRollNumber(request.getRollNumber())) {\n            throw new ResourceExistsException(\"Roll number already exists: \" + request.getRollNumber(),\n                    ErrorCode.ROLL_NUMBER_EXISTS);\n        }\n\n        // Username cannot be updated via admin management; reject if changed\n        if (request.getUsername() != null && !existingUser.getUsername().equals(request.getUsername())) {\n            throw new OperationNotAllowedException(\"Username cannot be changed\", ErrorCode.FORBIDDEN);\n        }\n\n        // Update the Major if it has changed\n        if (!studentProfile.getMajor().getId().equals(request.getMajorId())) {\n            Major major = majorRepository.findById(request.getMajorId())\n                    .orElseThrow(() -> new ResourceNotFoundException(\"Major not found: \" + request.getMajorId(),\n                            ErrorCode.MAJOR_NOT_FOUND));\n            studentProfile.setMajor(major);\n        }\n\n        // Update user fields\n        // Do not update username\n        existingUser.setEmail(request.getEmail());\n        existingUser.setFullName(request.getFullName());\n        existingUser.setActive(request.getActive());\n        studentProfile.setRollNumber(request.getRollNumber());\n        StudentProfile updatedProfile = studentRepository.save(studentProfile);\n\n        StudentProfileDTO dto = studentProfileMapper.toDTO(updatedProfile);\n        dto.setRoles(Set.of(Role.STUDENT.toString()));\n        // TODO: Query hasActiveEmbedding from face_embeddings table\n        // For now, hardcode to false\n        dto.setHasActiveEmbedding(false);\n        dto.setCanUseFaceRecognition(false);\n        return dto;\n    }\n\n    @Transactional\n    public void delete(Integer userId) {\n        if (!studentRepository.existsById(userId)) {\n            throw new ResourceNotFoundException(\"Student profile not found: \" + userId,\n                    ErrorCode.STUDENT_PROFILE_NOT_FOUND);\n        }\n        try {\n            studentRepository.deleteById(userId);\n        } catch (DataIntegrityViolationException e) {\n            throw new OperationNotAllowedException(\n                    \"Cannot delete student profile with enrollment history or attendance records\",\n                    ErrorCode.FOREIGN_KEY_CONSTRAINT_VIOLATION);\n        }\n    }\n\n    @Transactional(readOnly = true)\n    public List<StudentSemesterDTO> searchBySemesterId(Short semesterId, StudentSemesterSearchRequest request) {\n        // Validate semester exists\n        semesterService.findById(semesterId);\n\n        // Validate subjectId if provided\n        if (request.getSubjectId() != null) {\n            // Will throw exception if subject doesn't exist\n            // SubjectService will handle validation\n        }\n\n        // Validate majorId if provided\n        if (request.getMajorId() != null) {\n            majorService.findById(request.getMajorId());\n        }\n\n        return new ArrayList<>(studentRepository.searchBySemesterId(semesterId, request));\n    }\n\n    @Transactional(readOnly = true)\n    public Long countBySemesterId(Short semesterId, StudentSemesterSearchRequest request) {\n        return studentRepository.countBySemesterId(semesterId, request);\n    }\n\n    /**\n     * Import student profiles from CSV file with partial success pattern.\n     * Supports AddOnly and AddAndUpdate modes.\n     * NO @Transactional here to avoid rollback-only conflict.\n     *\n     * @param file CSV file with format: full_name,email,username,roll_number,major_code\n     * @param modeStr Import mode (\"AddOnly\" or \"AddAndUpdate\")\n     * @return ImportResultDTO with success/failure counts and error details\n     */\n    public ImportResultDTO importFromCsv(MultipartFile file, String modeStr) {\n        logger.info(\"Starting student profile CSV import with mode: {}\", modeStr);\n\n        // Parse mode\n        ImportMode mode;\n        try {\n            mode = ImportMode.fromString(modeStr);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), ErrorCode.INVALID_IMPORT_MODE);\n        }\n\n        // Parse CSV\n        List<StudentProfileCsvRow> rows;\n        try {\n            rows = csvParserService.parseStudentProfileCsv(file);\n        } catch (IOException e) {\n            throw new BadRequestException(\"Failed to process CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        logger.info(\"Parsed {} rows from CSV\", rows.size());\n\n        // Deduplicate within file by business key (roll_number)\n        Map<String, StudentProfileCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (StudentProfileCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getUniqueKey(), row);\n        }\n\n        logger.info(\"After deduplication: {} unique student profiles\", uniqueRows.size());\n\n        // Process rows with partial success\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (StudentProfileCsvRow row : uniqueRows.values()) {\n            try {\n                processOneStudentRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                logger.warn(\"Failed to process row {}: {}\", row.getRowNumber(), e.getMessage());\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()\n                ));\n            }\n        }\n\n        logger.info(\"Student profile import completed: {} successful, {} failed\", successCount, errors.size());\n\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Process a single student profile row in a separate transaction.\n     * This ensures one row's failure doesn't affect others (partial success).\n     * NOTE: Password is set to NULL (no email sent), user must reset password later.\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneStudentRow(StudentProfileCsvRow row, ImportMode mode) {\n        // Validate row\n        if (!row.isValid()) {\n            throw new BadRequestException(\"Invalid row data\", ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Find major\n        Major major = majorRepository.findByCode(row.getMajorCode());\n        if (major == null) {\n            throw new ResourceNotFoundException(\n                    \"Major not found with code: \" + row.getMajorCode(),\n                    ErrorCode.MAJOR_NOT_FOUND\n            );\n        }\n        if (!major.getActive()) {\n            throw new BadRequestException(\"Cannot create student with inactive major\",\n                    ErrorCode.INACTIVE_REFERENCE_NOT_ALLOWED);\n        }\n\n        // Check if student exists by roll number\n        StudentProfile existingProfile = studentRepository.findByRollNumber(row.getRollNumber());\n\n        if (existingProfile != null) {\n            // Student exists\n            if (mode == ImportMode.ADD_ONLY) {\n                throw new ResourceExistsException(\n                        \"Student with roll number already exists: \" + row.getRollNumber(),\n                        ErrorCode.ROLL_NUMBER_EXISTS\n                );\n            }\n\n            // AddAndUpdate mode: Update existing student\n            User existingUser = existingProfile.getUser();\n\n            // Check email uniqueness if changing\n            if (!existingUser.getEmail().equals(row.getEmail()) &&\n                    userRepository.existsByEmail(row.getEmail())) {\n                throw new ResourceExistsException(\"Email already exists: \" + row.getEmail(),\n                        ErrorCode.EMAIL_EXISTS);\n            }\n\n            // Check username uniqueness if changing\n            if (!existingUser.getUsername().equals(row.getUsername()) &&\n                    userRepository.existsByUsername(row.getUsername())) {\n                throw new ResourceExistsException(\"Username already exists: \" + row.getUsername(),\n                        ErrorCode.USERNAME_EXISTS);\n            }\n\n            // Update user fields\n            existingUser.setEmail(row.getEmail());\n            existingUser.setUsername(row.getUsername());\n            existingUser.setFullName(row.getFullName());\n\n            // Update password if provided\n            if (row.getPassword() != null && !row.getPassword().isEmpty()) {\n                existingUser.setPasswordHash(row.getPassword());\n            }\n\n            // Update status if provided\n            if (row.getIsActive() != null) {\n                existingUser.setActive(row.getIsActive());\n            }\n\n            existingUser.setUpdatedAt(Instant.now());\n            userRepository.save(existingUser);\n\n            // Update student profile\n            existingProfile.setMajor(major);\n            studentRepository.save(existingProfile);\n\n        } else {\n            // Create new student profile\n\n            // Check uniqueness\n            if (userRepository.existsByEmail(row.getEmail())) {\n                throw new ResourceExistsException(\"Email already exists: \" + row.getEmail(),\n                        ErrorCode.EMAIL_EXISTS);\n            }\n            if (userRepository.existsByUsername(row.getUsername())) {\n                throw new ResourceExistsException(\"Username already exists: \" + row.getUsername(),\n                        ErrorCode.USERNAME_EXISTS);\n            }\n\n            // Create user\n            User user = new User();\n            user.setUsername(row.getUsername());\n            user.setEmail(row.getEmail());\n            user.setFullName(row.getFullName());\n            user.setPasswordHash(row.getPassword() != null && !row.getPassword().isEmpty() ? row.getPassword() : null);\n            user.setActive(row.getIsActive() != null ? row.getIsActive() : true);\n            user.setCreatedAt(Instant.now());\n            user.setUpdatedAt(Instant.now());\n\n            // Assign STUDENT role\n            var studentRole = roleRepository.findByName(Role.STUDENT.toString())\n                    .orElseThrow(() -> new ResourceNotFoundException(\"Student role not found\",\n                            ErrorCode.ROLE_NOT_FOUND));\n            user.setRoles(Set.of(studentRole));\n\n            user = userRepository.save(user);\n\n            // Create student profile\n            StudentProfile profile = new StudentProfile();\n            profile.setUser(user);\n            profile.setMajor(major);\n            profile.setRollNumber(row.getRollNumber());\n            studentRepository.save(profile);\n        }\n    }\n\n    /**\n     * Extract error code from exception.\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\SubjectService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/SubjectService.java",
      "filename": "SubjectService.java",
      "size_bytes": 17316,
      "lines": 403,
      "last_modified": "2025-11-21T19:54:16.217977",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.constant.ImportMode;\nimport com.fuacs.backend.dto.mapper.MajorMapper;\nimport com.fuacs.backend.dto.mapper.SubjectMapper;\nimport com.fuacs.backend.dto.request.SubjectCsvRow;\nimport com.fuacs.backend.dto.request.SubjectCreateRequest;\nimport com.fuacs.backend.dto.request.SubjectSearchRequest;\nimport com.fuacs.backend.dto.request.SubjectUpdateRequest;\nimport com.fuacs.backend.dto.response.ImportErrorDTO;\nimport com.fuacs.backend.dto.response.ImportResultDTO;\nimport com.fuacs.backend.dto.response.SubjectDTO;\nimport com.fuacs.backend.entity.Major;\nimport com.fuacs.backend.entity.Subject;\nimport com.fuacs.backend.exception.BadRequestException;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport com.fuacs.backend.exception.ResourceExistsException;\nimport com.fuacs.backend.exception.ResourceNotFoundException;\nimport com.fuacs.backend.repository.MajorRepository;\nimport com.fuacs.backend.repository.SubjectRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.dao.DataIntegrityViolationException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n@Service\npublic class SubjectService {\n\n    private static final Logger log = LoggerFactory.getLogger(SubjectService.class);\n\n    private final SubjectRepository subjectRepository;\n    private final SubjectMapper subjectMapper;\n    private final MajorRepository majorRepository;\n    private final MajorMapper majorMapper;\n    private final SemesterService semesterService;\n    private final CsvParserService csvParserService;\n\n    public SubjectService(SubjectRepository subjectRepository,\n            SubjectMapper subjectMapper,\n            MajorRepository majorRepository,\n            MajorMapper majorMapper,\n            SemesterService semesterService,\n            CsvParserService csvParserService) {\n        this.subjectRepository = subjectRepository;\n        this.subjectMapper = subjectMapper;\n        this.majorRepository = majorRepository;\n        this.majorMapper = majorMapper;\n        this.semesterService = semesterService;\n        this.csvParserService = csvParserService;\n    }\n\n    public List<SubjectDTO> search(SubjectSearchRequest request) {\n        return new ArrayList<>(subjectRepository.search(request));\n    }\n\n    public Long count(SubjectSearchRequest request) {\n        return subjectRepository.count(request);\n    }\n\n    // NEW METHOD: Get subjects by staff ID\n    public List<SubjectDTO> searchByStaffId(Integer staffId, SubjectSearchRequest request) {\n        return new ArrayList<>(subjectRepository.searchByStaffId(staffId, request));\n    }\n\n    // NEW METHOD: Count subjects by staff ID\n    public Long countByStaffId(Integer staffId, SubjectSearchRequest request) {\n        return subjectRepository.countByStaffId(staffId, request);\n    }\n\n    @Transactional(readOnly = true)\n    public SubjectDTO findById(Short id) {\n        Subject subject = subjectRepository.findById(id)\n                .orElseThrow(\n                        () -> new ResourceNotFoundException(\"Subject not found: \" + id, ErrorCode.SUBJECT_NOT_FOUND));\n\n        SubjectDTO subjectDTO = subjectMapper.toDTO(subject);\n        subjectDTO.setMajors(subject.getMajors().stream()\n                .map(majorMapper::toDTO)\n                .toList());\n        subjectDTO.setTotalClass((int) subjectRepository.countAllClassesBySubjectId(id));\n        subjectDTO.setTotalActiveClass((int) subjectRepository.countActiveClassesBySubjectId(id));\n\n        return subjectDTO;\n    }\n\n    @Transactional\n    public SubjectDTO create(SubjectCreateRequest request) {\n        // Validate unique constraints\n        if (subjectRepository.existsByCode(request.getCode())) {\n            throw new ResourceExistsException(\"Subject code already exists: \" + request.getCode(),\n                    ErrorCode.SUBJECT_CODE_EXISTS);\n        }\n\n        if (subjectRepository.existsByName(request.getName())) {\n            throw new ResourceExistsException(\"Subject name already exists: \" + request.getName(),\n                    ErrorCode.SUBJECT_NAME_EXISTS);\n        }\n\n        List<Short> majorIds = request.getMajorIds();\n        if (majorIds == null || majorIds.isEmpty()) {\n            throw new OperationNotAllowedException(\"At least one major must be specified\",\n                    ErrorCode.SUBJECT_MAJOR_IDS_EMPTY);\n        }\n\n        Set<Short> uniqueMajorIds = new HashSet<>(majorIds);\n        List<Major> majors = majorRepository.findByIdIn(uniqueMajorIds);\n\n        if (majors.size() != uniqueMajorIds.size()) {\n            Set<Short> foundIds = majors.stream()\n                    .map(Major::getId)\n                    .collect(Collectors.toSet());\n\n            for (Short majorId : uniqueMajorIds) {\n                if (!foundIds.contains(majorId)) {\n                    throw new ResourceNotFoundException(\"Major not found: \" + majorId, ErrorCode.MAJOR_NOT_FOUND);\n                }\n            }\n            throw new ResourceNotFoundException(\"One or more majors not found\", ErrorCode.MAJOR_NOT_FOUND);\n        }\n\n        for (Major major : majors) {\n            if (!major.getActive()) {\n                throw new OperationNotAllowedException(\n                        String.format(\"Cannot assign subject to inactive major (Major ID: %d, Code: %s)\", major.getId(),\n                                major.getCode()),\n                        ErrorCode.INACTIVE_MAJOR_NOT_ALLOWED);\n            }\n        }\n        Subject subject = subjectMapper.toEntity(request);\n        subject.setMajors(new HashSet<>(majors));\n        Subject savedSubject = subjectRepository.save(subject);\n\n        SubjectDTO subjectDTO = subjectMapper.toDTO(savedSubject);\n        subjectDTO.setMajors(majors.stream()\n                .map(majorMapper::toDTO)\n                .toList());\n        subjectDTO.setTotalClass(0);\n        subjectDTO.setTotalActiveClass(0);\n\n        return subjectDTO;\n    }\n\n    @Transactional\n    public SubjectDTO update(Short id, SubjectUpdateRequest request) {\n        Subject existing = subjectRepository.findById(id)\n                .orElseThrow(\n                        () -> new ResourceNotFoundException(\"Subject not found: \" + id, ErrorCode.SUBJECT_NOT_FOUND));\n\n        // Validate unique constraints (excluding current record)\n        if (!request.getCode().equals(existing.getCode()) && subjectRepository.existsByCode(request.getCode())) {\n            throw new ResourceExistsException(\"Subject code already exists: \" + request.getCode(),\n                    ErrorCode.SUBJECT_CODE_EXISTS);\n        }\n\n        if (!request.getName().equals(existing.getName()) && subjectRepository.existsByName(request.getName())) {\n            throw new ResourceExistsException(\"Subject name already exists: \" + request.getName(),\n                    ErrorCode.SUBJECT_NAME_EXISTS);\n        }\n\n        List<Short> majorIds = request.getMajorIds();\n        if (majorIds == null || majorIds.isEmpty()) {\n            throw new OperationNotAllowedException(\"At least one major must be specified\",\n                    ErrorCode.SUBJECT_MAJOR_IDS_EMPTY);\n        }\n\n        Set<Short> uniqueMajorIds = new HashSet<>(majorIds);\n        List<Major> majors = majorRepository.findByIdIn(uniqueMajorIds);\n\n        if (majors.size() != uniqueMajorIds.size()) {\n            Set<Short> foundIds = majors.stream()\n                    .map(Major::getId)\n                    .collect(Collectors.toSet());\n\n            for (Short majorId : uniqueMajorIds) {\n                if (!foundIds.contains(majorId)) {\n                    throw new ResourceNotFoundException(\"Major not found: \" + majorId, ErrorCode.MAJOR_NOT_FOUND);\n                }\n            }\n            throw new ResourceNotFoundException(\"One or more majors not found\", ErrorCode.MAJOR_NOT_FOUND);\n        }\n\n        for (Major major : majors) {\n            if (!major.getActive()) {\n                throw new OperationNotAllowedException(\n                        String.format(\"Cannot assign subject to inactive major (Major ID: %d, Code: %s)\", major.getId(),\n                                major.getCode()),\n                        ErrorCode.INACTIVE_MAJOR_NOT_ALLOWED);\n            }\n        }\n\n        subjectMapper.updateSubjectFromRequest(request, existing);\n        existing.setMajors(new HashSet<>(majors));\n        Subject savedSubject = subjectRepository.save(existing);\n\n        SubjectDTO subjectDTO = subjectMapper.toDTO(savedSubject);\n        subjectDTO.setMajors(majors.stream()\n                .map(majorMapper::toDTO)\n                .toList());\n        subjectDTO.setTotalClass((int) subjectRepository.countAllClassesBySubjectId(id));\n        subjectDTO.setTotalActiveClass((int) subjectRepository.countActiveClassesBySubjectId(id));\n\n        return subjectDTO;\n    }\n\n    @Transactional\n    public void delete(Short id) {\n        if (!subjectRepository.existsById(id)) {\n            throw new ResourceNotFoundException(\"Subject not found: \" + id, ErrorCode.SUBJECT_NOT_FOUND);\n        }\n        long totalClasses = subjectRepository.countAllClassesBySubjectId(id);\n        if (totalClasses > 0) {\n            throw new OperationNotAllowedException(\n                    String.format(\"Cannot delete subject. Found %d classes. Please delete them first\", totalClasses),\n                    ErrorCode.SUBJECT_HAS_DEPENDENCIES);\n        }\n        try {\n            subjectRepository.deleteById(id);\n        } catch (DataIntegrityViolationException e) {\n            throw new OperationNotAllowedException(\"Cannot delete subject due to existing dependencies\",\n                    ErrorCode.SUBJECT_HAS_DEPENDENCIES);\n        }\n    }\n\n    public List<SubjectDTO> searchByMajorId(Short majorId, SubjectSearchRequest request) {\n        if (!majorRepository.existsById(majorId)) {\n            throw new ResourceNotFoundException(\"Major not found: \" + majorId, ErrorCode.MAJOR_NOT_FOUND);\n        }\n        return new ArrayList<>(subjectRepository.searchByMajorId(majorId, request));\n    }\n\n    public Long countByMajorId(Short majorId, SubjectSearchRequest request) {\n        return subjectRepository.countByMajorId(majorId, request);\n    }\n\n    @Transactional(readOnly = true)\n    public List<SubjectDTO> searchBySemesterId(Short semesterId, SubjectSearchRequest request) {\n        // Validate semester exists\n        semesterService.findById(semesterId);\n        return new ArrayList<>(subjectRepository.searchBySemesterId(semesterId, request));\n    }\n\n    @Transactional(readOnly = true)\n    public Long countBySemesterId(Short semesterId, SubjectSearchRequest request) {\n        return subjectRepository.countBySemesterId(semesterId, request);\n    }\n\n    // ========== CSV IMPORT METHODS ==========\n\n    /**\n     * Import subjects from CSV file.\n     * Supports partial success: valid rows are processed, invalid rows are reported.\n     * NO @Transactional on this method to avoid rollback-only conflicts.\n     */\n    public ImportResultDTO importFromCsv(MultipartFile file, String modeStr) {\n        ImportMode mode = ImportMode.fromString(modeStr);\n\n        List<SubjectCsvRow> rows;\n        try {\n            rows = csvParserService.parseSubjectCsv(file);\n        } catch (Exception e) {\n            log.error(\"Failed to parse Subject CSV file\", e);\n            throw new BadRequestException(\"Failed to parse CSV file: \" + e.getMessage(),\n                    ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        // Deduplicate by business key (code)\n        Map<String, SubjectCsvRow> uniqueRows = new LinkedHashMap<>();\n        for (SubjectCsvRow row : rows) {\n            uniqueRows.putIfAbsent(row.getUniqueKey(), row);\n        }\n\n        // Process each row in isolated transaction\n        List<ImportErrorDTO> errors = new ArrayList<>();\n        int successCount = 0;\n\n        for (SubjectCsvRow row : uniqueRows.values()) {\n            try {\n                processOneSubjectRow(row, mode);\n                successCount++;\n            } catch (Exception e) {\n                errors.add(new ImportErrorDTO(\n                        row.getRowNumber(),\n                        extractErrorCode(e),\n                        e.getMessage()));\n            }\n        }\n\n        return new ImportResultDTO(successCount, errors.size(), errors);\n    }\n\n    /**\n     * Process one subject row in an isolated transaction (REQUIRES_NEW).\n     * This allows partial success - each row commits or rolls back independently.\n     */\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    protected void processOneSubjectRow(SubjectCsvRow row, ImportMode mode) {\n        // Validate row data\n        if (!row.isValid()) {\n            throw new BadRequestException(\"Invalid row data at row \" + row.getRowNumber(),\n                    ErrorCode.INVALID_FIELD_FORMAT);\n        }\n\n        // Parse major codes\n        List<String> majorCodeList = row.getMajorCodeList();\n        if (majorCodeList.isEmpty()) {\n            throw new BadRequestException(\"At least one major code must be specified\",\n                    ErrorCode.SUBJECT_MAJOR_IDS_EMPTY);\n        }\n\n        // Lookup majors by code\n        List<Major> majors = new ArrayList<>();\n        for (String majorCode : majorCodeList) {\n            Major major = majorRepository.findByCode(majorCode);\n            if (major == null) {\n                throw new ResourceNotFoundException(\"Major code not found: \" + majorCode,\n                        ErrorCode.MAJOR_NOT_FOUND);\n            }\n            if (!major.getActive()) {\n                throw new OperationNotAllowedException(\n                        String.format(\"Cannot assign subject to inactive major (Code: %s)\", majorCode),\n                        ErrorCode.INACTIVE_MAJOR_NOT_ALLOWED);\n            }\n            majors.add(major);\n        }\n\n        // Check if subject already exists\n        Subject existing = subjectRepository.findByCode(row.getCode());\n\n        if (existing != null) {\n            // Subject exists\n            if (mode == ImportMode.ADD_ONLY) {\n                throw new ResourceExistsException(\n                        \"Subject code already exists: \" + row.getCode(),\n                        ErrorCode.SUBJECT_CODE_EXISTS);\n            }\n\n            // Update mode: update existing subject\n            // Check name uniqueness (excluding current record)\n            if (!existing.getName().equals(row.getName())) {\n                if (subjectRepository.existsByNameAndIdNot(row.getName(), existing.getId())) {\n                    throw new ResourceExistsException(\n                            \"Subject name already exists: \" + row.getName(),\n                            ErrorCode.SUBJECT_NAME_EXISTS);\n                }\n            }\n\n            existing.setName(row.getName());\n            existing.setMajors(new HashSet<>(majors));\n            if (row.getIsActive() != null) {\n                existing.setActive(row.getIsActive());\n            }\n            existing.setUpdatedAt(Instant.now());\n            subjectRepository.save(existing);\n\n        } else {\n            // Subject does not exist: create new\n            // Check name uniqueness\n            if (subjectRepository.existsByName(row.getName())) {\n                throw new ResourceExistsException(\n                        \"Subject name already exists: \" + row.getName(),\n                        ErrorCode.SUBJECT_NAME_EXISTS);\n            }\n\n            Subject subject = new Subject();\n            subject.setCode(row.getCode());\n            subject.setName(row.getName());\n            subject.setMajors(new HashSet<>(majors));\n            subject.setActive(row.getIsActive() != null ? row.getIsActive() : true);\n            subject.setCreatedAt(Instant.now());\n            subject.setUpdatedAt(Instant.now());\n            subjectRepository.save(subject);\n        }\n    }\n\n    /**\n     * Extract error code from exception.\n     */\n    private String extractErrorCode(Exception e) {\n        if (e instanceof BadRequestException) {\n            return ((BadRequestException) e).getErrorCode();\n        } else if (e instanceof ResourceExistsException) {\n            return ((ResourceExistsException) e).getErrorCode();\n        } else if (e instanceof ResourceNotFoundException) {\n            return ((ResourceNotFoundException) e).getErrorCode();\n        } else if (e instanceof OperationNotAllowedException) {\n            return ((OperationNotAllowedException) e).getErrorCode();\n        }\n        return ErrorCode.UNKNOWN_ERROR;\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\SupervisorDashboardService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/SupervisorDashboardService.java",
      "filename": "SupervisorDashboardService.java",
      "size_bytes": 7899,
      "lines": 169,
      "last_modified": "2025-11-24T10:07:17.576616",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.dto.response.*;\nimport com.fuacs.backend.entity.Semester;\nimport com.fuacs.backend.repository.*;\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.exception.BadRequestException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@Service\n@Transactional(readOnly = true)\npublic class SupervisorDashboardService {\n\n    private final SlotRepository slotRepository;\n    private final SemesterRepository semesterRepository;\n    private final ClassRepository classRepository;\n\n    public SupervisorDashboardService(SlotRepository slotRepository,\n                                      SemesterRepository semesterRepository,\n                                      ClassRepository classRepository) {\n        this.slotRepository = slotRepository;\n        this.semesterRepository = semesterRepository;\n        this.classRepository = classRepository;\n    }\n\n    public SupervisorDashboardResponse getDashboardData(Integer supervisorId, Short requestedSemesterId) {\n        // Validate supervisor ID\n        if (supervisorId == null || supervisorId <= 0) {\n            throw new BadRequestException(\"Invalid supervisor ID. Supervisor ID must be positive\", ErrorCode.BAD_REQUEST);\n        }\n\n        // Validate semester ID if provided\n        if (requestedSemesterId != null && requestedSemesterId <= 0) {\n            throw new BadRequestException(\"Invalid semester ID. Semester ID must be positive\", ErrorCode.BAD_REQUEST);\n        }\n\n        try {\n            // 1. Get available semesters with supervision data\n            var semestersWithData = getSemestersWithSupervisionDataRaw(supervisorId);\n            java.util.Set<Short> dataSemesterIds = semestersWithData.stream().map(Semester::getId).collect(java.util.stream.Collectors.toCollection(java.util.LinkedHashSet::new));\n\n            // 2. Determine selected semester\n            List<SemesterDTO> semesters = toSemesterListIncludingCurrent(semestersWithData);\n            Short selectedSemesterId = determineSelectedSemester(semesters, requestedSemesterId, dataSemesterIds);\n        \n        // 3. Calculate supervisor stats\n        SupervisorStatsDTO stats = calculateSupervisorStats(supervisorId, selectedSemesterId);\n\n        // 4. Get recent supervision activity\n        List<RecentActivitySlotDTO> recentActivity = getRecentSupervisionActivity(supervisorId, selectedSemesterId);\n\n        // 5. Get upcoming exam slots\n        List<TodaySlotDTO> upcomingExams = getUpcomingExamSlots(supervisorId, selectedSemesterId);\n\n            // 6. Build and return response\n            return new SupervisorDashboardResponse(semesters, selectedSemesterId, stats, recentActivity, upcomingExams);\n            \n        } catch (BadRequestException e) {\n            // Re-throw BadRequestException as-is\n            throw e;\n        } catch (Exception e) {\n            // Handle unexpected errors\n            throw new BadRequestException(\"Failed to retrieve supervisor dashboard data: \" + e.getMessage(), ErrorCode.UNKNOWN_ERROR);\n        }\n    }\n\n    private List<Semester> getSemestersWithSupervisionDataRaw(Integer supervisorId) {\n        try {\n            return semesterRepository.findSemestersWithSupervisionData(supervisorId);\n        } catch (Exception e) {\n            // Return empty list if there's an error, don't fail the entire dashboard\n            return List.of();\n        }\n    }\n\n    private List<SemesterDTO> toSemesterListIncludingCurrent(List<Semester> semestersWithData) {\n        java.util.LinkedHashMap<Short, Semester> map = new java.util.LinkedHashMap<>();\n        for (Semester s : semestersWithData) map.put(s.getId(), s);\n        List<Semester> currentSemesters = semesterRepository.findCurrentSemesters();\n        Semester current = !currentSemesters.isEmpty() ? currentSemesters.get(0) : null;\n        if (current != null && !map.containsKey(current.getId())) {\n            // include current semester in list for UX, even if no data\n            map.put(current.getId(), current);\n        }\n        return map.values().stream().map(this::mapToSemesterDTO).collect(Collectors.toList());\n    }\n\n    private Short determineSelectedSemester(List<SemesterDTO> semesters, Short requestedSemesterId, java.util.Set<Short> dataSemesterIds) {\n        // CHANGED: Simplified logic to support \"All Semester\" mode\n        // If specific semester is requested, use it (even if it has no data)\n        // If null is requested, return null to indicate \"All Semester\" mode\n        // Frontend is responsible for auto-selecting current semester on initial load\n        return requestedSemesterId;\n    }\n\n    private SupervisorStatsDTO calculateSupervisorStats(Integer supervisorId, Short semesterId) {\n        try {\n            // CHANGED: Support \"All Semester\" mode when semesterId is null\n            if (semesterId == null) {\n                return slotRepository.calculateSupervisorStatsAllSemesters(supervisorId);\n            }\n            return slotRepository.calculateSupervisorStats(supervisorId, semesterId);\n        } catch (Exception e) {\n            // Return empty stats if there's an error\n            return new SupervisorStatsDTO(0, 0, 0, 0.0, 0);\n        }\n    }\n\n    private List<RecentActivitySlotDTO> getRecentSupervisionActivity(Integer supervisorId, Short selectedSemesterId) {\n        if (selectedSemesterId == null || supervisorId == null) return List.of();\n\n        try {\n            LocalDate today = LocalDate.now();\n            LocalDateTime start = today.minusDays(7).atStartOfDay();\n            LocalDateTime end = today.minusDays(1).atTime(23, 59, 59);\n\n            List<RecentActivitySlotDTO> slots = slotRepository.findRecentSupervisionActivity(supervisorId, selectedSemesterId, start, end);\n\n            // Add attendance stats for each slot (with error handling)\n            slots.forEach(s -> {\n                try {\n                    if (s.getId() != null) {\n                        s.setAttendanceStats(slotRepository.getAttendanceStats(s.getId()));\n                    }\n                } catch (Exception e) {\n                    // Continue without attendance stats for this slot\n                }\n            });\n            return slots;\n        } catch (Exception e) {\n            return List.of();\n        }\n    }\n\n    private List<TodaySlotDTO> getUpcomingExamSlots(Integer supervisorId, Short selectedSemesterId) {\n        if (selectedSemesterId == null || supervisorId == null) return List.of();\n\n        try {\n            LocalDateTime now = LocalDateTime.now(java.time.ZoneId.of(\"Asia/Ho_Chi_Minh\"));\n            int maxResults = 10; // Limit to next 10 upcoming exams\n\n            List<TodaySlotDTO> slots = slotRepository.findUpcomingExamSlots(supervisorId, selectedSemesterId, now, maxResults);\n\n            // Add attendance stats for each slot (with error handling)\n            slots.forEach(s -> {\n                try {\n                    if (s.getId() != null) {\n                        s.setAttendanceStats(slotRepository.getAttendanceStats(s.getId()));\n                    }\n                } catch (Exception e) {\n                    // Continue without attendance stats for this slot\n                }\n            });\n            return slots;\n        } catch (Exception e) {\n            return List.of();\n        }\n    }\n\n    private SemesterDTO mapToSemesterDTO(Semester semester) {\n        return new SemesterDTO(semester.getId(), semester.getName(), semester.getCode(), semester.getStartDate(), semester.getEndDate(), semester.getActive());\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\service\\ZipFileService.java",
      "relative_path": "src/main/java/com/fuacs/backend/service/ZipFileService.java",
      "filename": "ZipFileService.java",
      "size_bytes": 8264,
      "lines": 222,
      "last_modified": "2025-11-11T17:49:27.808061",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.service;\n\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.exception.BadRequestException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n@Service\npublic class ZipFileService {\n\n    private static final Logger logger = LoggerFactory.getLogger(ZipFileService.class);\n\n    private static final long MAX_ZIP_SIZE = 100 * 1024 * 1024; // 100MB\n    private static final long MAX_UNCOMPRESSED_SIZE = 500 * 1024 * 1024; // 500MB\n    private static final long MAX_IMAGE_SIZE = 5 * 1024 * 1024; // 5MB per image\n    private static final int MAX_FILES = 1000;\n\n    private final String tempDir;\n\n    public ZipFileService() {\n        // Read from application.yml or use default\n        this.tempDir = \"./temp\";\n    }\n\n    /**\n     * Extract ZIP file vào temp directory\n     *\n     * @param zipFile ZIP file upload từ client\n     * @return Path to extracted directory\n     * @throws BadRequestException nếu ZIP invalid hoặc quá lớn\n     */\n    public Path extractZipToTemp(MultipartFile zipFile) throws IOException {\n        // Validate ZIP file\n        if (zipFile == null || zipFile.isEmpty()) {\n            throw new BadRequestException(\"ZIP file is required\", ErrorCode.ZIP_FILE_REQUIRED);\n        }\n\n        if (zipFile.getSize() > MAX_ZIP_SIZE) {\n            throw new BadRequestException(\n                \"ZIP file too large (max \" + (MAX_ZIP_SIZE / 1024 / 1024) + \"MB)\",\n                ErrorCode.FILE_TOO_LARGE\n            );\n        }\n\n        // Validate content type - accept multiple ZIP MIME types\n        String contentType = zipFile.getContentType();\n        String originalFilename = zipFile.getOriginalFilename();\n\n        boolean isValidZip = false;\n\n        // Check content type (các browser/OS có thể gửi MIME type khác nhau)\n        if (contentType != null && (\n            contentType.equals(\"application/zip\") ||\n            contentType.equals(\"application/x-zip-compressed\") ||\n            contentType.equals(\"application/x-zip\") ||\n            contentType.equals(\"application/octet-stream\")\n        )) {\n            isValidZip = true;\n        }\n\n        // Fallback: check file extension\n        if (!isValidZip && originalFilename != null && originalFilename.toLowerCase().endsWith(\".zip\")) {\n            isValidZip = true;\n        }\n\n        if (!isValidZip) {\n            throw new BadRequestException(\n                \"Invalid file type, expected ZIP (content-type: \" + contentType + \")\",\n                ErrorCode.INVALID_ZIP_FORMAT\n            );\n        }\n\n        // Create temp directory: ./temp/{uuid}/\n        Path extractDir = Paths.get(tempDir, UUID.randomUUID().toString());\n        Files.createDirectories(extractDir);\n        logger.info(\"Created temp directory: {}\", extractDir);\n\n        long totalUncompressedSize = 0;\n        int fileCount = 0;\n\n        try (ZipInputStream zis = new ZipInputStream(zipFile.getInputStream())) {\n            ZipEntry entry;\n\n            while ((entry = zis.getNextEntry()) != null) {\n                String entryName = entry.getName();\n\n                // Skip directories\n                if (entry.isDirectory()) {\n                    zis.closeEntry();\n                    continue;\n                }\n\n                // Skip hidden/system files (MacOS, Windows)\n                String fileName = entryName.contains(\"/\")\n                    ? entryName.substring(entryName.lastIndexOf(\"/\") + 1)\n                    : entryName;\n                if (fileName.startsWith(\".\") || fileName.equals(\"Thumbs.db\")) {\n                    zis.closeEntry();\n                    continue;\n                }\n\n                fileCount++;\n                if (fileCount > MAX_FILES) {\n                    throw new BadRequestException(\n                        \"Too many files in ZIP (max \" + MAX_FILES + \")\",\n                        ErrorCode.TOO_MANY_FILES\n                    );\n                }\n\n                // Check uncompressed size (ZIP bomb protection)\n                long uncompressedSize = entry.getSize();\n                if (uncompressedSize > MAX_IMAGE_SIZE) {\n                    throw new BadRequestException(\n                        \"Image too large: \" + entryName,\n                        ErrorCode.FILE_TOO_LARGE\n                    );\n                }\n\n                totalUncompressedSize += uncompressedSize;\n                if (totalUncompressedSize > MAX_UNCOMPRESSED_SIZE) {\n                    throw new BadRequestException(\n                        \"Total uncompressed size exceeds limit\",\n                        ErrorCode.FILE_TOO_LARGE\n                    );\n                }\n\n                // Extract file\n                Path destPath = extractDir.resolve(entryName).normalize();\n\n                // Final security check\n                if (!destPath.toAbsolutePath().normalize().startsWith(extractDir.toAbsolutePath().normalize())) {\n                    throw new BadRequestException(\n                        \"Invalid ZIP entry: path traversal\",\n                        ErrorCode.INVALID_ZIP_FORMAT\n                    );\n                }\n\n                // Create parent directories if needed\n                Files.createDirectories(destPath.getParent());\n\n                // Copy file\n                Files.copy(zis, destPath, StandardCopyOption.REPLACE_EXISTING);\n\n                zis.closeEntry();\n            }\n        } catch (IOException e) {\n            // Cleanup on failure\n            cleanupTempDirectory(extractDir);\n            throw new BadRequestException(\"Failed to extract ZIP: \" + e.getMessage(), ErrorCode.FILE_PROCESSING_ERROR);\n        }\n\n        logger.info(\"Extracted {} files from ZIP to {}\", fileCount, extractDir);\n        return extractDir;\n    }\n\n    /**\n     * List image files trong temp directory\n     *\n     * @param tempDir Temp directory path\n     * @return Map<filename, filePath> - filename không có extension\n     */\n    public Map<String, Path> listImageFiles(Path tempDir) throws IOException {\n        Map<String, Path> imageFiles = new HashMap<>();\n\n        Files.walk(tempDir)\n            .filter(Files::isRegularFile)\n            .filter(this::isImageFile)\n            .forEach(path -> {\n                String filename = path.getFileName().toString();\n                imageFiles.put(filename, path);  // Key: full filename with extension\n            });\n\n        logger.info(\"Found {} image files in {}\", imageFiles.size(), tempDir);\n        return imageFiles;\n    }\n\n    /**\n     * Validate nếu file là image (JPG/PNG)\n     */\n    public boolean isImageFile(Path file) {\n        String filename = file.getFileName().toString().toLowerCase();\n        return filename.endsWith(\".jpg\") ||\n               filename.endsWith(\".jpeg\") ||\n               filename.endsWith(\".png\");\n    }\n\n    /**\n     * Cleanup temp directory\n     */\n    public void cleanupTempDirectory(Path tempDir) {\n        try {\n            if (Files.exists(tempDir)) {\n                Files.walk(tempDir)\n                    .sorted((a, b) -> -a.compareTo(b))  // Delete files before directories\n                    .forEach(path -> {\n                        try {\n                            Files.delete(path);\n                        } catch (IOException e) {\n                            logger.warn(\"Failed to delete {}: {}\", path, e.getMessage());\n                        }\n                    });\n                logger.info(\"Cleaned up temp directory: {}\", tempDir);\n            }\n        } catch (IOException e) {\n            logger.error(\"Failed to cleanup temp directory {}: {}\", tempDir, e.getMessage());\n        }\n    }\n}\n"
    }
  ]
}