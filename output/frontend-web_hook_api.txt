{
  "metadata": {
    "codebase": "frontend-web",
    "category": "hook_api",
    "generated_at": "2025-11-28T09:26:42.008899",
    "total_files": 36,
    "total_lines": 4828,
    "total_bytes": 158661
  },
  "files": [
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useAdminUserReports.ts",
      "relative_path": "hooks/api/useAdminUserReports.ts",
      "filename": "useAdminUserReports.ts",
      "size_bytes": 1361,
      "lines": 52,
      "last_modified": "2025-11-28T09:21:56.267521",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useQuery } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, QUERY_KEYS } from \"@/lib/constants\";\n\n/**\n * Types for lecturer semesters with classes response\n */\nexport interface LecturerClass {\n  id: number;\n  code: string;\n  subject: {\n    id: number;\n    name: string;\n    code: string;\n  };\n  isActive: boolean;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface LecturerSemesterWithClasses {\n  id: number;\n  name: string;\n  code: string;\n  startDate: string;\n  endDate: string;\n  isActive: boolean;\n  createdAt: string;\n  updatedAt: string;\n  classes: LecturerClass[];\n}\n\n/**\n * Hook to get lecturer's semesters with classes by userId (for admin view)\n * Returns hierarchical structure: semesters -> classes\n */\nexport const useAdminLecturerSemestersClasses = (\n  userId: number,\n  enabled = true\n) => {\n  return useQuery<LecturerSemesterWithClasses[], Error>({\n    queryKey: QUERY_KEYS.adminUsers.lecturerSemestersClasses(userId),\n    queryFn: async () => {\n      const response = await api.get(\n        API_ENDPOINTS.adminUsers.lecturerSemestersClasses(userId)\n      );\n      return response as unknown as LecturerSemesterWithClasses[];\n    },\n    enabled: enabled && !!userId && userId > 0,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useAttendanceRecords.ts",
      "relative_path": "hooks/api/useAttendanceRecords.ts",
      "filename": "useAttendanceRecords.ts",
      "size_bytes": 3419,
      "lines": 95,
      "last_modified": "2025-11-28T09:21:56.267521",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  attendanceRecordSchema,\n  paginatedAttendanceRecordResponseSchema,\n  updateAttendancePayloadSchema,\n  bulkAttendanceUpdatePayloadSchema,\n  bulkUpdateResultSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  AttendanceRecord,\n  AttendanceRecordQueryParams,\n  PaginatedAttendanceRecordResponse,\n  UpdateAttendancePayload,\n  BulkAttendanceUpdatePayload,\n  BulkUpdateResult,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\n// Get all attendance records with filters\nexport const useGetAttendanceRecords = (\n  params?: AttendanceRecordQueryParams,\n  options?: { enabled?: boolean }\n) => {\n  return useQuery<PaginatedAttendanceRecordResponse, Error>({\n    queryKey: [...QUERY_KEYS.attendanceRecords.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.attendanceRecords.all, {\n        params,\n      });\n      return paginatedAttendanceRecordResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 2, // 2 minutes - attendance data changes frequently\n    enabled: options?.enabled !== undefined ? options.enabled : true,\n  });\n};\n\n// Get single attendance record by ID\nexport const useGetAttendanceRecord = (id: number) => {\n  return useQuery<AttendanceRecord, Error>({\n    queryKey: QUERY_KEYS.attendanceRecords.detail(id),\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.attendanceRecords.byId(id));\n      return attendanceRecordSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 2, // 2 minutes\n  });\n};\n\n// Update attendance record (manual status change)\nexport const useUpdateAttendanceRecord = (slotId: number) => {\n  const queryClient = useQueryClient();\n\n  return useMutation<AttendanceRecord, Error, UpdateAttendancePayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = updateAttendancePayloadSchema.parse(payload); // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(\n        API_ENDPOINTS.attendanceRecords.byId(validatedPayload.recordId),\n        validatedPayload\n      );\n      return attendanceRecordSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Attendance updated successfully!\");\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.attendanceRecords.all,\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating attendance: ${errorMessage}`);\n    },\n  });\n};\n\n// Bulk update attendance records\n// (deprecated) useBulkUpdateAttendance removed in favor of useSubmitAttendance\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useAuth.ts",
      "relative_path": "hooks/api/useAuth.ts",
      "filename": "useAuth.ts",
      "size_bytes": 7726,
      "lines": 283,
      "last_modified": "2025-11-28T09:21:56.267521",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "\"use client\";\n\nimport { useMutation } from \"@tanstack/react-query\";\nimport { AxiosError } from \"axios\";\nimport { useRouter } from \"next/navigation\";\nimport { API_ENDPOINTS } from \"@/lib/constants\";\nimport api from \"@/lib/api-axios\";\nimport {\n  clearAuthSession,\n  clearRefreshToken,\n  getRefreshToken,\n  setAuthToken,\n  setAuthUser,\n  setRefreshToken,\n} from \"@/lib/auth\";\nimport {\n  loginRequestSchema,\n  loginResponseSchema,\n  logoutResponseSchema,\n  refreshTokenRequestSchema,\n  refreshTokenResponseSchema,\n  googleLoginRequestSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  AuthenticatedUser,\n  LoginRequest,\n  LoginResponse,\n  LogoutResponse,\n  RefreshTokenResponse,\n  GoogleLoginRequest,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nconst buildAuthenticatedUser = (\n  response: LoginResponse\n): AuthenticatedUser => ({\n  fullName: response.fullName,\n  username: response.username,\n  roles: response.roles,\n  tokenType: response.tokenType,\n  userId: response.userId,\n});\n\nconst extractErrorMessage = (error: unknown, fallback: string): string => {\n  if (error instanceof AxiosError) {\n    const responseMessage =\n      typeof error.response?.data === \"object\" &&\n      error.response?.data !== null &&\n      \"message\" in error.response.data\n        ? String((error.response.data as { message?: unknown }).message)\n        : undefined;\n\n    return responseMessage ?? error.message ?? fallback;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return fallback;\n};\n\nconst persistSession = (response: LoginResponse) => {\n  setAuthToken(response.accessToken);\n  if (response.refreshToken) {\n    setRefreshToken(response.refreshToken);\n  } else {\n    clearRefreshToken();\n  }\n  setAuthUser(buildAuthenticatedUser(response));\n};\n\nconst mapLoginError = (error: AxiosError) => {\n  const status = error.response?.status;\n\n  if (status === 403) {\n    return {\n      status,\n      toastMessage:\n        \"Your account is inactive. Please contact the administrator.\",\n    } as const;\n  }\n\n  if (status === 401) {\n    return {\n      status,\n      toastMessage: \"Incorrect username or password.\",\n    } as const;\n  }\n\n  return {\n    status: status ?? 0,\n    toastMessage: extractErrorMessage(\n      error,\n      \"Login failed. Please try again later.\"\n    ),\n  } as const;\n};\n\nconst mapGoogleLoginError = (error: AxiosError) => {\n  const status = error.response?.status;\n\n  if (status === 403) {\n    return {\n      status,\n      toastMessage:\n        \"Your account is inactive. Please contact the administrator.\",\n    } as const;\n  }\n\n    const responseMessage =\n      typeof error.response?.data === \"object\" &&\n      error.response?.data !== null &&\n      \"message\" in error.response.data\n        ? String((error.response.data as { message?: unknown }).message)\n        : undefined;\n\n  if (status === 404) {\n    return {\n      status,\n      toastMessage:\n        responseMessage ??\n        \"No matching account was found. Please contact the administrator.\",\n    } as const;\n  }\n\n  return {\n    status: status ?? 0,\n    toastMessage: extractErrorMessage(\n      error,\n      \"Google login failed. Please try again.\"\n    ),\n  } as const;\n};\n\nexport const useLogin = () => {\n  return useMutation<LoginResponse, AxiosError, LoginRequest>({\n    mutationFn: async (payload) => {\n      const validatedPayload = loginRequestSchema.parse(payload);\n\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const rawResponse = await api.post(\n        API_ENDPOINTS.auth.login,\n        validatedPayload\n      );\n      const parsedResponse = loginResponseSchema.parse(rawResponse);\n\n      persistSession(parsedResponse);\n\n      toast.success(\"Login successful\");\n      return parsedResponse;\n    },\n    onError: (error) => {\n      const mapped = mapLoginError(error);\n      toast.error(mapped.toastMessage);\n      throw mapped;\n    },\n  });\n};\n\nexport const useRefreshToken = () => {\n  return useMutation<RefreshTokenResponse, AxiosError, void>({\n    mutationFn: async () => {\n      const token = getRefreshToken();\n      if (!token) {\n        throw new Error(\"Refresh token is missing\");\n      }\n\n      const payload = refreshTokenRequestSchema.parse({ refreshToken: token });\n\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const rawResponse = await api.post(API_ENDPOINTS.auth.refresh, payload);\n      const parsedResponse = refreshTokenResponseSchema.parse(rawResponse);\n\n      persistSession(parsedResponse);\n\n      return parsedResponse;\n    },\n    onError: (error) => {\n      const message = extractErrorMessage(\n        error,\n        \"Session expired. Please log in again.\"\n      );\n      toast.error(message);\n      clearAuthSession();\n    },\n  });\n};\n\nexport const useLogout = () => {\n  return useMutation<LogoutResponse | undefined, AxiosError, void>({\n    mutationFn: async () => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const rawResponse = await api.post(API_ENDPOINTS.auth.logout);\n      if (!rawResponse) {\n        return undefined;\n      }\n\n      const parsed = logoutResponseSchema.safeParse(rawResponse);\n      return parsed.success ? parsed.data : undefined;\n    },\n    onSettled: (data, error) => {\n      clearAuthSession();\n      const message = error\n        ? extractErrorMessage(\n            error,\n            \"Unable to reach server, logged out locally.\"\n          )\n        : data?.message ?? \"Logged out\";\n\n      if (error) {\n        toast.error(message);\n      } else {\n        toast.success(message);\n      }\n    },\n  });\n};\n\nexport const useGoogleLogin = () => {\n  return useMutation<LoginResponse, AxiosError, string>({\n    mutationFn: async (token) => {\n      const payload: GoogleLoginRequest = googleLoginRequestSchema.parse({ token });\n\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const rawResponse = await api.post(API_ENDPOINTS.auth.googleLogin, payload);\n      const parsedResponse = loginResponseSchema.parse(rawResponse);\n\n      persistSession(parsedResponse);\n\n      toast.success(\"Login successful\");\n      return parsedResponse;\n    },\n    onError: (error) => {\n      const mapped = mapGoogleLoginError(error);\n      toast.error(mapped.toastMessage);\n      throw mapped;\n    },\n  });\n};\n\nexport const useForgotPassword = () => {\n  return useMutation<void, AxiosError, { email: string }>({\n    mutationFn: async ({ email }) => {\n      await api.post(API_ENDPOINTS.auth.forgotPassword, { email });\n    },\n    onSuccess: () => {\n      toast.success(\"Password reset link sent! Check your email.\");\n    },\n    onError: (error) => {\n      const message = extractErrorMessage(\n        error,\n        \"Failed to send reset link. Please try again.\"\n      );\n      toast.error(message);\n    },\n  });\n};\n\nexport const useResetPassword = () => {\n  const router = useRouter();\n\n  return useMutation<\n    void,\n    AxiosError,\n    { token: string; newPassword: string; confirmPassword: string }\n  >({\n    mutationFn: async (payload) => {\n      await api.post(API_ENDPOINTS.auth.resetPassword, payload);\n    },\n    onSuccess: () => {\n      toast.success(\"Password reset successfully! Please login.\");\n      router.push(\"/login\");\n    },\n    onError: (error) => {\n      const message = extractErrorMessage(\n        error,\n        \"Failed to reset password. Please try again.\"\n      );\n      toast.error(message);\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useCameras.ts",
      "relative_path": "hooks/api/useCameras.ts",
      "filename": "useCameras.ts",
      "size_bytes": 6374,
      "lines": 187,
      "last_modified": "2025-11-28T09:21:56.267521",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  cameraSchema,\n  createCameraPayloadSchema,\n  paginatedCameraResponseSchema,\n  importCamerasResponseSchema,\n  cameraConnectionTestResultSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreateCameraPayload,\n  PaginatedCameraResponse,\n  CameraQueryParams,\n  Camera,\n  UpdateCameraPayload,\n  CameraConnectionTestResult,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useGetCameras = (params?: CameraQueryParams) => {\n  return useQuery<PaginatedCameraResponse, Error>({\n    queryKey: [...QUERY_KEYS.cameras.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.cameras.all, { params });\n      return paginatedCameraResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useGetCameraById = (id: number) => {\n  return useQuery<Camera, Error>({\n    queryKey: QUERY_KEYS.cameras.detail(id),\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.cameras.byId(id));\n      return cameraSchema.parse(response);\n    },\n\n    enabled: !!id,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateCamera = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Camera, Error, CreateCameraPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createCameraPayloadSchema.parse(payload); // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(\n        API_ENDPOINTS.cameras.all,\n        validatedPayload\n      );\n      return cameraSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Camera created successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.cameras.all });\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.rooms.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error creating camera: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useUpdateCamera = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    Camera,\n    Error,\n    { id: number; payload: UpdateCameraPayload }\n  >({\n    mutationFn: async ({ id, payload }) => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(API_ENDPOINTS.cameras.byId(id), payload);\n      return cameraSchema.parse(response);\n    },\n    onSuccess: (updatedData) => {\n      toast.success(\"Camera updated successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.cameras.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.cameras.detail(updatedData.id),\n      });\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.rooms.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating camera: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useDeleteCamera = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {\n      // Real API call\n      return api.delete(API_ENDPOINTS.cameras.byId(id));\n    },\n    onSuccess: () => {\n      toast.success(\"Camera deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.cameras.all });\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.rooms.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error deleting camera: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useImportCameras = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    { errors: Array<{ rowNumber: number; errorCode: string; message: string }> },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(API_ENDPOINTS.cameras.import, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importCamerasResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All cameras imported successfully!\");\n      } else {\n        toast.warning(\n          `Import completed with ${errorCount} error(s). Check details below.`\n        );\n      }\n      // Invalidate camera queries\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.cameras.all });\n\n      // Invalidate room queries to update camera counts in room table\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.rooms.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n\nexport const useTestCameraConnection = () => {\n  return useMutation<\n    CameraConnectionTestResult,\n    Error,\n    { rtspUrl: string; timeout?: number; signal?: AbortSignal }\n  >({\n    mutationFn: async ({ rtspUrl, timeout = 10, signal }) => {\n      const response = await api.get(API_ENDPOINTS.cameras.testConnection, {\n        params: { rtspUrl, timeout },\n        signal, // Pass AbortSignal to axios for cancellation\n      });\n      return cameraConnectionTestResultSchema.parse(response);\n    },\n    // No toast here - let component handle success/error UI\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useClasses.ts",
      "relative_path": "hooks/api/useClasses.ts",
      "filename": "useClasses.ts",
      "size_bytes": 5549,
      "lines": 178,
      "last_modified": "2025-11-28T09:21:56.267521",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  createClassPayloadSchema,\n  paginatedClassResponseSchema,\n  paginatedSlotResponseSchema,\n  classSchema,\n  importClassesResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreateClassPayload,\n  PaginatedClassResponse,\n  ClassQueryParams,\n  ClassSlotQueryParams,\n  Class,\n  UpdateClassPayload,\n  PaginatedSlotResponse,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useGetClasses = (params?: ClassQueryParams) => {\n  return useQuery<PaginatedClassResponse, Error>({\n    queryKey: [...QUERY_KEYS.classes.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      const response = await api.get(API_ENDPOINTS.classes.all, { params });\n      return paginatedClassResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useGetClassById = (id: number) => {\n  return useQuery<Class, Error>({\n    queryKey: QUERY_KEYS.classes.detail(id),\n\n    queryFn: async () => {\n      // Real API call\n      const response = await api.get(API_ENDPOINTS.classes.byId(id));\n      return classSchema.parse(response);\n    },\n\n    enabled: !!id,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateClass = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Class, Error, CreateClassPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createClassPayloadSchema.parse(payload); // Real API call\n      const response = await api.post(\n        API_ENDPOINTS.classes.all,\n        validatedPayload\n      );\n      return classSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Class created successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.classes.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error creating class: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useUpdateClass = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Class, Error, { id: number; payload: UpdateClassPayload }>(\n    {\n      mutationFn: async ({ id, payload }) => {\n        // Real API call\n        const response = await api.put(API_ENDPOINTS.classes.byId(id), payload);\n        return classSchema.parse(response);\n      },\n      onSuccess: (updatedData) => {\n        toast.success(\"Class updated successfully!\");\n        queryClient.invalidateQueries({ queryKey: QUERY_KEYS.classes.all });\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.classes.detail(updatedData.id),\n        });\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onError: (error: any) => {\n        const errorMessage = formatApiError(error);\n        toast.error(`Error updating class: ${errorMessage}`);\n      },\n    }\n  );\n};\n\nexport const useDeleteClass = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {\n      // Real API call\n      return api.delete(API_ENDPOINTS.classes.byId(id));\n    },\n    onSuccess: () => {\n      toast.success(\"Class deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.classes.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error deleting class: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useGetClassSlots = (\n  classId: number,\n  params?: ClassSlotQueryParams\n) => {\n  return useQuery<PaginatedSlotResponse, Error>({\n    queryKey: [...QUERY_KEYS.classes.slots(classId), params],\n\n    queryFn: async () => {\n      // Real API call\n      const response = await api.get(API_ENDPOINTS.classes.slots(classId), {\n        params,\n      });\n      return paginatedSlotResponseSchema.parse(response);\n    },\n\n    enabled: !!classId,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useImportClasses = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    { errors: Array<{ rowNumber: number; errorCode: string; message: string }> },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(API_ENDPOINTS.classes.import, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importClassesResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All classes imported successfully!\");\n      } else {\n        toast.warning(\n          `Import completed with ${errorCount} error(s). Check details below.`\n        );\n      }\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.classes.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useDataOperatorDashboard.ts",
      "relative_path": "hooks/api/useDataOperatorDashboard.ts",
      "filename": "useDataOperatorDashboard.ts",
      "size_bytes": 624,
      "lines": 15,
      "last_modified": "2025-11-28T09:21:56.267521",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useQuery } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { DataOperatorDashboardResponse } from \"@/types\";\n\nexport const useDataOperatorDashboard = (semesterId?: number) => {\n  return useQuery<DataOperatorDashboardResponse, Error>({\n    queryKey: [\"data-operator-dashboard\", semesterId],\n    queryFn: async () => {\n      const params = semesterId ? { semesterId } : {};\n      const response = await api.get(\"/dashboard/data-operator\", { params });\n      return response as unknown as DataOperatorDashboardResponse;\n    },\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useEnrollments.ts",
      "relative_path": "hooks/api/useEnrollments.ts",
      "filename": "useEnrollments.ts",
      "size_bytes": 11942,
      "lines": 335,
      "last_modified": "2025-11-28T09:21:56.269026",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  createEnrollmentPayloadSchema,\n  updateEnrollmentPayloadSchema,\n  paginatedEnrollmentResponseSchema,\n  enrollmentSchema,\n  bulkEnrollmentResponseSchema,\n  paginatedClassEnrollmentResponseSchema,\n  importEnrollmentsResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreateEnrollmentPayload,\n  PaginatedEnrollmentResponse,\n  EnrollmentQueryParams,\n  Enrollment,\n  UpdateEnrollmentPayload,\n  BulkEnrollmentResponse,\n  PaginatedClassEnrollmentResponse,\n  ClassEnrollmentQueryParams,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useGetEnrollments = (params?: EnrollmentQueryParams) => {\n  return useQuery<PaginatedEnrollmentResponse, Error>({\n    queryKey: [...QUERY_KEYS.enrollments.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.enrollments.all, { params });\n      return paginatedEnrollmentResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useGetEnrollment = (classId: number, studentUserId: number) => {\n  return useQuery<Enrollment, Error>({\n    queryKey: QUERY_KEYS.enrollments.detail(classId, studentUserId),\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.enrollments.byId(classId, studentUserId)\n      );\n      return enrollmentSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateEnrollment = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Enrollment, Error, CreateEnrollmentPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createEnrollmentPayloadSchema.parse(payload);\n      const response = await api.post(\n        API_ENDPOINTS.enrollments.all,\n        validatedPayload\n      );\n      return enrollmentSchema.parse(response);\n    },\n    onSuccess: (data, variables) => {\n      // Check if it's a re-enrollment (200) or new enrollment (201)\n      const isReEnrollment = data.updatedAt !== data.createdAt;\n\n      if (isReEnrollment) {\n        toast.success(\"Student re-enrolled successfully!\");\n      } else {\n        toast.success(\"Student enrolled successfully!\");\n      }\n\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.enrollments.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.enrollments.byClass(variables.classId),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      const backendMessage =\n        error?.response?.data?.message || error?.backendError?.message;\n      const errorCode =\n        error?.response?.data?.code || error?.backendError?.code;\n\n      // Show detailed error message\n      const displayMessage = backendMessage || errorMessage;\n      toast.error(\n        `Error creating enrollment: ${displayMessage}${\n          errorCode ? ` (${errorCode})` : \"\"\n        }`\n      );\n    },\n  });\n};\n\nexport const useUpdateEnrollment = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Enrollment, Error, UpdateEnrollmentPayload>({\n    mutationFn: async (payload) => {\n      // Validate payload (includes classId, studentUserId, isEnrolled)\n      const validatedPayload = updateEnrollmentPayloadSchema.parse(payload);\n\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(\n        API_ENDPOINTS.enrollments.byId(\n          validatedPayload.classId,\n          validatedPayload.studentUserId\n        ),\n        { isEnrolled: validatedPayload.isEnrolled } // API only expects isEnrolled in body\n      );\n\n      // Parse and return full enrollment object as per API docs\n      return enrollmentSchema.parse(response);\n    },\n    onSuccess: (data, variables) => {\n      const action = variables.isEnrolled ? \"re-enrolled\" : \"withdrawn\";\n      toast.success(`Student ${action} successfully!`);\n\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.enrollments.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.enrollments.detail(\n          variables.classId,\n          variables.studentUserId\n        ),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.enrollments.byClass(variables.classId),\n      });\n\n      // Invalidate slot-related queries to ensure roster refreshes immediately\n      // when students are withdrawn or re-enrolled\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.slots.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating enrollment: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useDeleteEnrollment = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, { classId: number; studentUserId: number }>({\n    mutationFn: async ({ classId, studentUserId }) => {\n      await api.delete(\n        `${API_ENDPOINTS.enrollments.all}/${classId}/${studentUserId}`\n      );\n    },\n    onSuccess: (_, variables) => {\n      toast.success(\"Student deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.enrollments.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.enrollments.byClass(variables.classId),\n      });\n      // Invalidate slot-related queries to ensure roster refreshes\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.slots.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      // Mark error as handled to prevent NextJS dev overlay\n      if (error && typeof error === \"object\") {\n        error.handled = true;\n      }\n\n      const errorMessage = formatApiError(error);\n      const backendMessage =\n        error?.response?.data?.message || error?.backendError?.message;\n      const errorCode =\n        error?.response?.data?.code || error?.backendError?.code;\n      const statusCode = error?.response?.status;\n\n      // Handle 403 specifically - likely has attendance records or permission denied\n      if (statusCode === 403) {\n        const displayMessage = backendMessage || \"Cannot delete enrollment - student may have attendance records or you don't have permission\";\n        toast.error(displayMessage);\n        return;\n      }\n\n      // Show detailed error message for other errors\n      const displayMessage = backendMessage || errorMessage;\n      toast.error(\n        `Error deleting enrollment: ${displayMessage}${\n          errorCode ? ` (${errorCode})` : \"\"\n        }`\n      );\n    },\n    throwOnError: false, // Prevent Next.js error overlay\n  });\n};\n\nexport const useBulkEnrollment = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<BulkEnrollmentResponse, Error, File>({\n    mutationFn: async (file) => {\n      // Real API call with multipart/form-data\n      const formData = new FormData();\n      formData.append(\"file\", file);\n\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(\n        API_ENDPOINTS.enrollments.bulk,\n        formData,\n        {\n          headers: {\n            \"Content-Type\": \"multipart/form-data\",\n          },\n        }\n      );\n      return bulkEnrollmentResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const { successCount, skippedCount, failedCount } = data;\n\n      toast.success(\n        `Bulk enrollment completed: ${successCount} successful, ${skippedCount} skipped, ${failedCount} failed`\n      );\n\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.enrollments.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error processing bulk enrollment: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useDownloadEnrollmentTemplate = () => {\n  return useMutation<void, Error, void>({\n    mutationFn: async () => {\n      // Real API call\n      const response = await api.get(API_ENDPOINTS.enrollments.template, {\n        responseType: \"blob\",\n      });\n\n      // Create download link\n      const blob = new Blob([response.data], { type: \"text/csv\" });\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = \"enrollment_template.csv\";\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      window.URL.revokeObjectURL(url);\n    },\n    onSuccess: () => {\n      toast.success(\"Template downloaded successfully!\");\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const apiMessage = error.response?.data?.message;\n      toast.error(apiMessage || `Error downloading template: ${error.message}`);\n    },\n  });\n};\n\nexport const useGetClassEnrollments = (\n  classId: number,\n  params?: ClassEnrollmentQueryParams,\n  options?: { enabled?: boolean }\n) => {\n  return useQuery<PaginatedClassEnrollmentResponse, Error>({\n    queryKey: [...QUERY_KEYS.enrollments.byClass(classId), params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.enrollments.byClass(classId),\n        { params }\n      );\n      return paginatedClassEnrollmentResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 2, // 2 minutes for roster view\n    enabled: options?.enabled ?? true,\n  });\n};\n\nexport const useImportEnrollments = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    { errors: Array<{ rowNumber: number; errorCode: string; message: string }> },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(API_ENDPOINTS.enrollments.import, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importEnrollmentsResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All enrollments imported successfully!\");\n      } else {\n        toast.warning(`Import completed with ${errorCount} error(s). Check details below.`);\n      }\n      // Invalidate all enrollment-related queries\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.enrollments.all });\n\n      // Invalidate class queries to update student counts in tables\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.classes.all });\n\n      // Invalidate slot queries to update rosters\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.slots.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useExamAttendance.ts",
      "relative_path": "hooks/api/useExamAttendance.ts",
      "filename": "useExamAttendance.ts",
      "size_bytes": 3674,
      "lines": 100,
      "last_modified": "2025-11-28T09:21:56.269026",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  examAttendanceRecordSchema,\n  paginatedExamAttendanceRecordResponseSchema,\n  updateExamAttendancePayloadSchema,\n  bulkAttendanceUpdatePayloadSchema,\n  bulkExamUpdateResultSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  ExamAttendanceRecord,\n  ExamAttendanceRecordQueryParams,\n  PaginatedExamAttendanceRecordResponse,\n  UpdateExamAttendancePayload,\n  BulkAttendanceUpdatePayload,\n  BulkExamUpdateResult,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\n// Get all exam attendance records with filters\nexport const useGetExamAttendanceRecords = (\n  params?: ExamAttendanceRecordQueryParams,\n  options?: { enabled?: boolean }\n) => {\n  return useQuery<PaginatedExamAttendanceRecordResponse, Error>({\n    queryKey: [...QUERY_KEYS.examAttendanceRecords.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.examAttendance.all, {\n        params,\n      });\n      return paginatedExamAttendanceRecordResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 2, // 2 minutes - exam attendance data changes frequently\n    enabled: options?.enabled !== undefined ? options.enabled : true,\n  });\n};\n\n// Get single exam attendance record by ID\nexport const useGetExamAttendanceRecord = (id: number) => {\n  return useQuery<ExamAttendanceRecord, Error>({\n    queryKey: QUERY_KEYS.examAttendanceRecords.detail(id),\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.examAttendance.byId(id));\n      return examAttendanceRecordSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 2, // 2 minutes\n  });\n};\n\n// Update exam attendance record (manual status change)\nexport const useUpdateExamAttendance = (slotId: number) => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    ExamAttendanceRecord,\n    Error,\n    { recordId: number; status: \"present\" | \"absent\"; remark: string }\n  >({\n    mutationFn: async ({ recordId, status, remark }) => {\n      const payload: UpdateExamAttendancePayload = { status, remark };\n      const validatedPayload = updateExamAttendancePayloadSchema.parse(payload); // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(\n        API_ENDPOINTS.examAttendance.byId(recordId),\n        validatedPayload\n      );\n      return examAttendanceRecordSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Exam attendance updated successfully!\");\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examAttendanceRecords.all,\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating exam attendance: ${errorMessage}`);\n    },\n  });\n};\n\n// Bulk update exam attendance records\n// (deprecated) useBulkUpdateExamAttendance removed in favor of useSubmitAttendance\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useExamParticipants.ts",
      "relative_path": "hooks/api/useExamParticipants.ts",
      "filename": "useExamParticipants.ts",
      "size_bytes": 9142,
      "lines": 275,
      "last_modified": "2025-11-28T09:21:56.269026",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  paginatedExamParticipantResponseSchema,\n  paginatedExamParticipantAllResponseSchema,\n  examParticipantDetailSchema,\n  addExamParticipantPayloadSchema,\n  updateExamParticipantPayloadSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  PaginatedExamParticipantResponse,\n  PaginatedExamParticipantAllResponse,\n  ExamParticipantDetail,\n  ExamParticipantQueryParams,\n  AddExamParticipantPayload,\n  UpdateExamParticipantPayload,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\n// Get all participants for an exam slot\nexport const useGetExamParticipants = (\n  slotId: number,\n  params?: ExamParticipantQueryParams\n) => {\n  return useQuery<PaginatedExamParticipantResponse, Error>({\n    queryKey: [...QUERY_KEYS.examParticipants.all(slotId), params],\n\n    queryFn: async () => {      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.examParticipants.all(slotId),\n        { params }\n      );\n      return paginatedExamParticipantResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n// Get ALL participants across all subjects for an exam slot (no subject filter)\nexport const useGetAllExamParticipants = (\n  slotId: number,\n  params?: { page?: number; pageSize?: number; search?: string; isEnrolled?: boolean }\n) => {\n  return useQuery<PaginatedExamParticipantAllResponse, Error>({\n    queryKey: [...QUERY_KEYS.examParticipants.allParticipants(slotId), params],\n\n    queryFn: async () => {\n      const response = await api.get(\n        API_ENDPOINTS.examParticipants.allParticipants(slotId),\n        { params }\n      );\n      return paginatedExamParticipantAllResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n// Get individual participant by ID (lines 584-635 in API docs)\nexport const useGetExamParticipant = (\n  slotId: number,\n  participantId: number,\n  enabled = true\n) => {\n  return useQuery<ExamParticipantDetail, Error>({\n    queryKey: QUERY_KEYS.examParticipants.detail(slotId, participantId),\n\n    queryFn: async () => {      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.examParticipants.byId(slotId, participantId)\n      );\n      return examParticipantDetailSchema.parse(response);\n    },\n\n    enabled,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n// Add participant to exam\nexport const useAddExamParticipant = (slotId: number) => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, AddExamParticipantPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = addExamParticipantPayloadSchema.parse(payload);      await api.post(\n        API_ENDPOINTS.examParticipants.all(slotId),\n        validatedPayload\n      );\n    },\n    onSuccess: () => {\n      toast.success(\"Participant added successfully!\");\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examParticipants.all(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examParticipants.allParticipants(slotId),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error adding participant: ${errorMessage}`);\n    },\n  });\n};\n\n// Update participant status (withdraw/re-enroll) - lines 654-722 in API docs\nexport const useUpdateExamParticipant = (\n  slotId: number,\n  participantId: number\n) => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, UpdateExamParticipantPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload =\n        updateExamParticipantPayloadSchema.parse(payload);      await api.put(\n        API_ENDPOINTS.examParticipants.byId(slotId, participantId),\n        validatedPayload\n      );\n    },\n    onSuccess: (_, variables) => {\n      const action = variables.isEnrolled ? \"re-enrolled\" : \"withdrawn\";\n      toast.success(`Participant ${action} successfully!`);\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examParticipants.all(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examParticipants.allParticipants(slotId),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating participant: ${errorMessage}`);\n    },\n  });\n};\n\n// Delete participant (hard delete) - lines 755-797 in API docs\nexport const useDeleteExamParticipant = (\n  slotId: number,\n  participantId: number\n) => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, void>({\n    mutationFn: async () => {      await api.delete(\n        API_ENDPOINTS.examParticipants.byId(slotId, participantId)\n      );\n    },\n    onSuccess: () => {\n      toast.success(\"Participant removed successfully!\");\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examParticipants.all(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examParticipants.allParticipants(slotId),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error removing participant: ${errorMessage}`);\n    },\n  });\n};\n\n/**\n * Add multiple participants to exam slot (one API call per student)\n * Use case: Add a few students at once (3-5 students)\n * For bulk import, use CSV upload feature instead\n */\nexport const useBulkAddExamParticipants = (slotId: number) => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    {\n      totalAttempted: number;\n      successes: number[];\n      failures: Array<{\n        studentUserId: number;\n        rollNumber?: string;\n        error: string;\n      }>;\n    },\n    Error,\n    {\n      subjectId: number;\n      studentUserIds: number[];\n      studentMap?: Map<number, { rollNumber: string; fullName: string }>;\n    }\n  >({\n    mutationFn: async ({ subjectId, studentUserIds, studentMap }) => {\n      const successes: number[] = [];\n      const failures: Array<{\n        studentUserId: number;\n        rollNumber?: string;\n        error: string;\n      }> = [];\n\n      // Use Promise.allSettled to handle partial failures\n      // Each student is added via separate API call\n      const results = await Promise.allSettled(\n        studentUserIds.map((studentUserId) =>\n          api.post(API_ENDPOINTS.examParticipants.all(slotId), {\n            studentUserId,\n            subjectId,\n          })\n        )\n      );\n\n      // Track successes and failures\n      results.forEach((result, index) => {\n        const studentUserId = studentUserIds[index];\n        const rollNumber = studentMap?.get(studentUserId)?.rollNumber;\n\n        if (result.status === \"fulfilled\") {\n          successes.push(studentUserId);\n        } else {\n          failures.push({\n            studentUserId,\n            rollNumber,\n            error: formatApiError(result.reason),\n          });\n        }\n      });\n\n      return {\n        totalAttempted: studentUserIds.length,\n        successes,\n        failures,\n      };\n    },\n    onSuccess: ({ totalAttempted, successes, failures }) => {\n      // Show appropriate toast based on results\n      if (failures.length === 0) {\n        toast.success(\n          `Successfully added all ${successes.length} participant${\n            successes.length > 1 ? \"s\" : \"\"\n          }!`\n        );\n      } else if (successes.length > 0) {\n        toast.warning(\n          `Added ${successes.length}/${totalAttempted} participants. ${failures.length} failed.`\n        );\n        // Log failures for debugging\n        console.error(\"Failed to add participants:\", failures);\n      } else {\n        toast.error(`Failed to add all ${totalAttempted} participants.`);\n        console.error(\"Failed to add participants:\", failures);\n      }\n\n      // Invalidate queries to refresh participant lists\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examParticipants.all(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examParticipants.allParticipants(slotId),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      toast.error(`Bulk add operation failed: ${formatApiError(error)}`);\n    },\n  });\n};\n\n// TODO: Bulk add participants from CSV file - lines 802-976 in API docs\n// TODO: Download CSV template - lines 981-1006 in API docs\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useExamSession.ts",
      "relative_path": "hooks/api/useExamSession.ts",
      "filename": "useExamSession.ts",
      "size_bytes": 5162,
      "lines": 155,
      "last_modified": "2025-11-28T09:21:56.270030",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, QUERY_KEYS, formatApiError } from \"@/lib/constants\";\nimport type { SessionStatusResponse } from \"@/types\";\n\n/**\n * Hook to start exam session for LECTURE_WITH_PT or FINAL_EXAM slots\n */\nexport const useStartExamSession = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<SessionStatusResponse, Error, number>({\n    mutationFn: async (slotId) => {\n      // Response interceptor already unwraps the data\n      const response = await api.post(\n        API_ENDPOINTS.slots.startExamSession(slotId)\n      );\n      return response as unknown as SessionStatusResponse;\n    },\n\n    onSuccess: (data, slotId) => {\n      toast.success(\n        `Exam session started! ${data.activeCameras} camera(s) active.`\n      );\n\n      // Invalidate slot detail and roster to refresh UI\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n    },\n\n    onError: (error: any) => {\n      // Mark error as handled to prevent NextJS dev overlay\n      if (error && typeof error === \"object\") {\n        error.handled = true;\n      }\n      const errorMessage = formatApiError(error);\n\n      // Check if error is related to cameras\n      const isCameraError =\n        errorMessage.includes(\"No active cameras\") ||\n        errorMessage.includes(\"CAMERA_NOT_FOUND\") ||\n        (errorMessage.includes(\"cameras\") && errorMessage.includes(\"configured\"));\n\n      if (isCameraError) {\n        toast.error(\"Cannot start session: No cameras available in this room\");\n      } else {\n        toast.error(`Failed to start exam session: ${errorMessage}`);\n      }\n    },\n\n    // Prevent error from propagating to Error Boundary\n    throwOnError: false,\n  });\n};\n\n/**\n * Hook to stop exam session for LECTURE_WITH_PT or FINAL_EXAM slots\n */\nexport const useStopExamSession = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<SessionStatusResponse, Error, number>({\n    mutationFn: async (slotId) => {\n      // Response interceptor already unwraps the data\n      const response = await api.post(\n        API_ENDPOINTS.slots.stopExamSession(slotId)\n      );\n      return response as unknown as SessionStatusResponse;\n    },\n\n    onSuccess: (data, slotId) => {\n      toast.success(\n        `Exam session stopped. Total recognitions: ${data.totalRecognitions}`\n      );\n\n      // Invalidate slot detail and roster to refresh UI\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n    },\n\n    onError: (error: any) => {\n      // Mark error as handled to prevent NextJS dev overlay\n      if (error && typeof error === \"object\") {\n        error.handled = true;\n      }\n      const errorMessage = formatApiError(error);\n      toast.error(`Failed to stop exam session: ${errorMessage}`);\n    },\n\n    // Prevent error from propagating to Error Boundary\n    throwOnError: false,\n  });\n};\n\n/**\n * Hook to rescan exam attendance (Case 2 rescan with NO DOWNGRADE logic)\n * Students marked PRESENT remain PRESENT even if not detected in rescan\n */\nexport const useRescanExam = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<SessionStatusResponse, Error, number>({\n    mutationFn: async (slotId) => {\n      // Response interceptor already unwraps the data\n      const response = await api.post(API_ENDPOINTS.slots.rescanExam(slotId));\n      return response as unknown as SessionStatusResponse;\n    },\n\n    onSuccess: (_data, slotId) => {\n      toast.success(\n        \"Quét lại thi hoàn tất! Sinh viên Có mặt giữ nguyên, sinh viên Vắng nếu phát hiện sẽ chuyển thành Có mặt.\"\n      );\n\n      // Invalidate slot detail and roster to refresh UI\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n    },\n\n    onError: (error: any) => {\n      // Mark error as handled to prevent NextJS dev overlay\n      if (error && typeof error === \"object\") {\n        error.handled = true;\n      }\n      const errorMessage = formatApiError(error);\n\n      // Check if error is related to cameras\n      const isCameraError =\n        errorMessage.includes(\"No active cameras\") ||\n        errorMessage.includes(\"CAMERA_NOT_FOUND\") ||\n        (errorMessage.includes(\"cameras\") && errorMessage.includes(\"configured\"));\n\n      if (isCameraError) {\n        toast.error(\"Cannot rescan: No cameras available in this room\");\n      } else {\n        toast.error(`Failed to rescan exam: ${errorMessage}`);\n      }\n    },\n\n    // Prevent error from propagating to Error Boundary\n    throwOnError: false,\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useExamSlotDetail.ts",
      "relative_path": "hooks/api/useExamSlotDetail.ts",
      "filename": "useExamSlotDetail.ts",
      "size_bytes": 3753,
      "lines": 137,
      "last_modified": "2025-11-28T09:21:56.270030",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useQuery } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\n\ninterface ExamSlotDetail {\n  slotId: number;\n  title: string;\n  description: string;\n  startTime: string;\n  endTime: string;\n  room: {\n    id: number;\n    name: string;\n    location: string;\n  };\n  staff: {\n    id: number;\n    username: string;\n    email: string;\n    fullName: string;\n  };\n  sessionStatus: \"NOT_STARTED\" | \"IN_PROGRESS\" | \"COMPLETED\" | \"CANCELLED\";\n  subjects: Array<{\n    id: number;\n    name: string;\n    code: string;\n  }>;\n  students: Array<{\n    studentId: number;\n    rollNumber: string;\n    fullName: string;\n    subjectCode: string;\n    subjectName: string;\n    attendanceId: number;\n    status: \"present\" | \"absent\" | \"late\";\n    method: string;\n    recordedAt: string;\n    checkInTime?: string;\n    remark?: string;\n  }>;\n  statistics: {\n    totalStudents: number;\n    presentCount: number;\n    absentCount: number;\n    lateCount: number;\n  };\n}\n\n\n\nexport function useExamSlotDetail(slotId: number) {\n  return useQuery({\n    queryKey: [\"examSlotDetail\", slotId],\n    queryFn: async (): Promise<ExamSlotDetail> => {\n      const endpoint = `/exam-slots/${slotId}/attendance-report`;\n\n      // Our axios instance unwraps { status, data } and returns the inner data\n      // directly. However, handle both shapes defensively.\n      const raw = (await api.get(endpoint)) as unknown;\n\n      let data: unknown | undefined;\n      if (isObject(raw) && \"slotId\" in raw) {\n        data = raw;\n      } else if (isObject(raw) && \"data\" in raw) {\n        data = (raw as Record<string, unknown>).data;\n      }\n\n      if (!data) {\n        throw new Error(\"API response has no data\");\n      }\n\n      return transformToExamSlotDetail(data as unknown);\n    },\n    enabled: !!slotId,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    retry: 1,\n  });\n}\n\n// Transform API response to ExamSlotDetail format\nfunction isObject(v: unknown): v is Record<string, unknown> {\n  return v !== null && typeof v === \"object\";\n}\n\n// Transform API response to ExamSlotDetail format\nfunction transformToExamSlotDetail(data: unknown): ExamSlotDetail {\n  const d = data as any;\n  // Data from /exam-slots/{id}/attendance-report has the correct structure\n  // Backend now returns remark as a single string instead of remarks array\n\n  const result: ExamSlotDetail = {\n    slotId: d.slotId,\n    title: d.title,\n    description: d.description,\n    startTime: d.startTime,\n    endTime: d.endTime,\n    room: {\n      id: d.room.id,\n      name: d.room.name,\n      location: d.room.location\n    },\n    staff: {\n      id: d.staff.id,\n      username: d.staff.username,\n      email: d.staff.email,\n      fullName: d.staff.fullName\n    },\n    sessionStatus: d.sessionStatus,\n    subjects: d.subjects.map((subject: any) => ({\n      id: subject.id,\n      name: subject.name,\n      code: subject.code\n    })),\n    students: d.students.map((student: any) => ({\n      studentId: student.studentId,\n      rollNumber: student.rollNumber,\n      fullName: student.fullName,\n      subjectCode: student.subjectCode,\n      subjectName: student.subjectName,\n      attendanceId: student.attendanceId,\n      status: student.status,\n      method: student.method,\n      recordedAt: student.recordedAt,\n      checkInTime: student.checkInTime,\n      // Backend now returns single remark string\n      remark: student.remark || undefined\n    })),\n    statistics: {\n      totalStudents: d.statistics.totalStudents,\n      presentCount: d.statistics.presentCount,\n      absentCount: d.statistics.absentCount,\n      lateCount: d.statistics.lateCount\n    }\n  };\n\n  return result;\n}\n\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useExamSlotParticipants.ts",
      "relative_path": "hooks/api/useExamSlotParticipants.ts",
      "filename": "useExamSlotParticipants.ts",
      "size_bytes": 2496,
      "lines": 73,
      "last_modified": "2025-11-28T09:21:56.270030",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport { importExamSlotParticipantsResponseSchema } from \"@/lib/zod-schemas\";\nimport { toast } from \"sonner\";\n\n/**\n * Hook to import exam slot participants from CSV file.\n *\n * CSV format: semester_code,start_time,room_name,subject_code,roll_number\n *\n * Example:\n * FA24,2024-12-20T08:00:00,301,PRN212,SE160001\n * FA24,2024-12-20T08:00:00,301,PRN212,SE160002\n *\n * Validation (performed by backend):\n * - Slot exists and is FINAL_EXAM type\n * - Subject is assigned to slot (active ExamSlotSubject)\n * - Student exists and is active\n * - Student is enrolled in subject during semester\n * - No duplicate enrollment (AddOnly mode)\n *\n * Modes:\n * - AddOnly: Skip if student already enrolled in exam\n * - AddAndUpdate: Skip if enrolled, re-enroll if withdrawn\n */\nexport const useImportExamSlotParticipants = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    { errors: Array<{ rowNumber: number; errorCode: string; message: string }> },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(\n        API_ENDPOINTS.examParticipants.import,\n        formData,\n        {\n          headers: {\n            \"Content-Type\": \"multipart/form-data\",\n          },\n        }\n      );\n\n      return importExamSlotParticipantsResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All exam participants imported successfully!\");\n      } else {\n        toast.warning(\n          `Import completed with ${errorCount} error(s). Check details below.`\n        );\n      }\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({ queryKey: [\"examParticipants\"] });\n      queryClient.invalidateQueries({ queryKey: [\"examSlotSubjects\"] });\n      queryClient.invalidateQueries({ queryKey: [\"slots\"] });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useExamSlotSubjects.ts",
      "relative_path": "hooks/api/useExamSlotSubjects.ts",
      "filename": "useExamSlotSubjects.ts",
      "size_bytes": 3756,
      "lines": 106,
      "last_modified": "2025-11-28T09:21:56.270030",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  examSlotSubjectsResponseSchema,\n  addExamSlotSubjectPayloadSchema,\n  addExamSlotSubjectResponseSchema,\n  deleteExamSlotSubjectResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  ExamSlotSubjectsResponse,\n  AddExamSlotSubjectPayload,\n  AddExamSlotSubjectResponse,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\n// Get all subjects assigned to an exam slot\nexport const useGetExamSlotSubjects = (slotId: number) => {\n  return useQuery<ExamSlotSubjectsResponse, Error>({\n    queryKey: QUERY_KEYS.examSlotSubjects.all(slotId),\n\n    queryFn: async () => {      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.examSlotSubjects.all(slotId)\n      );\n      return examSlotSubjectsResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n\n// Add subjects to exam slot (bulk add)\nexport const useAddExamSlotSubject = (slotId: number) => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    AddExamSlotSubjectResponse,\n    Error,\n    AddExamSlotSubjectPayload\n  >({\n    mutationFn: async (payload) => {\n      const validatedPayload = addExamSlotSubjectPayloadSchema.parse(payload);      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(\n        API_ENDPOINTS.examSlotSubjects.all(slotId),\n        validatedPayload\n      );\n      return addExamSlotSubjectResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const count = data.assignedCount;\n      toast.success(\n        `${count} subject${\n          count > 1 ? \"s\" : \"\"\n        } assigned to exam slot successfully!`\n      );\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examSlotSubjects.all(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error assigning subjects: ${errorMessage}`);\n    },\n  });\n};\n\n// Remove subject from exam slot\nexport const useRemoveExamSlotSubject = (slotId: number) => {\n  const queryClient = useQueryClient();\n\n  return useMutation<{ message: string }, Error, { subjectId: number }>({\n    mutationFn: async ({ subjectId }) => {      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.delete(\n        API_ENDPOINTS.examSlotSubjects.byId(slotId, subjectId)\n      );\n      return deleteExamSlotSubjectResponseSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Subject removed from exam slot successfully!\");\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examSlotSubjects.all(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.examParticipants.all(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error removing subject: ${errorMessage}`);\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useExport.ts",
      "relative_path": "hooks/api/useExport.ts",
      "filename": "useExport.ts",
      "size_bytes": 4208,
      "lines": 144,
      "last_modified": "2025-11-28T09:21:56.271031",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useState } from \"react\";\nimport api from \"@/lib/api-axios\";\n\nexport type ExportType = \"classes\" | \"slots\";\nexport type ExportFormat = \"excel\" | \"csv\";\n\ninterface ExportClassesRequest {\n  semesterId: number;\n  ids?: number[];\n  exportAll?: boolean;\n}\n\ninterface ExportSlotsRequest {\n  semesterId: number;\n  ids?: number[];\n  exportAll?: boolean;\n}\n\ninterface UseExportReturn {\n  isExporting: boolean;\n  error: string | null;\n  exportClasses: (\n    format: ExportFormat,\n    request: ExportClassesRequest\n  ) => Promise<void>;\n  exportSlots: (\n    format: ExportFormat,\n    request: ExportSlotsRequest\n  ) => Promise<void>;\n}\n\nexport function useExport(): UseExportReturn {\n  const [isExporting, setIsExporting] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const downloadBlob = (blob: Blob, filename: string) => {\n    const url = window.URL.createObjectURL(blob);\n    const link = document.createElement(\"a\");\n    link.href = url;\n    link.download = filename;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    window.URL.revokeObjectURL(url);\n  };\n\n  const extractFilename = (\n    contentDisposition: string | undefined,\n    defaultName: string\n  ): string => {\n    if (!contentDisposition) return defaultName;\n    const match = contentDisposition.match(/filename=\"?([^\";\\n]+)\"?/);\n    return match ? match[1] : defaultName;\n  };\n\n  const exportData = async (\n    type: ExportType,\n    format: ExportFormat,\n    request: ExportClassesRequest | ExportSlotsRequest\n  ): Promise<void> => {\n    setIsExporting(true);\n    setError(null);\n\n    try {\n      const endpoint = `/export/${type}/${format}`;\n      const response = await api.post(endpoint, request, {\n        responseType: \"blob\",\n        headers: {\n          Accept:\n            format === \"excel\"\n              ? \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n              : \"application/zip\",\n        },\n      });\n\n      // Get response data\n      let blob: Blob;\n\n      // Check if response.data is already a Blob\n      if (response.data instanceof Blob) {\n        blob = response.data;\n      } else if (response instanceof Blob) {\n        // Handle case where response itself is the blob\n        blob = response;\n      } else {\n        // Try to create blob from response data\n        const mimeType = format === \"excel\"\n          ? \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n          : \"application/zip\";\n        blob = new Blob([response.data], { type: mimeType });\n      }\n\n      // Check if blob is valid (not an error response)\n      if (blob.type === \"application/json\" || blob.size === 0) {\n        // Try to read error message from blob\n        const text = await blob.text();\n        try {\n          const errorData = JSON.parse(text);\n          throw new Error(errorData.message || errorData.error || \"Export failed\");\n        } catch {\n          if (blob.size === 0) {\n            throw new Error(\"No data to export\");\n          }\n          throw new Error(text || \"Export failed\");\n        }\n      }\n\n      const contentDisposition = response.headers?.[\"content-disposition\"];\n      const extension = format === \"excel\" ? \"xlsx\" : \"zip\";\n      const defaultFilename = `${type}_export.${extension}`;\n      const filename = extractFilename(contentDisposition, defaultFilename);\n\n      downloadBlob(blob, filename);\n    } catch (err: unknown) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Export failed\";\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setIsExporting(false);\n    }\n  };\n\n  const exportClasses = async (\n    format: ExportFormat,\n    request: ExportClassesRequest\n  ): Promise<void> => {\n    await exportData(\"classes\", format, request);\n  };\n\n  const exportSlots = async (\n    format: ExportFormat,\n    request: ExportSlotsRequest\n  ): Promise<void> => {\n    await exportData(\"slots\", format, request);\n  };\n\n  return {\n    isExporting,\n    error,\n    exportClasses,\n    exportSlots,\n  };\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useLecturerDashboard.ts",
      "relative_path": "hooks/api/useLecturerDashboard.ts",
      "filename": "useLecturerDashboard.ts",
      "size_bytes": 598,
      "lines": 15,
      "last_modified": "2025-11-28T09:21:56.271031",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useQuery } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { LecturerDashboardResponse } from \"@/types\";\n\nexport const useLecturerDashboard = (semesterId?: number) => {\n  return useQuery<LecturerDashboardResponse, Error>({\n    queryKey: [\"lecturer-dashboard\", semesterId],\n    queryFn: async () => {\n      const params = semesterId ? { semesterId } : {};\n      const response = await api.get(\"/dashboard/lecturer\", { params });\n      return response as unknown as LecturerDashboardResponse;\n    },\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useLecturerSchedule.ts",
      "relative_path": "hooks/api/useLecturerSchedule.ts",
      "filename": "useLecturerSchedule.ts",
      "size_bytes": 4017,
      "lines": 120,
      "last_modified": "2025-11-28T09:21:56.271031",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { AxiosError } from \"axios\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, QUERY_KEYS } from \"@/lib/constants\";\nimport { monthlyScheduleSchema, backendScheduleResponseSchema } from \"@/lib/zod-schemas\";\nimport { MonthlySchedule, BackendScheduleItem } from \"@/types\";\nimport { endOfMonth, format, startOfMonth } from \"date-fns\";\n\nexport const useLecturerSchedule = (year: number, month: number) => {\n  return useQuery<MonthlySchedule, AxiosError>({\n    queryKey: QUERY_KEYS.lecturer.schedule(year, month),\n    queryFn: async () => {\n      const response = await api.get(API_ENDPOINTS.lecturer.schedule(year, month));\n      return monthlyScheduleSchema.parse(response);\n    },\n    retry: 1,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n\n// Mock hook for development - replace with real API later\nexport const useLecturerScheduleMock = (year: number, month: number) => {\n  return useQuery<MonthlySchedule, AxiosError>({\n    queryKey: QUERY_KEYS.lecturer.schedule(year, month),\n    queryFn: async () => {\n      // Mock data for testing\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      \n      const mockSchedule: MonthlySchedule = {\n        year,\n        month,\n        days: [\n          {\n            date: `${year}-${String(month).padStart(2, \"0\")}-15`,\n            schedules: [\n              {\n                id: 1,\n                courseCode: \"CS101\",\n                courseName: \"Introduction to Computer Science\",\n                className: \"CS101-01\",\n                classId: \"cs101-01\",\n                startTime: \"08:00\",\n                endTime: \"10:00\",\n                room: \"A101\",\n              },\n              {\n                id: 2,\n                courseCode: \"CS202\",\n                courseName: \"Data Structures\",\n                className: \"CS202-02\",\n                classId: \"cs202-02\",\n                startTime: \"14:00\",\n                endTime: \"16:00\",\n                room: \"B205\",\n              },\n            ],\n          },\n          {\n            date: `${year}-${String(month).padStart(2, \"0\")}-16`,\n            schedules: [\n              {\n                id: 3,\n                courseCode: \"CS303\",\n                courseName: \"Database Systems\",\n                className: \"CS303-01\",\n                classId: \"cs303-01\",\n                startTime: \"10:00\",\n                endTime: \"12:00\",\n                room: \"C301\",\n              },\n            ],\n          },\n        ],\n      };\n\n      return mockSchedule;\n    },\n    retry: 1,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n// New: Backend schedule API (range by start/end date)\nexport type GroupedMonthSchedule = Record<string, BackendScheduleItem[]>; // key: YYYY-MM-DD\n\nfunction getMonthRange(year: number, month: number) {\n  const start = startOfMonth(new Date(year, month - 1, 1));\n  const end = endOfMonth(start);\n  return {\n    startDate: format(start, \"yyyy-MM-dd\"),\n    endDate: format(end, \"yyyy-MM-dd\"),\n  };\n}\n\nexport const useBackendMonthlySchedule = (year: number, month: number) => {\n  return useQuery<{ raw: BackendScheduleItem[]; grouped: GroupedMonthSchedule }, AxiosError>({\n    queryKey: [...QUERY_KEYS.lecturer.schedule(year, month), \"backend\"],\n    queryFn: async () => {\n      const { startDate, endDate } = getMonthRange(year, month);\n      const data = await api.get(\"/schedule\", {\n        params: {\n          startDate,\n          endDate,\n          isActive: true  // Filter active slots only\n        }\n      });\n      const parsed = backendScheduleResponseSchema.parse(data);\n      const raw = parsed.data;\n      const grouped = raw.reduce<GroupedMonthSchedule>((acc, item) => {\n        (acc[item.date] ||= []).push(item);\n        return acc;\n      }, {} as GroupedMonthSchedule);\n      return { raw, grouped };\n    },\n    retry: 1,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useMajors.ts",
      "relative_path": "hooks/api/useMajors.ts",
      "filename": "useMajors.ts",
      "size_bytes": 5229,
      "lines": 162,
      "last_modified": "2025-11-28T09:21:56.271031",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  createMajorPayloadSchema,\n  paginatedMajorResponseSchema,\n  majorSchema,\n  importMajorsResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreateMajorPayload,\n  PaginatedMajorResponse,\n  MajorQueryParams,\n  Major,\n  UpdateMajorPayload,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useGetMajors = (params?: MajorQueryParams) => {\n  return useQuery<PaginatedMajorResponse, Error>({\n    queryKey: [...QUERY_KEYS.majors.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      const response = await api.get(API_ENDPOINTS.majors.all, { params });\n      return paginatedMajorResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useGetMajorById = (id: number) => {\n  return useQuery<Major, Error>({\n    queryKey: QUERY_KEYS.majors.detail(id),\n\n    queryFn: async () => {\n      // Real API call\n      const response = await api.get(API_ENDPOINTS.majors.byId(id));\n      return majorSchema.parse(response);\n    },\n\n    enabled: !!id,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateMajor = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Major, Error, CreateMajorPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createMajorPayloadSchema.parse(payload);\n\n      // Real API call\n      const response = await api.post(\n        API_ENDPOINTS.majors.all,\n        validatedPayload\n      );\n      return majorSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Major created successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.majors.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error creating major: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useUpdateMajor = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Major, Error, { id: number; payload: UpdateMajorPayload }>(\n    {\n      mutationFn: async ({ id, payload }) => {\n        // Real API call\n        const response = await api.put(API_ENDPOINTS.majors.byId(id), payload);\n        return majorSchema.parse(response);\n      },\n      onSuccess: (updatedData) => {\n        toast.success(\"Major updated successfully!\");\n        queryClient.invalidateQueries({ queryKey: QUERY_KEYS.majors.all });\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.majors.detail(updatedData.id),\n        });\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onError: (error: any) => {\n        const errorMessage = formatApiError(error);\n        toast.error(`Error updating major: ${errorMessage}`);\n      },\n    }\n  );\n};\n\nexport const useDeleteMajor = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {\n      // Real API call\n      return api.delete(API_ENDPOINTS.majors.byId(id));\n    },\n    onSuccess: () => {\n      toast.success(\"Major deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.majors.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error deleting major: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useImportMajors = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    { errors: Array<{ rowNumber: number; errorCode: string; message: string }> },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(API_ENDPOINTS.majors.import, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importMajorsResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All majors imported successfully!\");\n      } else {\n        toast.warning(\n          `Import completed with ${errorCount} error(s). Check details below.`\n        );\n      }\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.majors.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n\n// TODO: Nested GET /majors/{id}/subjects\n// Previously exported useGetMajorSubjects but removed since the current UI\n// navigates to the generic Subjects page filtered by majorId. Re-add a\n// paginated hook aligned to docs if we introduce an inline subjects-by-major view.\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\usePermissions.ts",
      "relative_path": "hooks/api/usePermissions.ts",
      "filename": "usePermissions.ts",
      "size_bytes": 4300,
      "lines": 120,
      "last_modified": "2025-11-28T09:21:56.271031",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  createPermissionPayloadSchema,\n  paginatedPermissionResponseSchema,\n  permissionSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreatePermissionPayload,\n  PaginatedPermissionResponse,\n  PermissionQueryParams,\n  Permission,\n  UpdatePermissionPayload,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\n// GET /permissions - List permissions with pagination, search, sort, and active filter\nexport const useGetPermissions = (params?: PermissionQueryParams) => {\n  return useQuery<PaginatedPermissionResponse, Error>({\n    queryKey: [...QUERY_KEYS.permissions.all, params],\n    queryFn: async () => {\n      const response = await api.get(API_ENDPOINTS.permissions.all, { params });\n      return paginatedPermissionResponseSchema.parse(response);\n    },\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n\n// GET /permissions/{id} - Get permission by ID\nexport const useGetPermissionById = (id: number) => {\n  return useQuery<Permission, Error>({\n    queryKey: QUERY_KEYS.permissions.detail(id),\n    queryFn: async () => {\n      const response = await api.get(API_ENDPOINTS.permissions.byId(id));\n      return permissionSchema.parse(response);\n    },\n    enabled: id > 0,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n// POST /permissions - Create a new permission\nexport const useCreatePermission = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Permission, Error, CreatePermissionPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createPermissionPayloadSchema.parse(payload);\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(\n        API_ENDPOINTS.permissions.all,\n        validatedPayload\n      );\n      return permissionSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Permission created successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.permissions.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error creating permission: ${errorMessage}`);\n    },\n  });\n};\n\n// PUT /permissions/{id} - Update a permission\nexport const useUpdatePermission = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    Permission,\n    Error,\n    { id: number; payload: UpdatePermissionPayload }\n  >({\n    mutationFn: async ({ id, payload }) => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(\n        API_ENDPOINTS.permissions.byId(id),\n        payload\n      );\n      return permissionSchema.parse(response);\n    },\n    onSuccess: (updatedData) => {\n      toast.success(\"Permission updated successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.permissions.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.permissions.detail(updatedData.id),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating permission: ${errorMessage}`);\n    },\n  });\n};\n\n// DELETE /permissions/{id} - Delete a permission\nexport const useDeletePermission = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      return api.delete(API_ENDPOINTS.permissions.byId(id));\n    },\n    onSuccess: () => {\n      toast.success(\"Permission deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.permissions.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error deleting permission: ${errorMessage}`);\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useRoles.ts",
      "relative_path": "hooks/api/useRoles.ts",
      "filename": "useRoles.ts",
      "size_bytes": 4157,
      "lines": 119,
      "last_modified": "2025-11-28T09:21:56.271031",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  createRolePayloadSchema,\n  paginatedRoleResponseSchema,\n  roleSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreateRolePayload,\n  PaginatedRoleResponse,\n  RoleQueryParams,\n  Role,\n  UpdateRolePayload,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\n// GET /roles - List roles with pagination, search, sort, and active filter\nexport const useGetRoles = (params?: RoleQueryParams) => {\n  return useQuery<PaginatedRoleResponse, Error>({\n    queryKey: [...QUERY_KEYS.roles.all, params],\n    queryFn: async () => {\n      // Transform exclude array to comma-separated string for API\n      const apiParams = params?.exclude\n        ? { ...params, exclude: params.exclude.join(\",\") }\n        : params;\n      const response = await api.get(API_ENDPOINTS.roles.all, {\n        params: apiParams,\n      });\n      return paginatedRoleResponseSchema.parse(response);\n    },\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n\n// GET /roles/{id} - Get role by ID\nexport const useGetRoleById = (id: number) => {\n  return useQuery<Role, Error>({\n    queryKey: QUERY_KEYS.roles.detail(id),\n    queryFn: async () => {\n      const response = await api.get(API_ENDPOINTS.roles.byId(id));\n      return roleSchema.parse(response);\n    },\n    enabled: id > 0,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n// POST /roles - Create a new role\nexport const useCreateRole = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Role, Error, CreateRolePayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createRolePayloadSchema.parse(payload);\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(\n        API_ENDPOINTS.roles.all,\n        validatedPayload\n      );\n      return roleSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Role created successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.roles.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error creating role: ${errorMessage}`);\n    },\n  });\n};\n\n// PUT /roles/{id} - Update a role\nexport const useUpdateRole = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Role, Error, { id: number; payload: UpdateRolePayload }>({\n    mutationFn: async ({ id, payload }) => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(API_ENDPOINTS.roles.byId(id), payload);\n      return roleSchema.parse(response);\n    },\n    onSuccess: (updatedData) => {\n      toast.success(\"Role updated successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.roles.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.roles.detail(updatedData.id),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating role: ${errorMessage}`);\n    },\n  });\n};\n\n// DELETE /roles/{id} - Delete a role\nexport const useDeleteRole = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      return api.delete(API_ENDPOINTS.roles.byId(id));\n    },\n    onSuccess: () => {\n      toast.success(\"Role deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.roles.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error deleting role: ${errorMessage}`);\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useRooms.ts",
      "relative_path": "hooks/api/useRooms.ts",
      "filename": "useRooms.ts",
      "size_bytes": 6523,
      "lines": 207,
      "last_modified": "2025-11-28T09:21:56.272029",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  createRoomPayloadSchema,\n  paginatedRoomResponseSchema,\n  roomSchema,\n  roomCamerasResponseSchema,\n  roomSlotsResponseSchema,\n  importRoomsResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreateRoomPayload,\n  PaginatedRoomResponse,\n  RoomQueryParams,\n  Room,\n  UpdateRoomPayload,\n  RoomCameraQueryParams,\n  RoomSlotQueryParams,\n  RoomCamerasResponse,\n  RoomSlotsResponse,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useGetRooms = (params?: RoomQueryParams) => {\n  return useQuery<PaginatedRoomResponse, Error>({\n    queryKey: [...QUERY_KEYS.rooms.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.rooms.all, { params });\n      return paginatedRoomResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useGetRoomById = (id: number) => {\n  return useQuery<Room, Error>({\n    queryKey: QUERY_KEYS.rooms.detail(id),\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.rooms.byId(id));\n      return roomSchema.parse(response);\n    },\n\n    enabled: !!id,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateRoom = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Room, Error, CreateRoomPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createRoomPayloadSchema.parse(payload);\n\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(\n        API_ENDPOINTS.rooms.all,\n        validatedPayload\n      );\n      return roomSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Room created successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.rooms.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error creating room: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useUpdateRoom = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Room, Error, { id: number; payload: UpdateRoomPayload }>({\n    mutationFn: async ({ id, payload }) => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(API_ENDPOINTS.rooms.byId(id), payload);\n      return roomSchema.parse(response);\n    },\n    onSuccess: (updatedData) => {\n      toast.success(\"Room updated successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.rooms.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.rooms.detail(updatedData.id),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating room: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useDeleteRoom = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {\n      // Real API call\n      return api.delete(API_ENDPOINTS.rooms.byId(id));\n    },\n    onSuccess: () => {\n      toast.success(\"Room deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.rooms.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error deleting room: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useGetRoomCameras = (\n  roomId: number,\n  params?: RoomCameraQueryParams\n) => {\n  return useQuery<RoomCamerasResponse, Error>({\n    queryKey: [...QUERY_KEYS.rooms.cameras(roomId), params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.rooms.cameras(roomId), {\n        params,\n      });\n      return roomCamerasResponseSchema.parse(response);\n    },\n\n    enabled: !!roomId,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useGetRoomSlots = (\n  roomId: number,\n  params?: RoomSlotQueryParams\n) => {\n  return useQuery<RoomSlotsResponse, Error>({\n    queryKey: [...QUERY_KEYS.rooms.slots(roomId), params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.rooms.slots(roomId), {\n        params,\n      });\n      return roomSlotsResponseSchema.parse(response);\n    },\n\n    enabled: !!roomId,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useImportRooms = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    { errors: Array<{ rowNumber: number; errorCode: string; message: string }> },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(API_ENDPOINTS.rooms.import, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importRoomsResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All rooms imported successfully!\");\n      } else {\n        toast.warning(\n          `Import completed with ${errorCount} error(s). Check details below.`\n        );\n      }\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.rooms.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useRoster.ts",
      "relative_path": "hooks/api/useRoster.ts",
      "filename": "useRoster.ts",
      "size_bytes": 3497,
      "lines": 113,
      "last_modified": "2025-11-28T09:21:56.272029",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "\"use client\";\n\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { AxiosError } from \"axios\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, QUERY_KEYS } from \"@/lib/constants\";\nimport { rosterSchema, submitAttendancePayloadSchema } from \"@/lib/zod-schemas\";\nimport { Roster, SubmitAttendancePayload } from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useRoster = (classId: string, date: string) => {\n  return useQuery<Roster, AxiosError>({\n    queryKey: QUERY_KEYS.lecturer.roster(classId, date),\n    queryFn: async () => {\n      const response = await api.get(API_ENDPOINTS.lecturer.roster(classId, date));\n      return rosterSchema.parse(response.data);\n    },\n    enabled: !!classId && !!date,\n    retry: 1,\n    staleTime: 1000 * 60 * 2, // 2 minutes\n  });\n};\n\nexport const useSubmitAttendance = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<unknown, AxiosError, SubmitAttendancePayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = submitAttendancePayloadSchema.parse(payload);\n      const response = await api.post(\n        API_ENDPOINTS.lecturer.submitAttendance,\n        validatedPayload\n      );\n      return response.data;\n    },\n    onSuccess: () => {\n      toast.success(\"Attendance submitted successfully\");\n      queryClient.invalidateQueries({\n        queryKey: [\"lecturer\", \"roster\"],\n      });\n    },\n    onError: (error) => {\n      const message =\n        error.response?.data &&\n        typeof error.response.data === \"object\" &&\n        \"message\" in error.response.data\n          ? String(error.response.data.message)\n          : \"Failed to submit attendance\";\n      toast.error(message);\n    },\n  });\n};\n\n// Mock hook for development\nexport const useRosterMock = (classId: string, date: string) => {\n  return useQuery<Roster, AxiosError>({\n    queryKey: QUERY_KEYS.lecturer.roster(classId, date),\n    queryFn: async () => {\n      await new Promise((resolve) => setTimeout(resolve, 500));\n\n      const mockRoster: Roster = {\n        classId,\n        className: classId.toUpperCase(),\n        courseName: \"Introduction to Computer Science\",\n        courseCode: \"CS101\",\n        scheduleDate: date,\n        students: [\n          {\n            id: \"1\",\n            studentId: \"SE12345\",\n            fullName: \"Nguyen Van A\",\n            email: \"nguyenvana@example.com\",\n            avatarUrl: undefined,\n          },\n          {\n            id: \"2\",\n            studentId: \"SE12346\",\n            fullName: \"Tran Thi B\",\n            email: \"tranthib@example.com\",\n            avatarUrl: undefined,\n          },\n          {\n            id: \"3\",\n            studentId: \"SE12347\",\n            fullName: \"Le Van C\",\n            email: \"levanc@example.com\",\n            avatarUrl: undefined,\n          },\n          {\n            id: \"4\",\n            studentId: \"SE12348\",\n            fullName: \"Pham Thi D\",\n            email: \"phamthid@example.com\",\n            avatarUrl: undefined,\n          },\n          {\n            id: \"5\",\n            studentId: \"SE12349\",\n            fullName: \"Hoang Van E\",\n            email: \"hoangvane@example.com\",\n            avatarUrl: undefined,\n          },\n        ],\n        attendanceRecords: [],\n      };\n\n      return mockRoster;\n    },\n    enabled: !!classId && !!date,\n    retry: 1,\n    staleTime: 1000 * 60 * 2,\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useSemesters.ts",
      "relative_path": "hooks/api/useSemesters.ts",
      "filename": "useSemesters.ts",
      "size_bytes": 9269,
      "lines": 295,
      "last_modified": "2025-11-28T09:21:56.272029",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  createSemesterPayloadSchema,\n  paginatedSemesterResponseSchema,\n  paginatedSemesterSubjectResponseSchema,\n  paginatedSemesterStudentResponseSchema,\n  paginatedSemesterClassResponseSchema,\n  semesterSchema,\n  importSemestersResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreateSemesterPayload,\n  PaginatedSemesterResponse,\n  SemesterQueryParams,\n  Semester,\n  UpdateSemesterPayload,\n  PaginatedSemesterSubjectResponse,\n  SemesterSubjectQueryParams,\n  PaginatedSemesterStudentResponse,\n  SemesterStudentQueryParams,\n  PaginatedSemesterClassResponse,\n  SemesterClassQueryParams,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useGetSemesters = (params?: SemesterQueryParams) => {\n  return useQuery<PaginatedSemesterResponse, Error>({\n    queryKey: [...QUERY_KEYS.semesters.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.semesters.all, { params });\n      return paginatedSemesterResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useGetSemesterById = (id: number) => {\n  return useQuery<Semester, Error>({\n    queryKey: QUERY_KEYS.semesters.detail(id),\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.semesters.byId(id));\n      return semesterSchema.parse(response);\n    },\n\n    enabled: !!id && id > 0,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateSemester = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Semester, Error, CreateSemesterPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createSemesterPayloadSchema.parse(payload);\n\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(\n        API_ENDPOINTS.semesters.all,\n        validatedPayload\n      );\n      return semesterSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Semester created successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.semesters.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n\nexport const useUpdateSemester = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    Semester,\n    Error,\n    { id: number; payload: UpdateSemesterPayload }\n  >({\n    mutationFn: async ({ id, payload }) => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(API_ENDPOINTS.semesters.byId(id), payload);\n      return semesterSchema.parse(response);\n    },\n    onSuccess: (updatedData) => {\n      toast.success(\"Semester updated successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.semesters.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.semesters.detail(updatedData.id),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n\nexport const useDeleteSemester = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {\n      // Real API call\n      return api.delete(API_ENDPOINTS.semesters.byId(id));\n    },\n    onSuccess: () => {\n      toast.success(\"Semester deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.semesters.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n\n/**\n * Hook to import semesters from CSV file\n * Supports two modes: AddOnly (skip duplicates) or AddAndUpdate (upsert)\n */\nexport const useImportSemesters = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    { errors: Array<{ rowNumber: number; errorCode: string; message: string }> },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(API_ENDPOINTS.semesters.import, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importSemestersResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All semesters imported successfully!\");\n      } else {\n        toast.warning(`Import completed with ${errorCount} error(s). Check details below.`);\n      }\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.semesters.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n\n/**\n * Hook to get subjects that have active classes in a specific semester\n * Useful for filtering subjects when assigning to exam slots\n */\nexport const useGetSemesterSubjects = (\n  semesterId: number,\n  params?: SemesterSubjectQueryParams,\n  enabled = true\n) => {\n  return useQuery<PaginatedSemesterSubjectResponse, Error>({\n    queryKey: [...QUERY_KEYS.semesters.subjects(semesterId), params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.semesters.subjects(semesterId),\n        {\n          params,\n        }\n      );\n      return paginatedSemesterSubjectResponseSchema.parse(response);\n    },\n\n    enabled,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n/**\n * Hook to get students with active enrollments in a specific semester\n * Useful for adding participants to exam slots\n * Can filter by subjectId to show only students enrolled in specific subject\n */\nexport const useGetSemesterStudents = (\n  semesterId: number,\n  params?: SemesterStudentQueryParams,\n  enabled = true\n) => {\n  return useQuery<PaginatedSemesterStudentResponse, Error>({\n    queryKey: [...QUERY_KEYS.semesters.students(semesterId), params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.semesters.students(semesterId),\n        {\n          params,\n        }\n      );\n      return paginatedSemesterStudentResponseSchema.parse(response);\n    },\n\n    enabled,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n/**\n * Hook to get classes in a specific semester\n * Shows all classes belonging to the semester with subject info and student count\n */\nexport const useGetSemesterClasses = (\n  semesterId: number,\n  params?: SemesterClassQueryParams,\n  enabled = true\n) => {\n  return useQuery<PaginatedSemesterClassResponse, Error>({\n    queryKey: [...QUERY_KEYS.semesters.classes(semesterId), params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.semesters.classes(semesterId),\n        {\n          params,\n        }\n      );\n      return paginatedSemesterClassResponseSchema.parse(response);\n    },\n\n    enabled,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n/**\n * Simple semester type for student semesters API\n */\nexport interface StudentSemester {\n  id: number;\n  name: string;\n  code: string;\n  startDate?: string;\n  endDate?: string;\n  isActive?: boolean;\n}\n\n/**\n * Hook to get semesters where a specific student has enrolled classes.\n * Used by admin to filter attendance history by relevant semesters only.\n */\nexport const useStudentSemesters = (\n  studentId: number,\n  enabled = true\n) => {\n  return useQuery<StudentSemester[], Error>({\n    queryKey: QUERY_KEYS.students.semesters(studentId),\n    queryFn: async () => {\n      const response = await api.get(API_ENDPOINTS.students.semesters(studentId));\n      return response as unknown as StudentSemester[];\n    },\n    enabled: enabled && !!studentId && studentId > 0,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useSlotDetail.ts",
      "relative_path": "hooks/api/useSlotDetail.ts",
      "filename": "useSlotDetail.ts",
      "size_bytes": 632,
      "lines": 19,
      "last_modified": "2025-11-28T09:21:56.273031",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { slotDetailResponseSchema } from \"@/lib/zod-schemas\";\nimport { SlotDetailData } from \"@/types\";\n\nexport const useSlotDetail = (slotId: number) => {\n  return useQuery<SlotDetailData, Error>({\n    queryKey: [\"slots\", slotId, \"detail\"],\n    queryFn: async () => {\n      const data = await api.get(`/slots/${slotId}/detail`);\n      const parsed = slotDetailResponseSchema.parse(data);\n      return parsed.data;\n    },\n    enabled: Number.isFinite(slotId) && slotId > 0,\n    staleTime: 1000 * 60 * 2,\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useSlotRoster.ts",
      "relative_path": "hooks/api/useSlotRoster.ts",
      "filename": "useSlotRoster.ts",
      "size_bytes": 3697,
      "lines": 103,
      "last_modified": "2025-11-28T09:21:56.273536",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport api from \"@/lib/api-axios\";\nimport { QUERY_KEYS, API_ENDPOINTS, formatApiError } from \"@/lib/constants\";\nimport {\n  slotRosterResponseSchema,\n  slotActionResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport type { SlotRosterResponse } from \"@/types\";\n\nexport const useGetSlotRoster = (slotId: number) => {\n  return useQuery<SlotRosterResponse, Error>({\n    queryKey: QUERY_KEYS.slots.roster(slotId),\n    queryFn: async () => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.slots.roster(slotId));\n      return slotRosterResponseSchema.parse(response);\n    },\n    staleTime: 1000 * 60 * 2, // 2 minutes\n  });\n};\n\nexport const useStartSession = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async (slotId: number) => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(API_ENDPOINTS.slots.startSession(slotId));\n      return slotActionResponseSchema.parse(response);\n    },\n    onSuccess: (_, slotId) => {\n      toast.success(\"Session started successfully!\");\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n    },\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Failed to start session: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useRescanSession = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async (slotId: number) => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(API_ENDPOINTS.slots.rescan(slotId));\n      return slotActionResponseSchema.parse(response);\n    },\n    onSuccess: (_, slotId) => {\n      toast.success(\"Rescan completed successfully!\");\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n    },\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Failed to rescan: ${errorMessage}`);\n    },\n  });\n};\n\n// export const useFinalizeSlot = () => {\n//   const queryClient = useQueryClient();\n\n//   return useMutation({\n//     mutationFn: async ({\n//       slotId,\n//       notYetStatusResolution,\n//     }: {\n//       slotId: number;\n//       notYetStatusResolution: \"MARK_AS_PRESENT\" | \"MARK_AS_ABSENT\";\n//     }) => {\n//       // Interceptor automatically unwraps { status, data } → returns data directly\n//       const response = await api.post(API_ENDPOINTS.slots.finalize(slotId), {\n//         notYetStatusResolution,\n//       });\n//       return slotActionResponseSchema.parse(response);\n//     },\n//     onSuccess: (_, { slotId }) => {\n//       toast.success(\"Slot finalized successfully!\");\n//       queryClient.invalidateQueries({\n//         queryKey: QUERY_KEYS.slots.roster(slotId),\n//       });\n//       queryClient.invalidateQueries({\n//         queryKey: QUERY_KEYS.slots.detail(slotId),\n//       });\n//       queryClient.invalidateQueries({ queryKey: QUERY_KEYS.slots.all });\n//     },\n//     onError: (error: any) => {\n//       const errorMessage = formatApiError(error);\n//       toast.error(`Failed to finalize slot: ${errorMessage}`);\n//     },\n//   });\n// };\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useSlots.ts",
      "relative_path": "hooks/api/useSlots.ts",
      "filename": "useSlots.ts",
      "size_bytes": 10149,
      "lines": 304,
      "last_modified": "2025-11-28T09:21:56.273536",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  createSlotPayloadSchema,\n  paginatedSlotResponseSchema,\n  slotSchema,\n  importSlotsResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreateSlotPayload,\n  PaginatedSlotResponse,\n  SlotQueryParams,\n  Slot,\n  UpdateSlotPayload,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\n// Get all slots with filters\nexport const useGetSlots = (\n  params?: SlotQueryParams,\n  options?: { enabled?: boolean }\n) => {\n  const result = useQuery<PaginatedSlotResponse, Error>({\n    queryKey: [...QUERY_KEYS.slots.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.slots.all, { params });\n      return paginatedSlotResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n    enabled: options?.enabled !== undefined ? options.enabled : true,\n  });\n\n  return result;\n};\n\n// Get single slot by ID\nexport const useGetSlot = (id: number) => {\n  return useQuery<Slot, Error>({\n    queryKey: QUERY_KEYS.slots.detail(id),\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.slots.byId(id));\n      return slotSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n// Create new slot\nexport const useCreateSlot = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Slot, Error, CreateSlotPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createSlotPayloadSchema.parse(payload);\n\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(\n        API_ENDPOINTS.slots.all,\n        validatedPayload\n      );\n      return slotSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Slot created successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.slots.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n\n      toast.error(`Error creating slot: ${errorMessage}`);\n    },\n  });\n};\n\n// Update existing slot\nexport const useUpdateSlot = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Slot, Error, { id: number; payload: UpdateSlotPayload }>({\n    mutationFn: async ({ id, payload }) => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(API_ENDPOINTS.slots.byId(id), payload);\n      return slotSchema.parse(response);\n    },\n    onSuccess: (updatedData) => {\n      toast.success(\"Slot updated successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.slots.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(updatedData.id),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating slot: ${errorMessage}`);\n    },\n  });\n};\n\n// Update slot category only (Lecturer - SLOT_UPDATE_CATEGORY permission)\nexport const useUpdateSlotCategory = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    Slot,\n    Error,\n    { id: number; slotCategory: \"LECTURE\" | \"LECTURE_WITH_PT\" }\n  >({\n    mutationFn: async ({ id, slotCategory }) => {\n      // Call the dedicated category update endpoint\n      const response = await api.put(API_ENDPOINTS.slots.updateCategory(id), {\n        slotCategory,\n      });\n      return slotSchema.parse(response);\n    },\n    onSuccess: (updatedData) => {\n      toast.success(\"Slot category updated successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.slots.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(updatedData.id),\n      });\n      // Also invalidate all staff profile queries (including slots)\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.staffProfiles.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating slot category: ${errorMessage}`);\n    },\n  });\n};\n\n// Delete slot\nexport const useDeleteSlot = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {\n      // Real API call\n      return api.delete(API_ENDPOINTS.slots.byId(id));\n    },\n    onSuccess: () => {\n      toast.success(\"Slot deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.slots.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error deleting slot: ${errorMessage}`);\n    },\n  });\n};\n\n// Import slots from CSV\nexport const useImportSlots = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    {\n      errors: Array<{ rowNumber: number; errorCode: string; message: string }>;\n    },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(API_ENDPOINTS.slots.import, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importSlotsResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All slots imported successfully!\");\n      } else {\n        toast.warning(\n          `Import completed with ${errorCount} error(s). Check details below.`\n        );\n      }\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.slots.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n\n// Import exam slots from CSV\nexport const useImportExamSlots = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    {\n      errors: Array<{ rowNumber: number; errorCode: string; message: string }>;\n    },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(API_ENDPOINTS.slots.importExams, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importSlotsResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All exam slots imported successfully!\");\n      } else {\n        toast.warning(\n          `Exam import completed with ${errorCount} error(s). Check details below.`\n        );\n      }\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.slots.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n\n// Check if slot has attendance records (PRESENT or ABSENT only, ignores NOT_YET)\nexport const useCheckSlotHasAttendance = (slotId: number, options?: { enabled?: boolean }) => {\n  return useQuery<boolean, Error>({\n    queryKey: QUERY_KEYS.slots.hasAttendance(slotId),\n    queryFn: async () => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.slots.hasAttendanceRecords(slotId));\n      return response as unknown as boolean;\n    },\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    enabled: options?.enabled !== undefined ? options.enabled : true,\n  });\n};\n\n// Response type for first slot start time query\n// Returns { startTime: string | null, hasSlots: boolean }\ninterface FirstSlotStartTimeResult {\n  startTime: string | null;\n  hasSlots: boolean;\n}\n\n// Get the first slot start time for a class\n// Used to determine if enrollment deletions are allowed (only before first slot starts)\nexport const useGetFirstSlotStartTime = (\n  classId: number,\n  options?: { enabled?: boolean }\n) => {\n  return useQuery<FirstSlotStartTimeResult, Error>({\n    queryKey: [...QUERY_KEYS.slots.all, \"firstStartTime\", classId],\n    queryFn: async () => {\n      // Get all slots for class, sorted by start time ascending, limit 1\n      const response = await api.get<PaginatedSlotResponse>(\n        API_ENDPOINTS.slots.all,\n        {\n          params: {\n            classId,\n            sortBy: \"startTime\",\n            sort: \"asc\",\n            pageSize: 1,\n          },\n        }\n      );\n      const data = paginatedSlotResponseSchema.parse(response);\n\n      // Check if slots exist based on totalItems (not just items.length)\n      // API may return empty items due to filtering but totalItems shows actual count\n      const hasSlots = data.totalItems > 0;\n      const startTime = data.items.length > 0 ? data.items[0].startTime : null;\n\n      return { startTime, hasSlots };\n    },\n    staleTime: 1000 * 60 * 2, // 2 minutes\n    enabled: options?.enabled !== false && classId > 0,\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useSlotSession.ts",
      "relative_path": "hooks/api/useSlotSession.ts",
      "filename": "useSlotSession.ts",
      "size_bytes": 5116,
      "lines": 153,
      "last_modified": "2025-11-28T09:21:56.273536",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport { sessionStatusResponseSchema } from \"@/lib/zod-schemas\";\nimport type { SessionStatusResponse } from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useStartSession = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<SessionStatusResponse, Error, number>({\n    mutationFn: async (slotId) => {\n      const response = await api.post(API_ENDPOINTS.slots.startSession(slotId));\n      return sessionStatusResponseSchema.parse(response);\n    },\n\n    onSuccess: (data, slotId) => {\n      const cameraInfo =\n        data.failedCameras && data.failedCameras > 0\n          ? ` (${data.failedCameras} camera(s) failed)`\n          : \"\";\n\n      toast.success(\n        `Session started successfully! ${\n          data.activeCameras || 0\n        } camera(s) active${cameraInfo}`\n      );\n\n      // Invalidate relevant queries\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n    },\n\n    onError: (error: any) => {\n      // Mark error as handled to prevent NextJS dev overlay\n      if (error && typeof error === \"object\") {\n        error.handled = true;\n      }\n      const errorMessage = formatApiError(error);\n\n      // Check if error is related to cameras\n      const isCameraError =\n        errorMessage.includes(\"No active cameras\") ||\n        errorMessage.includes(\"CAMERA_NOT_FOUND\") ||\n        (errorMessage.includes(\"cameras\") && errorMessage.includes(\"configured\"));\n\n      if (isCameraError) {\n        toast.error(\"Cannot start session: No cameras available in this room\");\n      } else {\n        toast.error(`Failed to start session: ${errorMessage}`);\n      }\n    },\n  });\n};\n\nexport const useStopSession = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<SessionStatusResponse, Error, number>({\n    mutationFn: async (slotId) => {\n      const response = await api.post(API_ENDPOINTS.slots.stopSession(slotId));\n      return sessionStatusResponseSchema.parse(response);\n    },\n\n    onSuccess: (data, slotId) => {\n      const recognitionsText = data.totalRecognitions\n        ? ` ${data.totalRecognitions} recognition(s) completed.`\n        : \"\";\n\n      toast.success(`Session stopped successfully!${recognitionsText}`);\n\n      // Invalidate relevant queries\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n    },\n\n    onError: (error: any) => {\n      // Mark error as handled to prevent NextJS dev overlay\n      if (error && typeof error === \"object\") {\n        error.handled = true;\n      }\n      const errorMessage = formatApiError(error);\n      toast.error(`Failed to stop session: ${errorMessage}`);\n    },\n  });\n};\n\n/**\n * Rescan attendance for a slot.\n *\n * Re-verifies attendance with review flags:\n * - PRESENT students not detected → flagged for review (kept as PRESENT)\n * - PRESENT students detected again → evidence updated, flag cleared\n * - ABSENT students detected → flagged for review (kept as ABSENT, new evidence)\n *\n * Use when:\n * - Need to re-verify attendance (e.g., students left early)\n * - Want to confirm attendance with additional scan\n *\n * @returns Mutation for rescanning\n */\nexport const useRescanSession = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<SessionStatusResponse, Error, number>({\n    mutationFn: async (slotId) => {\n      const response = await api.post(API_ENDPOINTS.slots.rescan(slotId));\n      return sessionStatusResponseSchema.parse(response);\n    },\n\n    onSuccess: (data, slotId) => {\n      toast.success(\n        \"Rescan initiated! Re-verifying attendance. Check for review flags after scan completes.\"\n      );\n\n      // Invalidate relevant queries\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n    },\n\n    onError: (error: any) => {\n      // Mark error as handled to prevent NextJS dev overlay\n      if (error && typeof error === \"object\") {\n        error.handled = true;\n      }\n      const errorMessage = formatApiError(error);\n\n      // Check if error is related to cameras\n      const isCameraError =\n        errorMessage.includes(\"No active cameras\") ||\n        errorMessage.includes(\"CAMERA_NOT_FOUND\") ||\n        (errorMessage.includes(\"cameras\") && errorMessage.includes(\"configured\"));\n\n      if (isCameraError) {\n        toast.error(\"Cannot rescan: No cameras available in this room\");\n      } else {\n        toast.error(`Failed to rescan: ${errorMessage}`);\n      }\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useStaffProfiles.ts",
      "relative_path": "hooks/api/useStaffProfiles.ts",
      "filename": "useStaffProfiles.ts",
      "size_bytes": 9201,
      "lines": 281,
      "last_modified": "2025-11-28T09:21:56.273536",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  staffProfileSchema,\n  paginatedStaffProfileResponseSchema,\n  createStaffProfilePayloadSchema,\n  updateStaffProfilePayloadSchema,\n  paginatedStaffClassResponseSchema,\n  paginatedStaffSubjectResponseSchema,\n  paginatedStaffRoomResponseSchema,\n  paginatedSlotResponseSchema,\n  importStaffProfilesResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  StaffProfile,\n  PaginatedStaffProfileResponse,\n  StaffProfileQueryParams,\n  CreateStaffProfilePayload,\n  UpdateStaffProfilePayload,\n  PaginatedStaffClassResponse,\n  StaffClassQueryParams,\n  PaginatedStaffSubjectResponse,\n  StaffSubjectQueryParams,\n  PaginatedStaffRoomResponse,\n  StaffRoomQueryParams,\n  PaginatedSlotResponse,\n  SlotQueryParams,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\n// Get all staff profiles with pagination, filtering, and search\nexport const useGetStaffProfiles = (params?: StaffProfileQueryParams) => {\n  return useQuery<PaginatedStaffProfileResponse, Error>({\n    queryKey: [...QUERY_KEYS.staffProfiles.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.staffProfiles.all, {\n        params,\n      });\n      return paginatedStaffProfileResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\n// Get single staff profile by ID\nexport const useGetStaffProfile = (id: number) => {\n  return useQuery<StaffProfile, Error>({\n    queryKey: QUERY_KEYS.staffProfiles.detail(id),\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.staffProfiles.byId(id));\n      return staffProfileSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n    enabled: !!id,\n  });\n};\n\n// Create new staff profile\nexport const useCreateStaffProfile = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<StaffProfile, Error, CreateStaffProfilePayload>({\n    mutationFn: async (payload) => {\n      // Validate payload with Zod\n      const validatedPayload = createStaffProfilePayloadSchema.parse(payload); // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(\n        API_ENDPOINTS.staffProfiles.all,\n        validatedPayload\n      );\n      return staffProfileSchema.parse(response);\n    },\n\n    onSuccess: () => {\n      toast.success(\"Staff profile created successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.staffProfiles.all });\n    },\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error creating staff profile: ${errorMessage}`);\n    },\n  });\n};\n\n// Update existing staff profile\nexport const useUpdateStaffProfile = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    StaffProfile,\n    Error,\n    { id: number; payload: UpdateStaffProfilePayload }\n  >({\n    mutationFn: async ({ id, payload }) => {\n      // Validate payload with Zod\n      const validatedPayload = updateStaffProfilePayloadSchema.parse(payload); // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(\n        API_ENDPOINTS.staffProfiles.byId(id),\n        validatedPayload\n      );\n      return staffProfileSchema.parse(response);\n    },\n\n    onSuccess: (updatedData) => {\n      toast.success(\"Staff profile updated successfully!\");\n\n      // Invalidate both list and detail queries\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.staffProfiles.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.staffProfiles.detail(updatedData.userId),\n      });\n    },\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating staff profile: ${errorMessage}`);\n    },\n  });\n};\n\n// Delete staff profile (hard delete)\nexport const useDeleteStaffProfile = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {\n      // Real API call\n      await api.delete(API_ENDPOINTS.staffProfiles.byId(id));\n    },\n\n    onSuccess: () => {\n      toast.success(\"Staff profile deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.staffProfiles.all });\n    },\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error deleting staff profile: ${errorMessage}`);\n    },\n  });\n};\n\n// Get classes assigned to a staff member\nexport const useGetStaffClasses = (\n  staffId: number,\n  params?: StaffClassQueryParams\n) => {\n  return useQuery<PaginatedStaffClassResponse, Error>({\n    queryKey: [...QUERY_KEYS.staffProfiles.classes(staffId), params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.staffProfiles.classes(staffId),\n        { params }\n      );\n      return paginatedStaffClassResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n    enabled: !!staffId, // Only run query if staffId is provided\n  });\n};\n\n// Get subjects assigned to a staff member (unique subjects)\nexport const useGetStaffSubjects = (\n  staffId: number,\n  params?: StaffSubjectQueryParams\n) => {\n  return useQuery<PaginatedStaffSubjectResponse, Error>({\n    queryKey: [...QUERY_KEYS.staffProfiles.subjects(staffId), params],\n\n    queryFn: async () => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.staffProfiles.subjects(staffId),\n        { params }\n      );\n      return paginatedStaffSubjectResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n    enabled: !!staffId,\n  });\n};\n\n// Get rooms associated with a staff member (unique rooms used in slots)\nexport const useGetStaffRooms = (\n  staffId: number,\n  params?: StaffRoomQueryParams\n) => {\n  return useQuery<PaginatedStaffRoomResponse, Error>({\n    queryKey: [...QUERY_KEYS.staffProfiles.rooms(staffId), params],\n\n    queryFn: async () => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.staffProfiles.rooms(staffId),\n        { params }\n      );\n      return paginatedStaffRoomResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n    enabled: !!staffId,\n  });\n};\n\n// Get slots assigned to a staff member (lecturer or supervisor)\nexport const useGetStaffSlots = (\n  staffId: number,\n  params?: SlotQueryParams\n) => {\n  return useQuery<PaginatedSlotResponse, Error>({\n    queryKey: [...QUERY_KEYS.staffProfiles.slots(staffId), params],\n\n    queryFn: async () => {\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(\n        API_ENDPOINTS.staffProfiles.slots(staffId),\n        { params }\n      );\n      return paginatedSlotResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n    enabled: !!staffId && staffId > 0,\n  });\n};\n\nexport const useImportStaffProfiles = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    { errors: Array<{ rowNumber: number; errorCode: string; message: string }> },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(API_ENDPOINTS.staffProfiles.import, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importStaffProfilesResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All staff profiles imported successfully!\");\n      } else {\n        toast.warning(`Import completed with ${errorCount} error(s). Check details below.`);\n      }\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.staffProfiles.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useStudentAttendanceHistory.ts",
      "relative_path": "hooks/api/useStudentAttendanceHistory.ts",
      "filename": "useStudentAttendanceHistory.ts",
      "size_bytes": 1297,
      "lines": 36,
      "last_modified": "2025-11-28T09:21:56.274542",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useQuery } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, QUERY_KEYS } from \"@/lib/constants\";\nimport { studentAttendanceHistoryResponseSchema } from \"@/lib/zod-schemas\";\nimport {\n  StudentAttendanceHistoryResponse,\n  StudentAttendanceHistoryParams,\n} from \"@/types\";\n\n// Get student attendance history\nexport const useStudentAttendanceHistory = (\n  studentId: number,\n  params?: StudentAttendanceHistoryParams,\n  options?: { enabled?: boolean }\n) => {\n  return useQuery<StudentAttendanceHistoryResponse, Error>({\n    queryKey: [...QUERY_KEYS.studentProfiles.attendanceHistory(studentId), params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get<StudentAttendanceHistoryResponse>(\n        API_ENDPOINTS.studentProfiles.attendanceHistory(studentId),\n        {\n          params,\n        }\n      );\n      return response as unknown as StudentAttendanceHistoryResponse;\n    },\n\n    staleTime: 1000 * 60, // 1 minute - allow some caching for better UX\n    refetchOnMount: false,\n    refetchOnWindowFocus: false,\n    enabled: options?.enabled !== undefined ? options.enabled : true,\n  });\n};"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useStudentDashboard.ts",
      "relative_path": "hooks/api/useStudentDashboard.ts",
      "filename": "useStudentDashboard.ts",
      "size_bytes": 702,
      "lines": 18,
      "last_modified": "2025-11-28T09:21:56.274542",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useQuery } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { StudentDashboardResponse } from \"@/types\";\n\nexport const useStudentDashboard = (semesterId?: number | null) => {\n  return useQuery<StudentDashboardResponse, Error>({\n    queryKey: [\"student-dashboard\", semesterId],\n    queryFn: async () => {\n      const params: Record<string, any> = {};\n      if (semesterId !== undefined && semesterId !== null) {\n        params.semesterId = semesterId;\n      }\n      const response = await api.get(\"/dashboard/student\", { params });\n      return response as unknown as StudentDashboardResponse;\n    },\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useStudentProfiles.ts",
      "relative_path": "hooks/api/useStudentProfiles.ts",
      "filename": "useStudentProfiles.ts",
      "size_bytes": 9296,
      "lines": 285,
      "last_modified": "2025-11-28T09:21:56.274542",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  createStudentProfilePayloadSchema,\n  paginatedStudentProfileResponseSchema,\n  studentProfileDetailSchema,\n  paginatedStudentClassResponseSchema,\n  attendanceHistoryResponseSchema,\n  importStudentProfilesResponseSchema,\n  importPhotosEmbeddingsResponseSchema,\n  paginatedSlotResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreateStudentProfilePayload,\n  PaginatedStudentProfileResponse,\n  StudentProfileQueryParams,\n  StudentProfileDetail,\n  UpdateStudentProfilePayload,\n  PaginatedStudentClassResponse,\n  StudentClassQueryParams,\n  AttendanceHistoryResponse,\n  AttendanceHistoryQueryParams,\n  PaginatedSlotResponse,\n  ImportPhotosEmbeddingsResponse,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useGetStudentProfiles = (params?: StudentProfileQueryParams) => {\n  return useQuery<PaginatedStudentProfileResponse, Error>({\n    queryKey: [...QUERY_KEYS.studentProfiles.all, params],\n\n    queryFn: async () => {      // Real API call\n      const response = await api.get(API_ENDPOINTS.studentProfiles.all, {\n        params,\n      });\n      return paginatedStudentProfileResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n\nexport const useGetStudentProfile = (id: number) => {\n  return useQuery<StudentProfileDetail, Error>({\n    queryKey: QUERY_KEYS.studentProfiles.detail(id),\n\n    queryFn: async () => {      // Real API call\n      const response = await api.get(API_ENDPOINTS.studentProfiles.byId(id));\n      return studentProfileDetailSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n\nexport const useCreateStudentProfile = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<StudentProfileDetail, Error, CreateStudentProfilePayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createStudentProfilePayloadSchema.parse(payload);      // Real API call\n      const response = await api.post(\n        API_ENDPOINTS.studentProfiles.all,\n        validatedPayload\n      );\n      return studentProfileDetailSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Student profile created successfully!\");\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.studentProfiles.all,\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error creating student profile: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useUpdateStudentProfile = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    StudentProfileDetail,\n    Error,\n    { id: number; payload: UpdateStudentProfilePayload }\n  >({\n    mutationFn: async ({ id, payload }) => {      // Real API call\n      const response = await api.put(\n        API_ENDPOINTS.studentProfiles.byId(id),\n        payload\n      );\n      return studentProfileDetailSchema.parse(response);\n    },\n    onSuccess: (data, variables) => {\n      toast.success(\"Student profile updated successfully!\");\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.studentProfiles.all,\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.studentProfiles.detail(variables.id),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating student profile: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useDeleteStudentProfile = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {      // Real API call\n      await api.delete(API_ENDPOINTS.studentProfiles.byId(id));\n    },\n    onSuccess: () => {\n      toast.success(\"Student profile deleted successfully!\");\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.studentProfiles.all,\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error deleting student profile: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useGetStudentClasses = (\n  studentId: number,\n  params?: StudentClassQueryParams\n) => {\n  return useQuery<PaginatedStudentClassResponse, Error>({\n    queryKey: [...QUERY_KEYS.studentProfiles.classes(studentId), params],\n\n    queryFn: async () => {      // Real API call\n      const response = await api.get(\n        API_ENDPOINTS.studentProfiles.classes(studentId),\n        { params }\n      );\n      return paginatedStudentClassResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  });\n};\n\nexport const useGetStudentAttendanceHistory = (\n  studentId: number,\n  params?: AttendanceHistoryQueryParams,\n  options?: { enabled?: boolean }\n) => {\n  return useQuery<AttendanceHistoryResponse, Error>({\n    queryKey: [\n      ...QUERY_KEYS.studentProfiles.attendanceHistory(studentId),\n      params,\n    ],\n\n    queryFn: async () => {      // Real API call\n      const response = await api.get(\n        API_ENDPOINTS.studentProfiles.attendanceHistory(studentId),\n        { params }\n      );\n      return attendanceHistoryResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 2, // 2 minutes (attendance data changes frequently)\n    enabled: options?.enabled ?? true,\n  });\n};\n\nexport const useGetStudentSlots = (\n  studentId: number,\n  params?: {\n    page?: number;\n    pageSize?: number;\n    slotCategories?: readonly (\"LECTURE\" | \"LECTURE_WITH_PT\" | \"FINAL_EXAM\")[] | (\"LECTURE\" | \"LECTURE_WITH_PT\" | \"FINAL_EXAM\")[];\n    studentUserId?: number;\n    isActive?: boolean;\n    startTimeFrom?: string;\n    startTimeTo?: string;\n    semesterId?: number;\n    subjectId?: number;\n  }\n) => {\n  return useQuery<PaginatedSlotResponse, Error>({\n    queryKey: [...QUERY_KEYS.studentProfiles.slots(studentId), params],\n\n    queryFn: async () => {\n      // Real API call\n      const response = await api.get(\n        API_ENDPOINTS.studentProfiles.slots(studentId),\n        { params }\n      );\n      // Backend returns standard Slot structure, validate with schema\n      return paginatedSlotResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    enabled: !!studentId,\n  });\n};\n\nexport const useImportStudentProfiles = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    { errors: Array<{ rowNumber: number; errorCode: string; message: string }> },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(API_ENDPOINTS.studentProfiles.import, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importStudentProfilesResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All student profiles imported successfully!\");\n      } else {\n        toast.warning(`Import completed with ${errorCount} error(s). Check details below.`);\n      }\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.studentProfiles.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n\nexport const useImportPhotosEmbeddings = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    ImportPhotosEmbeddingsResponse,\n    Error,\n    { csvFile: File; zipFile: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ csvFile, zipFile, mode }) => {\n      const formData = new FormData();\n      formData.append(\"csvFile\", csvFile);\n      formData.append(\"zipFile\", zipFile);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(\n        API_ENDPOINTS.studentProfiles.bulkUploadPhotosEmbeddings,\n        formData,\n        {\n          headers: {\n            \"Content-Type\": \"multipart/form-data\",\n          },\n        }\n      );\n\n      // Manual unwrap if interceptor didn't work\n      const dataToParseActual = ('data' in response && response.data) ? response.data : response;\n      return importPhotosEmbeddingsResponseSchema.parse(dataToParseActual);\n    },\n    onSuccess: () => {\n      // Toast handled by dialog component\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.studentProfiles.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: () => {\n      // Toast handled by dialog component\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useStudentRecentAttendance.ts",
      "relative_path": "hooks/api/useStudentRecentAttendance.ts",
      "filename": "useStudentRecentAttendance.ts",
      "size_bytes": 580,
      "lines": 16,
      "last_modified": "2025-11-28T09:21:56.274542",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useQuery } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { AttendanceHistoryItem } from \"@/types\";\n\nexport const useStudentRecentAttendance = (limit: number = 10) => {\n  return useQuery<AttendanceHistoryItem[], Error>({\n    queryKey: [\"student-recent-attendance\", limit],\n    queryFn: async () => {\n      const response = await api.get(\"/students/me/attendance-recent\", {\n        params: { limit },\n      });\n      return response as unknown as AttendanceHistoryItem[];\n    },\n    staleTime: 1000 * 60 * 2, // 2 minutes\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useStudentSubjects.ts",
      "relative_path": "hooks/api/useStudentSubjects.ts",
      "filename": "useStudentSubjects.ts",
      "size_bytes": 1406,
      "lines": 43,
      "last_modified": "2025-11-28T09:21:56.274542",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useQuery } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, QUERY_KEYS } from \"@/lib/constants\";\nimport type { StudentDashboardSubject } from \"@/types\";\n\n/**\n * Fetch subjects của student trong semester.\n * Used by student attendance history page.\n *\n * @param studentId Student ID\n * @param semesterId Semester ID (required)\n * @param options Query options (enabled flag)\n */\nexport const useStudentSubjects = (\n  studentId: number,\n  semesterId: number | undefined,\n  options?: { enabled?: boolean }\n) => {\n  return useQuery<StudentDashboardSubject[], Error>({\n    queryKey: [...QUERY_KEYS.studentProfiles.subjects(studentId), semesterId],\n\n    queryFn: async () => {\n      if (!semesterId) {\n        throw new Error(\"Semester ID is required\");\n      }\n\n      const response = await api.get<StudentDashboardSubject[]>(\n        API_ENDPOINTS.studentProfiles.subjects(studentId),\n        {\n          params: { semesterId },\n        }\n      );\n\n      // Axios interceptor đã unwrap { status, data } → returns data directly\n      return response as unknown as StudentDashboardSubject[];\n    },\n\n    staleTime: 1000 * 60 * 5, // 5 minutes (subjects rarely change)\n    refetchOnMount: false,\n    refetchOnWindowFocus: false,\n    enabled: options?.enabled !== undefined ? options.enabled : !!semesterId,\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useSubjects.ts",
      "relative_path": "hooks/api/useSubjects.ts",
      "filename": "useSubjects.ts",
      "size_bytes": 5637,
      "lines": 169,
      "last_modified": "2025-11-28T09:21:56.275542",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError, QUERY_KEYS } from \"@/lib/constants\";\nimport {\n  createSubjectPayloadSchema,\n  paginatedSubjectResponseSchema,\n  subjectSchema,\n  importSubjectsResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  CreateSubjectPayload,\n  PaginatedSubjectResponse,\n  SubjectQueryParams,\n  Subject,\n  UpdateSubjectPayload,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useGetSubjects = (params?: SubjectQueryParams) => {\n  return useQuery<PaginatedSubjectResponse, Error>({\n    queryKey: [...QUERY_KEYS.subjects.all, params],\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.subjects.all, { params });\n      return paginatedSubjectResponseSchema.parse(response);\n    },\n\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useGetSubjectById = (id: number) => {\n  return useQuery<Subject, Error>({\n    queryKey: QUERY_KEYS.subjects.detail(id),\n\n    queryFn: async () => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.get(API_ENDPOINTS.subjects.byId(id));\n      return subjectSchema.parse(response);\n    },\n\n    enabled: !!id && id > 0,\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateSubject = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<Subject, Error, CreateSubjectPayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = createSubjectPayloadSchema.parse(payload);\n\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.post(\n        API_ENDPOINTS.subjects.all,\n        validatedPayload\n      );\n      return subjectSchema.parse(response);\n    },\n    onSuccess: () => {\n      toast.success(\"Subject created successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.subjects.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error creating subject: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useUpdateSubject = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    Subject,\n    Error,\n    { id: number; payload: UpdateSubjectPayload }\n  >({\n    mutationFn: async ({ id, payload }) => {\n      // Real API call\n      // Interceptor automatically unwraps { status, data } → returns data directly\n      const response = await api.put(API_ENDPOINTS.subjects.byId(id), payload);\n      return subjectSchema.parse(response);\n    },\n    onSuccess: (updatedData) => {\n      toast.success(\"Subject updated successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.subjects.all });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.subjects.detail(updatedData.id),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating subject: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useDeleteSubject = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, Error, number>({\n    mutationFn: async (id) => {\n      // Real API call\n      return api.delete(API_ENDPOINTS.subjects.byId(id));\n    },\n    onSuccess: () => {\n      toast.success(\"Subject deleted successfully!\");\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.subjects.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error deleting subject: ${errorMessage}`);\n    },\n  });\n};\n\nexport const useImportSubjects = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation<\n    { errors: Array<{ rowNumber: number; errorCode: string; message: string }> },\n    Error,\n    { file: File; mode: \"AddOnly\" | \"AddAndUpdate\" }\n  >({\n    mutationFn: async ({ file, mode }) => {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"mode\", mode);\n\n      const response = await api.post(API_ENDPOINTS.subjects.import, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n      return importSubjectsResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const errorCount = data.errors.length;\n      if (errorCount === 0) {\n        toast.success(\"All subjects imported successfully!\");\n      } else {\n        toast.warning(\n          `Import completed with ${errorCount} error(s). Check details below.`\n        );\n      }\n      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.subjects.all });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(errorMessage);\n    },\n  });\n};\n\n// TODO: Nested GET /subjects/{id}/classes\n// Previously exported useGetSubjectClasses but removed because the UI uses the\n// generic Classes page with subjectId filter. Reintroduce a paginated hook when\n// an inline classes-by-subject view is needed.\n\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useSubmitAttendance.ts",
      "relative_path": "hooks/api/useSubmitAttendance.ts",
      "filename": "useSubmitAttendance.ts",
      "size_bytes": 1846,
      "lines": 51,
      "last_modified": "2025-11-28T09:21:56.275542",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, QUERY_KEYS, formatApiError } from \"@/lib/constants\";\nimport {\n  submitAttendancePayloadSchema,\n  submitAttendanceResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport type {\n  SubmitAttendancePayload,\n  SubmitAttendanceResponse,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useSubmitAttendance = (slotId: number) => {\n  const queryClient = useQueryClient();\n\n  return useMutation<SubmitAttendanceResponse, Error, SubmitAttendancePayload>({\n    mutationFn: async (payload) => {\n      const validatedPayload = submitAttendancePayloadSchema.parse(payload);\n      const response = await api.post(\n        API_ENDPOINTS.slots.submitAttendance(slotId),\n        validatedPayload\n      );\n      return submitAttendanceResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      const { successCount, failureCount } = data;\n      if (failureCount === 0) {\n        toast.success(`Submitted attendance for ${successCount} student${successCount > 1 ? 's' : ''}.`);\n      } else if (successCount > 0) {\n        toast.warning(\n          `Success: ${successCount}, Failed: ${failureCount}. Please check details.`\n        );\n      } else {\n        toast.error(`Failed to submit attendance for all students.`);\n      }\n\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.roster(slotId),\n      });\n      queryClient.invalidateQueries({\n        queryKey: QUERY_KEYS.slots.detail(slotId),\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      const errorMessage = formatApiError(error);\n      toast.error(`Error submitting attendance: ${errorMessage}`);\n    },\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useSupervisorDashboard.ts",
      "relative_path": "hooks/api/useSupervisorDashboard.ts",
      "filename": "useSupervisorDashboard.ts",
      "size_bytes": 787,
      "lines": 18,
      "last_modified": "2025-11-28T09:21:56.275542",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useQuery } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { SupervisorDashboardResponse } from \"@/types\";\n\nexport const useSupervisorDashboard = (semesterId?: number) => {\n  return useQuery<SupervisorDashboardResponse, Error>({\n    queryKey: [\"supervisor-dashboard\", semesterId ?? null],\n    queryFn: async () => {\n      const params = semesterId ? { semesterId } : {};\n      // Response interceptor already unwraps { status, data } → data\n      // So response is already the unwrapped data\n      const response = await api.get<SupervisorDashboardResponse>(\"/dashboard/supervisor\", { params });\n      return response as unknown as SupervisorDashboardResponse;\n    },\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    retry: 1,\n  });\n};\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\frontend-web\\hooks\\api\\useUsers.ts",
      "relative_path": "hooks/api/useUsers.ts",
      "filename": "useUsers.ts",
      "size_bytes": 1539,
      "lines": 46,
      "last_modified": "2025-11-28T09:21:56.275542",
      "encoding": "utf-8",
      "language": "typescript",
      "content": "import { useMutation } from \"@tanstack/react-query\";\nimport api from \"@/lib/api-axios\";\nimport { API_ENDPOINTS, formatApiError } from \"@/lib/constants\";\nimport {\n  updatePasswordPayloadSchema,\n  updatePasswordResponseSchema,\n} from \"@/lib/zod-schemas\";\nimport {\n  UpdatePasswordPayload,\n  UpdatePasswordResponse,\n} from \"@/types\";\nimport { toast } from \"sonner\";\n\nexport const useUpdatePassword = () => {\n  return useMutation<\n    UpdatePasswordResponse,\n    Error,\n    { userId: number; payload: UpdatePasswordPayload }\n  >({\n    mutationFn: async ({ userId, payload }) => {\n      const validatedPayload = updatePasswordPayloadSchema.parse(payload);\n      const response = await api.post(\n        API_ENDPOINTS.users.updatePassword(userId),\n        validatedPayload\n      );\n      return updatePasswordResponseSchema.parse(response);\n    },\n    onSuccess: (data) => {\n      toast.success(data.message || \"Password updated successfully!\");\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onError: (error: any) => {\n      // Don't show toast for 401 errors (incorrect old password)\n      // Let the component handle it with field-level error\n      const status = error.response?.status || error.status;\n      if (status === 401) {\n        // Component will handle this error\n        return;\n      }\n\n      // Show toast for other errors\n      const errorMessage = formatApiError(error);\n      toast.error(`Error updating password: ${errorMessage}`);\n    },\n  });\n};"
    }
  ]
}