{
  "metadata": {
    "codebase": "backend",
    "category": "repository",
    "generated_at": "2025-12-03T21:12:48.228538",
    "total_files": 55,
    "total_lines": 8666,
    "total_bytes": 402475
  },
  "files": [
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\AttendanceRecordRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/AttendanceRecordRepository.java",
      "filename": "AttendanceRecordRepository.java",
      "size_bytes": 6606,
      "lines": 123,
      "last_modified": "2025-12-01T19:50:23.078381",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.constant.enums.AttendanceMethod;\nimport com.fuacs.backend.constant.enums.AttendanceStatus;\nimport com.fuacs.backend.entity.AttendanceRecord;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.repository.custom.CustomAttendanceRecordRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Modifying;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\nimport java.util.List;\n\n@Repository\npublic interface AttendanceRecordRepository\n        extends JpaRepository<AttendanceRecord, Long>, CustomAttendanceRecordRepository {\n\n    @Query(\"SELECT ar FROM AttendanceRecord ar WHERE ar.slot.id = :slotId AND ar.student.id = :studentUserId\")\n    AttendanceRecord findBySlotIdAndStudentUserId(@Param(\"slotId\") Integer slotId,\n            @Param(\"studentUserId\") Integer studentUserId);\n\n    @Query(\"SELECT ar FROM AttendanceRecord ar WHERE ar.slot.id = :slotId\")\n    List<AttendanceRecord> findBySlotId(@Param(\"slotId\") Integer slotId);\n\n    @Query(\"SELECT ar FROM AttendanceRecord ar WHERE ar.student.id = :studentUserId\")\n    List<AttendanceRecord> findByStudentUserId(@Param(\"studentUserId\") Integer studentUserId);\n\n    @Query(\"SELECT ar FROM AttendanceRecord ar WHERE ar.slot.id = :slotId AND ar.status = :status\")\n    List<AttendanceRecord> findBySlotIdAndStatus(@Param(\"slotId\") Integer slotId,\n            @Param(\"status\") AttendanceStatus status);\n\n    @Query(\"SELECT ar FROM AttendanceRecord ar WHERE ar.slot.id = :slotId AND ar.method = :method\")\n    List<AttendanceRecord> findBySlotIdAndMethod(@Param(\"slotId\") Integer slotId,\n            @Param(\"method\") AttendanceMethod method);\n\n    @Query(\"SELECT COUNT(ar) FROM AttendanceRecord ar WHERE ar.slot.id = :slotId\")\n    Long countBySlotId(@Param(\"slotId\") Integer slotId);\n\n    @Query(\"SELECT COUNT(ar) FROM AttendanceRecord ar WHERE ar.slot.id = :slotId AND ar.status = :status\")\n    Long countBySlotIdAndStatus(@Param(\"slotId\") Integer slotId, @Param(\"status\") AttendanceStatus status);\n\n    @Query(\"SELECT COUNT(ar) FROM AttendanceRecord ar WHERE ar.slot.id = :slotId AND ar.method = :method\")\n    Long countBySlotIdAndMethod(@Param(\"slotId\") Integer slotId, @Param(\"method\") AttendanceMethod method);\n\n    @Query(\"SELECT ar FROM AttendanceRecord ar WHERE ar.slot.academicClass.id = :classId\")\n    List<AttendanceRecord> findByClassId(@Param(\"classId\") Short classId);\n\n    @Query(\"SELECT ar FROM AttendanceRecord ar WHERE ar.slot.academicClass.semester.id = :semesterId\")\n    List<AttendanceRecord> findBySemesterId(@Param(\"semesterId\") Short semesterId);\n\n    @Query(\"SELECT ar FROM AttendanceRecord ar WHERE ar.recordedAt >= :startDate AND ar.recordedAt <= :endDate\")\n    List<AttendanceRecord> findByDateRange(@Param(\"startDate\") LocalDateTime startDate,\n            @Param(\"endDate\") LocalDateTime endDate);\n\n    @Query(\"SELECT ar FROM AttendanceRecord ar WHERE ar.slot.startTime >= :startDate AND ar.slot.startTime <= :endDate\")\n    List<AttendanceRecord> findBySlotDateRange(@Param(\"startDate\") LocalDateTime startDate,\n            @Param(\"endDate\") LocalDateTime endDate);\n\n    @Query(\"SELECT COUNT(ar) > 0 FROM AttendanceRecord ar WHERE ar.slot.id = :slotId AND ar.student.id = :studentUserId\")\n    boolean existsBySlotIdAndStudentUserId(@Param(\"slotId\") Integer slotId,\n            @Param(\"studentUserId\") Integer studentUserId);\n\n    @Query(\"SELECT ar FROM AttendanceRecord ar WHERE ar.slot.id = :slotId AND ar.needsReview = :needsReview\")\n    List<AttendanceRecord> findBySlotIdAndNeedsReview(@Param(\"slotId\") Integer slotId,\n            @Param(\"needsReview\") Boolean needsReview);\n\n    /**\n     * Find attendance statuses for a specific student across multiple slots.\n     * Used for populating student-specific attendance status in slot lists.\n     *\n     * @param slotIds List of slot IDs to query\n     * @param studentUserId Student user ID\n     * @return List of [slotId, status] tuples\n     */\n    @Query(\"SELECT ar.slot.id, ar.status FROM AttendanceRecord ar \" +\n           \"WHERE ar.slot.id IN :slotIds AND ar.student.id = :studentUserId\")\n    List<Object[]> findStatusesBySlotIdsAndStudent(@Param(\"slotIds\") List<Integer> slotIds,\n                                                    @Param(\"studentUserId\") Integer studentUserId);\n\n    /**\n     * Bulk update attendance status for all records of a slot matching the old status.\n     * Used for automatic attendance finalization to convert NOT_YET to ABSENT.\n     *\n     * @param slotId ID of the slot to update\n     * @param oldStatus Current status to match (e.g., NOT_YET)\n     * @param newStatus New status to set (e.g., ABSENT)\n     * @param method Method used for the update (e.g., SYSTEM_FINALIZE)\n     * @param recordedAt Timestamp when the update occurred\n     * @return Number of records updated\n     */\n    @Modifying\n    @Query(\"UPDATE AttendanceRecord ar SET ar.status = :newStatus, \" +\n           \"ar.method = :method, ar.recordedAt = :recordedAt \" +\n           \"WHERE ar.slot.id = :slotId AND ar.status = :oldStatus\")\n    int bulkUpdateStatus(@Param(\"slotId\") Integer slotId,\n                        @Param(\"oldStatus\") AttendanceStatus oldStatus,\n                        @Param(\"newStatus\") AttendanceStatus newStatus,\n                        @Param(\"method\") AttendanceMethod method,\n                        @Param(\"recordedAt\") Instant recordedAt);\n\n    /**\n     * Find students with a specific attendance status for a slot.\n     * Used for sending absence notifications after finalization.\n     */\n    @Query(\"SELECT ar.student FROM AttendanceRecord ar WHERE ar.slot.id = :slotId AND ar.status = :status\")\n    List<User> findStudentsBySlotIdAndStatus(@Param(\"slotId\") Integer slotId,\n                                              @Param(\"status\") AttendanceStatus status);\n\n    /**\n     * Reset needsReview flag to false for all attendance records of a slot.\n     * Used during attendance finalization to clear review flags.\n     *\n     * @param slotId ID of the slot to update\n     * @return Number of records updated\n     */\n    @Modifying\n    @Query(\"UPDATE AttendanceRecord ar SET ar.needsReview = false WHERE ar.slot.id = :slotId AND ar.needsReview = true\")\n    int resetNeedsReviewBySlotId(@Param(\"slotId\") Integer slotId);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\CameraRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/CameraRepository.java",
      "filename": "CameraRepository.java",
      "size_bytes": 3101,
      "lines": 83,
      "last_modified": "2025-11-28T08:56:33.008538",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.Camera;\nimport com.fuacs.backend.repository.custom.CustomCameraRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n/**\n * JPA repository cho Camera entity.\n * Cung cấp các method CRUD chuẩn (từ JpaRepository) và các query methods tùy chỉnh.\n * Kế thừa CustomCameraRepository để có thêm search và count methods.\n *\n * @see Camera\n * @see CustomCameraRepository\n */\n@Repository\npublic interface CameraRepository extends JpaRepository<Camera, Short>, CustomCameraRepository {\n\n    /**\n     * Kiểm tra tên camera đã tồn tại chưa (dùng cho validation khi tạo mới).\n     *\n     * @param name Tên camera cần kiểm tra\n     * @return true nếu tên đã tồn tại\n     */\n    boolean existsByName(String name);\n\n    /**\n     * Kiểm tra RTSP URL đã tồn tại chưa (dùng cho validation khi tạo mới).\n     *\n     * @param rtspUrl RTSP URL cần kiểm tra\n     * @return true nếu URL đã tồn tại\n     */\n    boolean existsByRtspUrl(String rtspUrl);\n\n    /**\n     * Kiểm tra tên camera unique khi update (loại trừ camera hiện tại).\n     *\n     * @param name Tên camera cần kiểm tra\n     * @param id ID camera hiện tại (để loại trừ)\n     * @return true nếu tên đã được dùng bởi camera khác\n     */\n    boolean existsByNameAndIdNot(String name, Short id);\n\n    /**\n     * Kiểm tra RTSP URL unique khi update (loại trừ camera hiện tại).\n     *\n     * @param rtspUrl RTSP URL cần kiểm tra\n     * @param id ID camera hiện tại (để loại trừ)\n     * @return true nếu URL đã được dùng bởi camera khác\n     */\n    boolean existsByRtspUrlAndIdNot(String rtspUrl, Short id);\n\n    /**\n     * Đếm số slot active sắp diễn ra trong phòng chứa camera này.\n     * Dùng để kiểm tra trước khi xóa camera (không cho xóa nếu có slot active).\n     *\n     * @param cameraId ID camera cần kiểm tra\n     * @param now Thời điểm hiện tại\n     * @return Số slot active có startTime >= now\n     */\n    @Query(\"SELECT COUNT(s.id) FROM Slot s WHERE s.room.id IN (SELECT c.room.id FROM Camera c WHERE c.id = :cameraId) AND s.startTime >= :now AND s.isActive = true\")\n    long countActiveSlotsByCameraId(@Param(\"cameraId\") Short cameraId, @Param(\"now\") java.time.LocalDateTime now);\n\n    /**\n     * Tìm tất cả camera trong một phòng cụ thể.\n     *\n     * @param roomId ID phòng\n     * @return Danh sách camera trong phòng\n     */\n    List<Camera> findByRoom_Id(Short roomId);\n\n    /**\n     * Tìm camera theo tên (dùng trong CSV import để check duplicate).\n     *\n     * @param name Tên camera\n     * @return Camera entity hoặc null\n     */\n    Camera findByName(String name);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\ClassRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/ClassRepository.java",
      "filename": "ClassRepository.java",
      "size_bytes": 5158,
      "lines": 84,
      "last_modified": "2025-12-01T21:19:17.133739",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.AcademicClass;\nimport com.fuacs.backend.repository.custom.CustomClassRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface ClassRepository extends JpaRepository<AcademicClass, Short>, CustomClassRepository {\n\n    @Query(value = \"SELECT EXISTS(SELECT 1 FROM classes WHERE code = :code AND subject_id = :subjectId AND semester_id = :semesterId)\", nativeQuery = true)\n    boolean existsByCodeAndSubjectIdAndSemesterId(@Param(\"code\") String code, @Param(\"subjectId\") Short subjectId, @Param(\"semesterId\") Short semesterId);\n\n    @Query(value = \"SELECT EXISTS(SELECT 1 FROM classes WHERE code = :code AND subject_id = :subjectId AND semester_id = :semesterId AND id <> :id)\", nativeQuery = true)\n    boolean existsByCodeAndSubjectIdAndSemesterIdAndIdNot(@Param(\"code\") String code, @Param(\"subjectId\") Short subjectId, @Param(\"semesterId\") Short semesterId, @Param(\"id\") Short id);\n\n    @Query(\"SELECT c FROM AcademicClass c WHERE c.code = :code AND c.subject.id = :subjectId AND c.semester.id = :semesterId\")\n    AcademicClass findByCodeAndSubjectIdAndSemesterId(@Param(\"code\") String code, @Param(\"subjectId\") Short subjectId, @Param(\"semesterId\") Short semesterId);\n\n    @Query(\"SELECT c FROM AcademicClass c WHERE c.code = :code AND c.semester.code = :semesterCode\")\n    AcademicClass findByCodeAndSemesterCode(@Param(\"code\") String code, @Param(\"semesterCode\") String semesterCode);\n\n    // Eager fetch Subject (with majors) and Semester for enrollment import to avoid lazy loading issues\n    @Query(\"SELECT c FROM AcademicClass c \" +\n           \"JOIN FETCH c.subject subj \" +\n           \"JOIN FETCH subj.majors \" +\n           \"JOIN FETCH c.semester \" +\n           \"WHERE c.code = :code AND c.semester.code = :semesterCode\")\n    AcademicClass findByCodeAndSemesterCodeWithSubjectAndSemester(@Param(\"code\") String code, @Param(\"semesterCode\") String semesterCode);\n\n    @Query(\"SELECT COUNT(s.id) FROM Slot s WHERE s.academicClass.id = :classId AND s.isActive = true\")\n    long countActiveSlotsByClassId(@Param(\"classId\") Short classId);\n\n    @Query(\"SELECT MAX(s.endTime) FROM Slot s WHERE s.academicClass.id = :classId AND s.isActive = true\")\n    java.time.LocalDateTime findLastActiveSlotEndTimeByClassId(@Param(\"classId\") Short classId);\n\n    @Query(\"SELECT COUNT(e.id) FROM Enrollment e WHERE e.academicClass.id = :classId AND e.isEnrolled = true\")\n    long countEnrolledStudentsByClassId(@Param(\"classId\") Short classId);\n\n    @Query(\"SELECT COUNT(e.id) FROM Enrollment e WHERE e.academicClass.id = :classId\")\n    long countAllStudentsByClassId(@Param(\"classId\") Short classId);\n\n    @Query(\"SELECT COUNT(s.id) FROM Slot s WHERE s.academicClass.id = :classId\")\n    long countAllSlotsByClassId(@Param(\"classId\") Short classId);\n\n    @Query(\"SELECT c FROM AcademicClass c WHERE c.code = :code AND c.subject.code = :subjectCode AND c.semester.code = :semesterCode\")\n    AcademicClass findByCodeAndSubjectCodeAndSemesterCode(@Param(\"code\") String code, @Param(\"subjectCode\") String subjectCode, @Param(\"semesterCode\") String semesterCode);\n\n    // Data Operator Dashboard queries - Per Semester\n    @Query(\"SELECT COUNT(c) FROM AcademicClass c WHERE c.semester.id = :semesterId\")\n    Integer countTotalClassesBySemester(@Param(\"semesterId\") Short semesterId);\n\n    @Query(\"SELECT COUNT(c) FROM AcademicClass c WHERE c.semester.id = :semesterId AND c.isActive = true\")\n    Integer countActiveClassesBySemester(@Param(\"semesterId\") Short semesterId);\n\n    @Query(\"SELECT COUNT(c) FROM AcademicClass c WHERE c.semester.id = :semesterId AND c.isActive = false\")\n    Integer countCompletedClassesBySemester(@Param(\"semesterId\") Short semesterId);\n\n    @Query(\"SELECT COUNT(DISTINCT s.staff.id) FROM AcademicClass c \" +\n           \"JOIN c.slots s \" +\n           \"WHERE c.semester.id = :semesterId\")\n    Integer countLecturersBySemester(@Param(\"semesterId\") Short semesterId);\n\n    // Data Operator Dashboard queries - All Semesters (no semester filter)\n    @Query(\"SELECT COUNT(c) FROM AcademicClass c WHERE c.isActive = true\")\n    Integer countActiveClasses();\n\n    @Query(\"SELECT COUNT(c) FROM AcademicClass c WHERE c.isActive = false\")\n    Integer countCompletedClasses();\n\n    @Query(\"SELECT COUNT(DISTINCT s.staff.id) FROM AcademicClass c JOIN c.slots s\")\n    Integer countTotalLecturers();\n\n    // Lecturer-specific queries\n    @Query(\"SELECT DISTINCT c FROM AcademicClass c \" +\n           \"JOIN c.slots s \" +\n           \"WHERE s.staff.id = :lecturerId AND c.semester.id = :semesterId \" +\n           \"AND s.isActive = true \" +\n           \"AND (s.slotCategory = 'LECTURE' OR s.slotCategory = 'LECTURE_WITH_PT') \" +\n           \"ORDER BY c.code\")\n    java.util.List<AcademicClass> findClassesByLecturerAndSemester(@Param(\"lecturerId\") Integer lecturerId, @Param(\"semesterId\") Short semesterId);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomAttendanceHistoryRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomAttendanceHistoryRepository.java",
      "filename": "CustomAttendanceHistoryRepository.java",
      "size_bytes": 813,
      "lines": 18,
      "last_modified": "2025-11-28T08:56:33.011549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.AttendanceHistorySearchRequest;\nimport com.fuacs.backend.dto.response.AttendanceHistoryDTO;\nimport com.fuacs.backend.dto.response.AttendanceSummaryDTO;\nimport com.fuacs.backend.dto.response.AttendanceSummaryDetailsDTO;\n\nimport java.util.List;\n\npublic interface CustomAttendanceHistoryRepository {\n    List<AttendanceHistoryDTO> searchByStudentId(Integer studentId, AttendanceHistorySearchRequest request);\n\n    Long countByStudentId(Integer studentId, AttendanceHistorySearchRequest request);\n\n    AttendanceSummaryDTO getAttendanceSummary(Integer studentId, AttendanceHistorySearchRequest request);\n\n    AttendanceSummaryDetailsDTO getDetailedSummary(Integer studentId, AttendanceHistorySearchRequest request);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomAttendanceRecordRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomAttendanceRecordRepository.java",
      "filename": "CustomAttendanceRecordRepository.java",
      "size_bytes": 1209,
      "lines": 29,
      "last_modified": "2025-11-28T08:56:33.012551",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.AttendanceRecordSearchRequest;\nimport com.fuacs.backend.dto.response.AttendanceRecordDTO;\nimport com.fuacs.backend.entity.AttendanceRecord;\n\nimport java.util.List;\n\npublic interface CustomAttendanceRecordRepository {\n    List<AttendanceRecordDTO> search(AttendanceRecordSearchRequest request);\n\n    Long count(AttendanceRecordSearchRequest request);\n\n    AttendanceRecordDTO findByIdWithDetails(Long id);\n\n    /**\n     * Find attendance records by class and semester with slot category filtering.\n     * Only includes records for slots with categories LECTURE and LECTURE_WITH_PT.\n     * Excludes FINAL_EXAM slots as specified in requirements.\n     */\n    List<AttendanceRecord> findByClassAndSemesterWithSlotFiltering(Short classId, Short semesterId);\n\n    /**\n     * Count attendance records by student and class for statistics calculation.\n     * Only includes records for slots with categories LECTURE and LECTURE_WITH_PT.\n     * Excludes FINAL_EXAM slots as specified in requirements.\n     */\n    Long countAttendanceByStudentAndClass(Integer studentUserId, Short classId, Short semesterId);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomCameraRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomCameraRepository.java",
      "filename": "CustomCameraRepository.java",
      "size_bytes": 1128,
      "lines": 33,
      "last_modified": "2025-11-28T08:56:33.012551",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.CameraSearchBaseRequest;\nimport com.fuacs.backend.dto.response.CameraDTO;\n\nimport java.util.List;\n\n/**\n * Custom repository interface định nghĩa các query phức tạp cho Camera.\n * Implementation nằm trong CameraRepositoryImpl sử dụng EntityManager và JPQL.\n *\n * @see com.fuacs.backend.repository.impl.CameraRepositoryImpl\n */\npublic interface CustomCameraRepository {\n\n    /**\n     * Tìm kiếm camera với filters và pagination.\n     * Hỗ trợ filters: search keyword (name/rtspUrl), isActive, roomId, sorting.\n     *\n     * @param request Chứa filters và pagination\n     * @return Danh sách CameraDTO kèm thông tin phòng (RoomDTO)\n     */\n    List<CameraDTO> search(CameraSearchBaseRequest request);\n\n    /**\n     * Đếm tổng số camera thỏa mãn filters.\n     * Dùng để tính total pages cho pagination.\n     *\n     * @param request Chứa filters (không bao gồm pagination)\n     * @return Tổng số camera\n     */\n    Long count(CameraSearchBaseRequest request);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomClassRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomClassRepository.java",
      "filename": "CustomClassRepository.java",
      "size_bytes": 1464,
      "lines": 31,
      "last_modified": "2025-11-28T08:56:33.012551",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.ClassSearchRequest;\nimport com.fuacs.backend.dto.response.ClassDTO;\nimport com.fuacs.backend.dto.response.MyClassDTO;\n\nimport java.util.List;\n\npublic interface CustomClassRepository {\n    List<ClassDTO> search(ClassSearchRequest request);\n    Long count(ClassSearchRequest request);\n\n    List<ClassDTO> searchClassBySemesterId(Short semesterId, ClassSearchRequest request);\n    Long countBySemesterId(Short semesterId, ClassSearchRequest request);\n\n    List<ClassDTO> searchClassBySubjectId(Short subjectId, ClassSearchRequest request);\n    Long countBySubjectId(Short subjectId, ClassSearchRequest request);\n\n    List<ClassDTO> searchClassesByStudentId(Integer studentId, ClassSearchRequest request);\n    Long countClassesByStudentId(Integer studentId, ClassSearchRequest request);\n\n    List<ClassDTO> searchClassesByStaffId(Integer staffId, ClassSearchRequest request);\n    Long countClassesByStaffId(Integer staffId, ClassSearchRequest request);\n\n    // Lecturer dashboard aggregation\n    java.util.List<MyClassDTO> findClassesWithStatsByLecturerAndSemester(Integer lecturerId, Short semesterId);\n    java.util.List<MyClassDTO> findClassesWithStatsByLecturer(Integer lecturerId);\n\n    // Get upcoming slots for a specific class\n    java.util.List<com.fuacs.backend.dto.response.TodaySlotDTO> findUpcomingSlotsForClass(Short classId, int limit);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomEnrollmentRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomEnrollmentRepository.java",
      "filename": "CustomEnrollmentRepository.java",
      "size_bytes": 1902,
      "lines": 48,
      "last_modified": "2025-11-28T08:56:33.012551",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.EnrollmentSearchRequest;\nimport com.fuacs.backend.dto.request.StudentSemesterSearchRequest;\nimport com.fuacs.backend.dto.response.ClassRosterDTO;\nimport com.fuacs.backend.dto.response.EnrollmentDTO;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.dto.response.StudentProfileDTO;\nimport com.fuacs.backend.dto.response.StudentSemesterDTO;\nimport com.fuacs.backend.entity.EnrollmentId;\n\nimport java.util.List;\n\npublic interface CustomEnrollmentRepository {\n\n    List<EnrollmentDTO> search(EnrollmentSearchRequest request);\n\n    Long count(EnrollmentSearchRequest request);\n\n    EnrollmentDTO findByEnrollmentId(EnrollmentId id);\n\n    List<StudentProfileDTO> findByClassId(Short classId, EnrollmentSearchRequest request);\n\n    Long countByClassId(Short classId, EnrollmentSearchRequest request);\n\n    Long countByClassId(Short classId, Boolean isEnrolled, String search);\n\n    Long countEnrolledByClassId(Short classId);\n\n    Long countWithdrawnByClassId(Short classId);\n\n    boolean existsByEnrollmentId(EnrollmentId id);\n\n    boolean existsByIdAndIsEnrolled(EnrollmentId id, boolean isEnrolled);\n\n    boolean existsByStudentIdAndClassId(Integer studentUserId, Short classId);\n\n    // NEW METHODS for semester-scoped student searches\n    List<StudentSemesterDTO> searchBySemesterId(Short semesterId, StudentSemesterSearchRequest request);\n\n    Long countBySemesterId(Short semesterId, StudentSemesterSearchRequest request);\n\n    // Student Dashboard queries\n    List<com.fuacs.backend.dto.response.StudentSubjectDTO> findCurrentSemesterSubjectsByStudentId(Integer studentUserId, Short currentSemesterId);\n\n    // Get distinct semesters where student has enrolled classes\n    List<SemesterDTO> findDistinctSemestersByStudentId(Integer studentId);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomExamAttendanceRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomExamAttendanceRepository.java",
      "filename": "CustomExamAttendanceRepository.java",
      "size_bytes": 383,
      "lines": 11,
      "last_modified": "2025-11-28T08:56:33.012551",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.ExamAttendanceSearchRequest;\nimport com.fuacs.backend.dto.response.ExamAttendanceDTO;\nimport java.util.List;\n\npublic interface CustomExamAttendanceRepository {\n    List<ExamAttendanceDTO> search(ExamAttendanceSearchRequest request);\n    Long count(ExamAttendanceSearchRequest request);\n}\n\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomExamSlotParticipantRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomExamSlotParticipantRepository.java",
      "filename": "CustomExamSlotParticipantRepository.java",
      "size_bytes": 1324,
      "lines": 33,
      "last_modified": "2025-11-28T08:56:33.012551",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.ExamSlotParticipantSearchRequest;\nimport com.fuacs.backend.dto.request.PagedRequest;\nimport com.fuacs.backend.dto.response.ExamSlotParticipantDTO;\n\nimport java.util.List;\n\npublic interface CustomExamSlotParticipantRepository {\n\n    List<ExamSlotParticipantDTO> search(Integer slotId, ExamSlotParticipantSearchRequest request);\n\n    Long count(Integer slotId, ExamSlotParticipantSearchRequest request);\n\n    /**\n     * Search ALL participants across all subjects for a slot (no subject filter)\n     */\n    List<ExamSlotParticipantDTO> searchAllBySlotId(Integer slotId, PagedRequest request);\n\n    /**\n     * Count ALL participants across all subjects for a slot (no subject filter)\n     */\n    Long countAllBySlotId(Integer slotId, PagedRequest request);\n\n    ExamSlotParticipantDTO findByIdWithDetails(Long participantId);\n\n    /**\n     * Find all students with their attendance information for a specific exam slot\n     * This method returns comprehensive attendance data including check-in/check-out times,\n     * evidence, and remark for all students enrolled in the exam slot\n     */\n    List<com.fuacs.backend.dto.response.StudentAttendanceInfoDTO> findStudentsWithAttendanceBySlotId(Integer slotId);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomExamSlotSubjectRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomExamSlotSubjectRepository.java",
      "filename": "CustomExamSlotSubjectRepository.java",
      "size_bytes": 244,
      "lines": 10,
      "last_modified": "2025-11-28T08:56:33.013549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.response.SubjectDTO;\n\nimport java.util.List;\n\npublic interface CustomExamSlotSubjectRepository {\n\n    List<SubjectDTO> findSubjectsBySlotId(Integer slotId);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomMajorRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomMajorRepository.java",
      "filename": "CustomMajorRepository.java",
      "size_bytes": 329,
      "lines": 11,
      "last_modified": "2025-11-28T08:56:33.013549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.MajorSearchRequest;\nimport com.fuacs.backend.dto.response.MajorDTO;\n\nimport java.util.List;\n\npublic interface CustomMajorRepository {\n    List<MajorDTO> search(MajorSearchRequest request);\n    Long count(MajorSearchRequest request);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomRoleRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomRoleRepository.java",
      "filename": "CustomRoleRepository.java",
      "size_bytes": 415,
      "lines": 13,
      "last_modified": "2025-11-28T08:56:33.013549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.entity.Role;\nimport org.springframework.data.domain.Pageable;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic interface CustomRoleRepository {\n    List<Role> searchRoles(String search, Boolean isActive, Set<String> exclude, Pageable pageable);\n    Long countAllRoles(String search, Boolean isActive, Set<String> exclude);\n}\n\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomRoomRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomRoomRepository.java",
      "filename": "CustomRoomRepository.java",
      "size_bytes": 3474,
      "lines": 80,
      "last_modified": "2025-11-28T08:56:33.013549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.RoomSearchRequest;\nimport com.fuacs.backend.dto.response.RoomDTO;\n\nimport java.time.LocalDate;\nimport java.util.List;\n\n/**\n * Custom repository interface định nghĩa các query phức tạp cho Room.\n * Implementation nằm trong RoomRepositoryImpl sử dụng EntityManager và JPQL.\n *\n * @see com.fuacs.backend.repository.impl.RoomRepositoryImpl\n */\npublic interface CustomRoomRepository {\n    /**\n     * Search phòng với filter thông thường (không staff-scoped).\n     * Trả về danh sách phòng với thống kê camera (totalCameras, activeCameras).\n     *\n     * @param request Chứa filters: search keyword, isActive, hasCamera, pagination\n     * @return Danh sách RoomDTO với camera statistics\n     */\n    List<RoomDTO> search(RoomSearchRequest request);\n\n    /**\n     * Đếm tổng số phòng thỏa mãn filter thông thường.\n     * Dùng để tính total pages cho pagination.\n     *\n     * @param request Chứa filters: search keyword, isActive, hasCamera\n     * @return Tổng số phòng thỏa mãn filter\n     */\n    Long count(RoomSearchRequest request);\n\n    /**\n     * Search phòng theo staff ID (staff-scoped search).\n     * Chỉ trả về phòng mà staff có ít nhất 1 slot được assigned.\n     * Kết quả bao gồm usageCount và lastUsedAt của staff đó với phòng.\n     *\n     * @param staffId ID của staff (Lecturer hoặc Supervisor)\n     * @param request Chứa filters: search keyword, isActive, semesterId, pagination\n     * @return Danh sách RoomDTO với usage statistics cho staff\n     */\n    List<RoomDTO> searchByStaffId(Integer staffId, RoomSearchRequest request);\n\n    /**\n     * Đếm tổng số phòng thỏa mãn staff-scoped filter.\n     * Dùng để tính total pages cho pagination trong staff-scoped search.\n     *\n     * @param staffId ID của staff\n     * @param request Chứa filters: search keyword, isActive, semesterId\n     * @return Tổng số phòng mà staff có slot\n     */\n    Long countByStaffId(Integer staffId, RoomSearchRequest request);\n\n    /**\n     * Search phòng theo staff ID với date range filter.\n     * Tương tự searchByStaffId nhưng thêm filter theo khoảng thời gian slot.\n     *\n     * @param staffId ID của staff\n     * @param request Chứa filters: search keyword, isActive, semesterId, pagination\n     * @param startDate Ngày bắt đầu filter (slot.startTime >= startDate)\n     * @param endDate Ngày kết thúc filter (slot.endTime <= endDate)\n     * @return Danh sách RoomDTO với usage statistics trong khoảng thời gian\n     */\n    List<RoomDTO> searchByStaffIdWithDateRange(Integer staffId, RoomSearchRequest request,\n            LocalDate startDate, LocalDate endDate);\n\n    /**\n     * Đếm tổng số phòng thỏa mãn staff-scoped filter với date range.\n     * Dùng để tính total pages cho pagination.\n     *\n     * @param staffId ID của staff\n     * @param request Chứa filters: search keyword, isActive, semesterId\n     * @param startDate Ngày bắt đầu filter\n     * @param endDate Ngày kết thúc filter\n     * @return Tổng số phòng mà staff có slot trong khoảng thời gian\n     */\n    Long countByStaffIdWithDateRange(Integer staffId, RoomSearchRequest request,\n            LocalDate startDate, LocalDate endDate);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomSemesterRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomSemesterRepository.java",
      "filename": "CustomSemesterRepository.java",
      "size_bytes": 571,
      "lines": 18,
      "last_modified": "2025-11-28T08:56:33.013549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.SemesterSearchRequest;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.entity.Semester;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n@Repository\npublic interface CustomSemesterRepository {\n    List<SemesterDTO> search(SemesterSearchRequest request);\n\n    Long count(SemesterSearchRequest request);\n\n    // Supervisor dashboard queries\n    List<Semester> findSemestersWithSupervisionData(Integer supervisorId);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomSlotRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomSlotRepository.java",
      "filename": "CustomSlotRepository.java",
      "size_bytes": 6163,
      "lines": 141,
      "last_modified": "2025-11-28T08:56:33.013549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.SlotSearchRequest;\nimport com.fuacs.backend.dto.response.SlotDTO;\nimport com.fuacs.backend.dto.response.SlotRosterItemDTO;\nimport com.fuacs.backend.dto.response.AttendanceStatsDTO;\nimport com.fuacs.backend.dto.response.DashboardStatsDTO;\nimport com.fuacs.backend.dto.response.RecentActivitySlotDTO;\nimport com.fuacs.backend.dto.response.TodaySlotDTO;\nimport com.fuacs.backend.dto.response.SupervisorStatsDTO;\n\nimport java.util.List;\nimport java.time.LocalDateTime;\n\npublic interface CustomSlotRepository {\n    List<SlotDTO> search(SlotSearchRequest request);\n\n    Long count(SlotSearchRequest request);\n\n    List<SlotDTO> searchByStudentId(SlotSearchRequest request);\n\n    Long countByStudentId(SlotSearchRequest request);\n\n    List<SlotDTO> searchByClassId(Short classId, SlotSearchRequest request);\n\n    Long countByClassId(Short classId, SlotSearchRequest request);\n\n    List<SlotDTO> searchByRoomId(Short roomId, SlotSearchRequest request);\n\n    Long countByRoomId(Short roomId, SlotSearchRequest request);\n\n    boolean existsByRoomAndTimeRange(Short roomId, java.time.LocalDateTime startTime, java.time.LocalDateTime endTime, Integer excludeId);\n\n    boolean existsByStaffAndTimeRange(Integer staffUserId, java.time.LocalDateTime startTime, java.time.LocalDateTime endTime, Integer excludeId);\n\n    Long countAttendanceRecordsBySlotId(Integer slotId);\n\n    Long countExamAttendanceRecordsBySlotId(Integer slotId);\n\n    List<SlotRosterItemDTO> getSlotRoster(Integer slotId);\n\n    // Dashboard queries\n    DashboardStatsDTO calculateLecturerStats(Integer lecturerId, Short semesterId);\n\n    // Dashboard queries - All Semester variants (no semester filter)\n    DashboardStatsDTO calculateLecturerStatsAllSemesters(Integer lecturerId);\n\n    Integer calculateUpcomingSlots(Integer lecturerId, Short semesterId);\n\n    Integer calculateUpcomingSlotsAllSemesters(Integer lecturerId);\n\n    Integer calculateTotalStudents(Integer lecturerId, Short semesterId);\n\n    Integer calculateTotalStudentsAllSemesters(Integer lecturerId);\n\n    List<TodaySlotDTO> findTodaySlots(Integer lecturerId, LocalDateTime startOfDay, LocalDateTime endOfDay);\n\n    List<RecentActivitySlotDTO> findRecentActivitySlots(Integer lecturerId, LocalDateTime startDate, LocalDateTime endDate);\n\n    // Dashboard queries with semester filter\n    List<TodaySlotDTO> findTodaySlotsBySemester(Integer lecturerId, Short semesterId, LocalDateTime startOfDay, LocalDateTime endOfDay);\n\n    List<RecentActivitySlotDTO> findRecentActivitySlotsBySemester(Integer lecturerId, Short semesterId, LocalDateTime startDate, LocalDateTime endDate);\n\n    AttendanceStatsDTO getAttendanceStats(Integer slotId);\n\n    /**\n     * Find slots by class, semester, and category (LECTURE, LECTURE_WITH_PT).\n     * Excludes FINAL_EXAM slots as specified in requirements.\n     */\n    List<com.fuacs.backend.entity.Slot> findByClassAndSemesterAndCategory(Short classId, Short semesterId);\n\n    /**\n     * Find slot by ID with room and staff information eagerly loaded\n     */\n    com.fuacs.backend.entity.Slot findByIdWithRoomAndStaff(Integer slotId);\n\n    // Supervisor dashboard queries\n    SupervisorStatsDTO calculateSupervisorStats(Integer supervisorId, Short semesterId);\n\n    // Supervisor dashboard queries - All Semester variant\n    SupervisorStatsDTO calculateSupervisorStatsAllSemesters(Integer supervisorId);\n\n    List<TodaySlotDTO> findTodaySupervisionSlots(Integer supervisorId, Short semesterId, LocalDateTime startOfDay, LocalDateTime endOfDay);\n\n    List<RecentActivitySlotDTO> findRecentSupervisionActivity(Integer supervisorId, Short semesterId, LocalDateTime startDate, LocalDateTime endDate);\n\n    List<TodaySlotDTO> findUpcomingExamSlots(Integer supervisorId, Short semesterId, LocalDateTime fromTime, int maxResults);\n\n    // Lecturer Dashboard - Next Day Slots (LECTURE + LECTURE_WITH_PT only)\n    List<TodaySlotDTO> findUpcomingSlotsForNextDay(Integer lecturerId, Short semesterId, LocalDateTime startTime, LocalDateTime endTime);\n\n    List<TodaySlotDTO> findUpcomingSlotsForNextDayAllSemesters(Integer lecturerId, LocalDateTime startTime, LocalDateTime endTime);\n\n    // Student Dashboard queries\n    List<com.fuacs.backend.dto.response.StudentSlotDTO> findUpcomingLearningSlotsByStudentId(Integer studentUserId, LocalDateTime currentTime);\n\n    List<com.fuacs.backend.dto.response.StudentSlotDTO> findUpcomingExamSlotsByStudentId(Integer studentUserId, LocalDateTime currentTime);\n\n    /**\n     * Find slots for next scheduled day (dynamic - could be today, tomorrow, or later)\n     *\n     * @param studentUserId Student user ID\n     * @param semesterId Semester ID (null for all semesters)\n     * @param currentTime Current time to find next slots from\n     * @return List of slots for the next day that has any scheduled slots\n     */\n    List<com.fuacs.backend.dto.response.StudentSlotDTO> findNextDaySlotsByStudentId(\n            Integer studentUserId,\n            Short semesterId,\n            LocalDateTime currentTime\n    );\n\n    /**\n     * Find upcoming learning slots with semester filter\n     *\n     * @param studentUserId Student user ID\n     * @param semesterId Semester ID (null for all semesters)\n     * @param currentTime Current time\n     * @return List of upcoming learning slots\n     */\n    List<com.fuacs.backend.dto.response.StudentSlotDTO> findUpcomingLearningSlotsBySemester(\n            Integer studentUserId,\n            Short semesterId,\n            LocalDateTime currentTime\n    );\n\n    /**\n     * Find upcoming exam slots with semester filter\n     *\n     * @param studentUserId Student user ID\n     * @param semesterId Semester ID (null for all semesters)\n     * @param currentTime Current time\n     * @return List of upcoming exam slots\n     */\n    List<com.fuacs.backend.dto.response.StudentSlotDTO> findUpcomingExamSlotsBySemester(\n            Integer studentUserId,\n            Short semesterId,\n            LocalDateTime currentTime\n    );\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomStaffProfileRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomStaffProfileRepository.java",
      "filename": "CustomStaffProfileRepository.java",
      "size_bytes": 371,
      "lines": 12,
      "last_modified": "2025-11-28T08:56:33.013549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.StaffProfileSearchRequest;\nimport com.fuacs.backend.dto.response.StaffProfileDTO;\n\nimport java.util.List;\n\npublic interface CustomStaffProfileRepository {\n    List<StaffProfileDTO> search(StaffProfileSearchRequest request);\n\n    Long count(StaffProfileSearchRequest request);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomStudentProfileRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomStudentProfileRepository.java",
      "filename": "CustomStudentProfileRepository.java",
      "size_bytes": 762,
      "lines": 19,
      "last_modified": "2025-11-28T08:56:33.014549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.StudentProfileSearchRequest;\nimport com.fuacs.backend.dto.request.StudentSemesterSearchRequest;\nimport com.fuacs.backend.dto.response.StudentProfileDTO;\nimport com.fuacs.backend.dto.response.StudentSemesterDTO;\n\nimport java.util.List;\n\npublic interface CustomStudentProfileRepository {\n    List<StudentProfileDTO> search(StudentProfileSearchRequest request);\n\n    Long count(StudentProfileSearchRequest request);\n\n    // NEW METHODS for semester-scoped student searches\n    List<StudentSemesterDTO> searchBySemesterId(Short semesterId, StudentSemesterSearchRequest request);\n\n    Long countBySemesterId(Short semesterId, StudentSemesterSearchRequest request);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\custom\\CustomSubjectRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/custom/CustomSubjectRepository.java",
      "filename": "CustomSubjectRepository.java",
      "size_bytes": 931,
      "lines": 26,
      "last_modified": "2025-11-28T08:56:33.014549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.custom;\n\nimport com.fuacs.backend.dto.request.SubjectSearchRequest;\nimport com.fuacs.backend.dto.response.SubjectDTO;\n\nimport java.util.List;\n\npublic interface CustomSubjectRepository {\n    List<SubjectDTO> search(SubjectSearchRequest request);\n\n    Long count(SubjectSearchRequest request);\n\n    List<SubjectDTO> searchByMajorId(Short majorId, SubjectSearchRequest request);\n\n    Long countByMajorId(Short majorId, SubjectSearchRequest request);\n\n    // NEW METHODS for semester-scoped searches\n    List<SubjectDTO> searchBySemesterId(Short semesterId, SubjectSearchRequest request);\n\n    Long countBySemesterId(Short semesterId, SubjectSearchRequest request);\n\n    // NEW METHODS for staff-scoped searches\n    List<SubjectDTO> searchByStaffId(Integer staffId, SubjectSearchRequest request);\n\n    Long countByStaffId(Integer staffId, SubjectSearchRequest request);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\EnrollmentRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/EnrollmentRepository.java",
      "filename": "EnrollmentRepository.java",
      "size_bytes": 3216,
      "lines": 67,
      "last_modified": "2025-11-28T08:56:33.008538",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.Enrollment;\nimport com.fuacs.backend.entity.EnrollmentId;\nimport com.fuacs.backend.repository.custom.CustomEnrollmentRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n@Repository\npublic interface EnrollmentRepository extends JpaRepository<Enrollment, EnrollmentId>, CustomEnrollmentRepository {\n\n    // Check if student is enrolled in a subject during a semester\n    @Query(\"SELECT CASE WHEN COUNT(e) > 0 THEN true ELSE false END FROM Enrollment e \" +\n           \"WHERE e.student.id = :studentUserId \" +\n           \"AND e.academicClass.subject.id = :subjectId \" +\n           \"AND e.academicClass.semester.id = :semesterId \" +\n           \"AND e.isEnrolled = :enrolled\")\n    boolean existsByStudentAndSubjectAndSemesterAndEnrolled(\n            @Param(\"studentUserId\") Integer studentUserId,\n            @Param(\"subjectId\") Integer subjectId,\n            @Param(\"semesterId\") Short semesterId,\n            @Param(\"enrolled\") Boolean enrolled);\n\n    /**\n     * Find all enrollments for a specific class.\n     * Used for getting all enrolled students in a class for attendance matrix.\n     *\n     * @param classId The academic class ID\n     * @return List of enrollments with eager-loaded student\n     */\n    @Query(\"SELECT e FROM Enrollment e JOIN FETCH e.student WHERE e.academicClass.id = :classId AND e.isEnrolled = true\")\n    List<Enrollment> findAllByAcademicClassId(@Param(\"classId\") Short classId);\n\n    //\n    // @Query(\"SELECT COUNT(e.id) FROM Enrollment e WHERE e.academicClass.id =\n    // :classId AND e.isEnrolled = :isEnrolled\")\n    // Long countByClassIdAndIsEnrolled(@Param(\"classId\") Short classId,\n    // @Param(\"isEnrolled\") Boolean isEnrolled);\n    //\n    // @Query(\"SELECT COUNT(e.id) FROM Enrollment e WHERE e.academicClass.id =\n    // :classId\")\n    // Long countByClassId(@Param(\"classId\") Short classId);\n    //\n    // @Query(\"SELECT e FROM Enrollment e WHERE e.student.userId = :studentUserId\n    // AND e.academicClass.id = :classId\")\n    // Optional<Enrollment> findByStudentIdAndClassId(@Param(\"studentUserId\")\n    // Integer studentUserId, @Param(\"classId\") Short classId);\n    //\n    // @Query(\"SELECT e FROM Enrollment e WHERE e.academicClass.id = :classId AND\n    // e.isEnrolled = :isEnrolled\")\n    // List<Enrollment> findByClassIdAndIsEnrolled(@Param(\"classId\") Short classId,\n    // @Param(\"isEnrolled\") Boolean isEnrolled);\n    //\n    // boolean existsByClassIdAndStudentUserId(Short classId, Integer\n    // studentUserId);\n    //\n    // @Query(\"SELECT CASE WHEN COUNT(e) > 0 THEN true ELSE false END FROM\n    // Enrollment e WHERE e.academicClass.id = :classId AND e.student.userId =\n    // :studentUserId AND e.isEnrolled = :isEnrolled\")\n    // boolean existsByClassIdAndStudentUserIdAndIsEnrolled(@Param(\"classId\") Short\n    // classId, @Param(\"studentUserId\") Integer studentUserId, @Param(\"isEnrolled\")\n    // Boolean isEnrolled);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\ExamAttendanceEvidenceRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/ExamAttendanceEvidenceRepository.java",
      "filename": "ExamAttendanceEvidenceRepository.java",
      "size_bytes": 653,
      "lines": 15,
      "last_modified": "2025-11-28T08:56:33.008538",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.ExamAttendanceEvidence;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface ExamAttendanceEvidenceRepository extends JpaRepository<ExamAttendanceEvidence, Long> {\n\n    @Query(\"SELECT e FROM ExamAttendanceEvidence e WHERE e.examAttendance.id = :examAttendanceId\")\n    ExamAttendanceEvidence findByExamAttendanceId(@Param(\"examAttendanceId\") Long examAttendanceId);\n}\n\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\ExamAttendanceRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/ExamAttendanceRepository.java",
      "filename": "ExamAttendanceRepository.java",
      "size_bytes": 6330,
      "lines": 123,
      "last_modified": "2025-12-01T19:50:25.960324",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.ExamAttendance;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.constant.enums.AttendanceMethod;\nimport com.fuacs.backend.constant.enums.AttendanceStatus;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Modifying;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.Optional;\n\n@Repository\npublic interface ExamAttendanceRepository extends JpaRepository<ExamAttendance, Long>, com.fuacs.backend.repository.custom.CustomExamAttendanceRepository {\n\n    @Query(\"SELECT ea FROM ExamAttendance ea WHERE ea.slot.id = :slotId AND ea.student.id = :studentUserId\")\n    ExamAttendance findBySlotIdAndStudentUserId(@Param(\"slotId\") Integer slotId,\n            @Param(\"studentUserId\") Integer studentUserId);\n\n    @Query(\"SELECT ea FROM ExamAttendance ea WHERE ea.slot.id = :slotId\")\n    List<ExamAttendance> findBySlotId(@Param(\"slotId\") Integer slotId);\n\n    @Query(\"SELECT ea FROM ExamAttendance ea WHERE ea.student.id = :studentUserId\")\n    List<ExamAttendance> findByStudentUserId(@Param(\"studentUserId\") Integer studentUserId);\n\n    @Query(\"SELECT ea FROM ExamAttendance ea WHERE ea.slot.id = :slotId AND ea.status = :status\")\n    List<ExamAttendance> findBySlotIdAndStatus(@Param(\"slotId\") Integer slotId,\n            @Param(\"status\") com.fuacs.backend.constant.enums.AttendanceStatus status);\n\n    @Query(\"SELECT COUNT(ea) FROM ExamAttendance ea WHERE ea.slot.id = :slotId\")\n    Long countBySlotId(@Param(\"slotId\") Integer slotId);\n\n    @Query(\"SELECT COUNT(ea) FROM ExamAttendance ea WHERE ea.slot.id = :slotId AND ea.status = :status\")\n    Long countBySlotIdAndStatus(@Param(\"slotId\") Integer slotId,\n            @Param(\"status\") com.fuacs.backend.constant.enums.AttendanceStatus status);\n\n    // ========== New methods for Exam Session Management ==========\n\n    /**\n     * Count exam attendance records that are NOT in the specified status\n     * Used for category transition validation (count PRESENT/ABSENT)\n     */\n    @Query(\"SELECT COUNT(ea) FROM ExamAttendance ea WHERE ea.slot.id = :slotId AND ea.status <> :excludeStatus\")\n    Long countBySlotIdAndStatusNot(@Param(\"slotId\") Integer slotId,\n                                    @Param(\"excludeStatus\") com.fuacs.backend.constant.enums.AttendanceStatus excludeStatus);\n\n    /**\n     * Find exam attendance by slot and user ID (for recognition callback routing)\n     * Returns Optional for safer null handling\n     */\n    @Query(\"SELECT ea FROM ExamAttendance ea WHERE ea.slot.id = :slotId AND ea.student.id = :userId\")\n    Optional<ExamAttendance> findBySlotIdAndUserId(@Param(\"slotId\") Integer slotId,\n                                                    @Param(\"userId\") Integer userId);\n\n    /**\n     * Delete all exam attendance records for a specific slot\n     * Used when transitioning from LECTURE_WITH_PT to LECTURE (if all NOT_YET)\n     */\n    @Modifying\n    @Query(\"DELETE FROM ExamAttendance ea WHERE ea.slot.id = :slotId\")\n    void deleteBySlotId(@Param(\"slotId\") Integer slotId);\n\n    @Query(\"SELECT ea FROM ExamAttendance ea WHERE ea.slot.id = :slotId AND ea.needsReview = :needsReview\")\n    List<ExamAttendance> findBySlotIdAndNeedsReview(@Param(\"slotId\") Integer slotId,\n            @Param(\"needsReview\") Boolean needsReview);\n\n    /**\n     * Find exam attendance statuses for a specific student across multiple slots.\n     * Used for populating student-specific attendance status in slot lists (FINAL_EXAM slots).\n     *\n     * @param slotIds List of slot IDs to query\n     * @param studentUserId Student user ID\n     * @return List of [slotId, status] tuples\n     */\n    @Query(\"SELECT ea.slot.id, ea.status FROM ExamAttendance ea \" +\n           \"WHERE ea.slot.id IN :slotIds AND ea.student.id = :studentUserId\")\n    List<Object[]> findStatusesBySlotIdsAndStudent(@Param(\"slotIds\") List<Integer> slotIds,\n                                                    @Param(\"studentUserId\") Integer studentUserId);\n\n    /**\n     * Bulk update exam attendance status for all records of a slot matching the old status.\n     * Used for automatic exam attendance finalization to convert NOT_YET to ABSENT.\n     *\n     * @param slotId ID of the slot to update\n     * @param oldStatus Current status to match (e.g., NOT_YET)\n     * @param newStatus New status to set (e.g., ABSENT)\n     * @param method Method used for the update (e.g., SYSTEM_FINALIZE)\n     * @param recordedAt Timestamp when the update occurred\n     * @return Number of records updated\n     */\n    @Modifying\n    @Query(\"UPDATE ExamAttendance ea SET ea.status = :newStatus, \" +\n           \"ea.method = :method, ea.recordedAt = :recordedAt \" +\n           \"WHERE ea.slot.id = :slotId AND ea.status = :oldStatus\")\n    int bulkUpdateExamStatus(@Param(\"slotId\") Integer slotId,\n                            @Param(\"oldStatus\") AttendanceStatus oldStatus,\n                            @Param(\"newStatus\") AttendanceStatus newStatus,\n                            @Param(\"method\") AttendanceMethod method,\n                            @Param(\"recordedAt\") Instant recordedAt);\n\n    /**\n     * Find students with a specific exam attendance status for a slot.\n     * Used for sending absence notifications after finalization.\n     */\n    @Query(\"SELECT ea.student FROM ExamAttendance ea WHERE ea.slot.id = :slotId AND ea.status = :status\")\n    List<User> findStudentsBySlotIdAndStatus(@Param(\"slotId\") Integer slotId,\n                                              @Param(\"status\") AttendanceStatus status);\n\n    /**\n     * Reset needsReview flag to false for all exam attendance records of a slot.\n     * Used during exam attendance finalization to clear review flags.\n     *\n     * @param slotId ID of the slot to update\n     * @return Number of records updated\n     */\n    @Modifying\n    @Query(\"UPDATE ExamAttendance ea SET ea.needsReview = false WHERE ea.slot.id = :slotId AND ea.needsReview = true\")\n    int resetNeedsReviewBySlotId(@Param(\"slotId\") Integer slotId);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\ExamSlotParticipantRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/ExamSlotParticipantRepository.java",
      "filename": "ExamSlotParticipantRepository.java",
      "size_bytes": 2032,
      "lines": 43,
      "last_modified": "2025-11-28T08:56:33.009544",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.ExamSlotParticipant;\nimport com.fuacs.backend.repository.custom.CustomExamSlotParticipantRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@Repository\npublic interface ExamSlotParticipantRepository extends JpaRepository<ExamSlotParticipant, Long>,\n        CustomExamSlotParticipantRepository {\n\n    boolean existsByExamSlotSubjectIdAndStudentUserIdAndIsEnrolled(Long examSlotSubjectId, Integer studentUserId, Boolean isEnrolled);\n\n    Optional<ExamSlotParticipant> findByExamSlotSubjectIdAndStudentUserId(Long examSlotSubjectId, Integer studentUserId);\n\n    Long countByExamSlotSubject_Slot_IdAndExamSlotSubject_Subject_IdAndIsEnrolled(Integer slotId, Integer subjectId, Boolean isEnrolled);\n\n    // Count all enrolled participants for a slot (for deactivation check)\n    Long countByExamSlotSubject_Slot_IdAndIsEnrolled(Integer slotId, Boolean isEnrolled);\n\n    // Check if student is already enrolled in this slot (any subject)\n    boolean existsByExamSlotSubject_Slot_IdAndStudentUserIdAndIsEnrolled(Integer slotId, Integer studentUserId, Boolean isEnrolled);\n\n    /**\n     * Find all enrolled participants for a slot with students eager-loaded.\n     * Optimized with JOIN FETCH to avoid N+1 query problem.\n     *\n     * @param slotId The slot ID\n     * @return List of participants with students loaded\n     */\n    @Query(\"SELECT esp FROM ExamSlotParticipant esp \" +\n           \"JOIN FETCH esp.studentUser s \" +\n           \"JOIN FETCH esp.examSlotSubject ess \" +\n           \"WHERE ess.slot.id = :slotId \" +\n           \"AND ess.isActive = true \" +\n           \"AND esp.isEnrolled = true\")\n    List<ExamSlotParticipant> findBySlotIdWithStudents(@Param(\"slotId\") Integer slotId);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\ExamSlotSubjectRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/ExamSlotSubjectRepository.java",
      "filename": "ExamSlotSubjectRepository.java",
      "size_bytes": 1893,
      "lines": 48,
      "last_modified": "2025-11-28T08:56:33.009544",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.ExamSlotSubject;\nimport com.fuacs.backend.repository.custom.CustomExamSlotSubjectRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@Repository\npublic interface ExamSlotSubjectRepository extends JpaRepository<ExamSlotSubject, Long>,\n        CustomExamSlotSubjectRepository {\n\n    // Keep existing methods for backward compatibility\n    List<ExamSlotSubject> findBySlotId(Integer slotId);\n\n    boolean existsBySlotIdAndSubjectId(Integer slotId, Integer subjectId);\n\n    Optional<ExamSlotSubject> findBySlotIdAndSubjectId(Integer slotId, Integer subjectId);\n\n    // New methods for soft delete support - filter by is_active = true\n    List<ExamSlotSubject> findBySlotIdAndIsActiveTrue(Integer slotId);\n\n    boolean existsBySlotIdAndSubjectIdAndIsActiveTrue(Integer slotId, Integer subjectId);\n\n    Optional<ExamSlotSubject> findBySlotIdAndSubjectIdAndIsActiveTrue(Integer slotId, Integer subjectId);\n\n    // Check if exam slot subject has active participants\n    @Query(\"\"\"\n        SELECT COUNT(p) > 0\n        FROM ExamSlotParticipant p\n        WHERE p.examSlotSubject.id = :examSlotSubjectId\n        AND p.isEnrolled = true\n        \"\"\")\n    boolean hasActiveParticipants(@Param(\"examSlotSubjectId\") Long examSlotSubjectId);\n\n    // Count active participants for error messages\n    @Query(\"\"\"\n        SELECT COUNT(p)\n        FROM ExamSlotParticipant p\n        WHERE p.examSlotSubject.id = :examSlotSubjectId\n        AND p.isEnrolled = true\n        \"\"\")\n    Long countActiveParticipants(@Param(\"examSlotSubjectId\") Long examSlotSubjectId);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\FaceEmbeddingRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/FaceEmbeddingRepository.java",
      "filename": "FaceEmbeddingRepository.java",
      "size_bytes": 1446,
      "lines": 39,
      "last_modified": "2025-11-28T08:56:33.009544",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.FaceEmbedding;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Modifying;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@Repository\npublic interface FaceEmbeddingRepository extends JpaRepository<FaceEmbedding, Integer> {\n\n    /**\n     * Find active embedding for a student\n     * Only one embedding should be active per student\n     */\n    Optional<FaceEmbedding> findByStudentIdAndIsActiveTrue(Integer studentId);\n\n    /**\n     * Find all embeddings for a student (ordered by version desc)\n     */\n    @Query(\"SELECT f FROM FaceEmbedding f WHERE f.student.id = :studentId ORDER BY f.version DESC\")\n    List<FaceEmbedding> findByStudentIdOrderByVersionDesc(@Param(\"studentId\") Integer studentId);\n\n    /**\n     * Deactivate all embeddings for a student (called before saving new embedding)\n     */\n    @Modifying\n    @Query(\"UPDATE FaceEmbedding f SET f.isActive = false WHERE f.student.id = :studentId\")\n    void deactivateByStudentId(@Param(\"studentId\") Integer studentId);\n\n    /**\n     * Check if student has any active embedding\n     */\n    boolean existsByStudentIdAndIsActiveTrue(Integer studentId);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\AttendanceHistoryRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/AttendanceHistoryRepositoryImpl.java",
      "filename": "AttendanceHistoryRepositoryImpl.java",
      "size_bytes": 16071,
      "lines": 306,
      "last_modified": "2025-11-28T08:56:33.014549",
      "encoding": "utf-8",
      "language": "java",
      "content": "// src/main/java/com/fuacs/backend/repository/impl/AttendanceHistoryRepositoryImpl.java\npackage com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.AttendanceHistorySearchRequest;\nimport com.fuacs.backend.dto.response.AttendanceHistoryDTO;\nimport com.fuacs.backend.dto.response.AttendanceSummaryDTO;\nimport com.fuacs.backend.dto.response.AttendanceSummaryDetailsDTO;\nimport com.fuacs.backend.dto.response.SummaryByTypeDTO;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.repository.custom.CustomAttendanceHistoryRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.Tuple;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Repository\npublic class AttendanceHistoryRepositoryImpl implements CustomAttendanceHistoryRepository {\n    private static final Map<String, String> SORTABLE_FIELDS = Map.of(\n            \"slotDate\", \"s.startTime\",\n            \"className\", \"c.code\",\n            \"subjectName\", \"sub.name\",\n            \"slotCategory\", \"s.slotCategory\");\n\n    @PersistenceContext\n    private EntityManager em;\n\n    @Override\n    public List<AttendanceHistoryDTO> searchByStudentId(Integer studentId, AttendanceHistorySearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, studentId, request);\n\n        String jpql = \"\"\"\n                SELECT NEW com.fuacs.backend.dto.response.AttendanceHistoryDTO(\n                    s.id,\n                    s.startTime,\n                    s.endTime,\n                    s.slotCategory,\n                    c.code,\n                    sub.code,\n                    sub.name,\n                    u.fullName,\n                    r.name,\n                    COALESCE(ar.status, ea.status),\n                    COALESCE(ar.method, ea.method),\n                    COALESCE(ar.remark, ea.remark),\n                    ar.id,\n                    ea.id\n                )\n                FROM Slot s\n                LEFT JOIN s.academicClass c\n                LEFT JOIN c.subject sub\n                LEFT JOIN c.semester sem\n                LEFT JOIN s.room r\n                LEFT JOIN s.staff u\n                LEFT JOIN AttendanceRecord ar ON ar.slot.id = s.id AND ar.student.id = :studentId\n                LEFT JOIN ExamAttendance ea ON ea.slot.id = s.id AND ea.student.id = :studentId\n                LEFT JOIN Enrollment e ON e.academicClass.id = c.id AND e.student.id = :studentId\n                \"\"\"\n                +\n                (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause + \" \") +\n                \"ORDER BY \" + getOrderByField(request.getSortBy()) + \" \" + request.getSort();\n\n        var query = em.createQuery(jpql, AttendanceHistoryDTO.class);\n        query.setParameter(\"studentId\", studentId);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public Long countByStudentId(Integer studentId, AttendanceHistorySearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, studentId, request);\n\n        String jpql = \"\"\"\n                SELECT COUNT(DISTINCT s.id)\n                FROM Slot s\n                LEFT JOIN s.academicClass c\n                LEFT JOIN c.subject sub\n                LEFT JOIN c.semester sem\n                LEFT JOIN s.room r\n                LEFT JOIN s.staff u\n                LEFT JOIN AttendanceRecord ar ON s.id = ar.slot.id AND ar.student.id = :studentId\n                LEFT JOIN ExamAttendance ea ON ea.slot.id = s.id AND ea.student.id = :studentId\n                LEFT JOIN Enrollment e ON e.academicClass.id = c.id AND e.student.id = :studentId\n                \"\"\" +\n                (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause);\n\n        var query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"studentId\", studentId);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public AttendanceSummaryDTO getAttendanceSummary(Integer studentId, AttendanceHistorySearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, studentId, request);\n\n        String jpql = \"\"\"\n                 SELECT\n                     COUNT(DISTINCT s.id) as totalSlots,\n                     COALESCE(SUM(CASE WHEN COALESCE(ar.status, ea.status, com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET) = com.fuacs.backend.constant.enums.AttendanceStatus.PRESENT THEN 1 ELSE 0 END), 0) as presentCount,\n                     COALESCE(SUM(CASE WHEN COALESCE(ar.status, ea.status, com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET) = com.fuacs.backend.constant.enums.AttendanceStatus.ABSENT THEN 1 ELSE 0 END), 0) as absentCount,\n                     COALESCE(SUM(CASE WHEN COALESCE(ar.status, ea.status, com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET) = com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET THEN 1 ELSE 0 END), 0) as notYetCount\n                 FROM Slot s\n                 LEFT JOIN s.academicClass c\n                 LEFT JOIN c.subject sub\n                 LEFT JOIN c.semester sem\n                 LEFT JOIN s.room r\n                 LEFT JOIN s.staff u\n                 LEFT JOIN AttendanceRecord ar ON ar.slot.id = s.id AND ar.student.id = :studentId\n                 LEFT JOIN ExamAttendance ea ON ea.slot.id = s.id AND ea.student.id = :studentId\n                 LEFT JOIN Enrollment e ON e.academicClass.id = c.id AND e.student.id = :studentId\n                \"\"\"\n                + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause);\n\n        var query = em.createQuery(jpql, Tuple.class);\n        query.setParameter(\"studentId\", studentId);\n        parameters.forEach(query::setParameter);\n\n        Tuple result = query.getSingleResult();\n\n        // Giờ đây, các dòng này sẽ an toàn vì COALESCE đảm bảo chúng không bao giờ là\n        // null\n        int totalSlots = ((Number) result.get(\"totalSlots\")).intValue();\n        int presentCount = ((Number) result.get(\"presentCount\")).intValue();\n        int absentCount = ((Number) result.get(\"absentCount\")).intValue();\n        int notYetCount = ((Number) result.get(\"notYetCount\")).intValue();\n\n        return new AttendanceSummaryDTO(totalSlots, presentCount, absentCount, notYetCount);\n    }\n\n    @Override\n    public AttendanceSummaryDetailsDTO getDetailedSummary(Integer studentId, AttendanceHistorySearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, studentId, request);\n\n        // Overall (reuse getAttendanceSummary)\n        AttendanceSummaryDTO overall = getAttendanceSummary(studentId, request);\n\n        // By category\n        String byCategoryJpql = \"\"\"\n                SELECT s.slotCategory as category,\n                       COUNT(DISTINCT s.id) as totalSlots,\n                       COALESCE(SUM(CASE WHEN COALESCE(ar.status, ea.status, com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET) = com.fuacs.backend.constant.enums.AttendanceStatus.PRESENT THEN 1 ELSE 0 END), 0) as presentCount,\n                       COALESCE(SUM(CASE WHEN COALESCE(ar.status, ea.status, com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET) = com.fuacs.backend.constant.enums.AttendanceStatus.ABSENT THEN 1 ELSE 0 END), 0) as absentCount,\n                       COALESCE(SUM(CASE WHEN COALESCE(ar.status, ea.status, com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET) = com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET THEN 1 ELSE 0 END), 0) as notYetCount\n                FROM Slot s\n                LEFT JOIN s.academicClass c\n                LEFT JOIN c.subject sub\n                LEFT JOIN s.semester sem\n                LEFT JOIN AttendanceRecord ar ON ar.slot.id = s.id AND ar.student.id = :studentId\n                LEFT JOIN ExamAttendance ea ON ea.slot.id = s.id AND ea.student.id = :studentId\n                LEFT JOIN Enrollment e ON e.academicClass.id = c.id AND e.student.id = :studentId\n                \"\"\"\n                + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause) + \" GROUP BY s.slotCategory\";\n\n        var catQuery = em.createQuery(byCategoryJpql, Tuple.class);\n        catQuery.setParameter(\"studentId\", studentId);\n        parameters.forEach(catQuery::setParameter);\n        List<Tuple> catRows = catQuery.getResultList();\n        Map<String, AttendanceSummaryDTO> byCategory = new HashMap<>();\n        for (Tuple t : catRows) {\n            SlotCategory category = (SlotCategory) t.get(\"category\");\n            int totalSlots = ((Number) t.get(\"totalSlots\")).intValue();\n            int presentCount = ((Number) t.get(\"presentCount\")).intValue();\n            int absentCount = ((Number) t.get(\"absentCount\")).intValue();\n            int notYetCount = ((Number) t.get(\"notYetCount\")).intValue();\n            byCategory.put(category.name(),\n                    new AttendanceSummaryDTO(totalSlots, presentCount, absentCount, notYetCount));\n        }\n\n        // By type: class vs exam\n        // class type = LECTURE + LECTURE_WITH_PT\n        // exam type = FINAL_EXAM\n        AttendanceSummaryDTO classSummary = aggregateForCategories(studentId, request,\n                List.of(SlotCategory.LECTURE, SlotCategory.LECTURE_WITH_PT));\n        AttendanceSummaryDTO examSummary = aggregateForCategories(studentId, request, List.of(SlotCategory.FINAL_EXAM));\n\n        SummaryByTypeDTO byType = new SummaryByTypeDTO();\n        byType.setClazz(classSummary);\n        byType.setExam(examSummary);\n\n        AttendanceSummaryDetailsDTO details = new AttendanceSummaryDetailsDTO();\n        details.setOverall(overall);\n        details.setByType(byType);\n        details.setByCategory(byCategory);\n        return details;\n    }\n\n    private AttendanceSummaryDTO aggregateForCategories(Integer studentId, AttendanceHistorySearchRequest request,\n            List<SlotCategory> categories) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, studentId, request);\n\n        String catFilter = categories.isEmpty() ? \"\" : \" AND s.slotCategory IN :categories\";\n        String jpql = \"\"\"\n                SELECT COUNT(DISTINCT s.id),\n                       COALESCE(SUM(CASE WHEN COALESCE(ar.status, ea.status, com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET) = com.fuacs.backend.constant.enums.AttendanceStatus.PRESENT THEN 1 ELSE 0 END), 0),\n                       COALESCE(SUM(CASE WHEN COALESCE(ar.status, ea.status, com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET) = com.fuacs.backend.constant.enums.AttendanceStatus.ABSENT THEN 1 ELSE 0 END), 0),\n                       COALESCE(SUM(CASE WHEN COALESCE(ar.status, ea.status, com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET) = com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET THEN 1 ELSE 0 END), 0)\n                FROM Slot s\n                LEFT JOIN s.academicClass c\n                LEFT JOIN c.subject sub\n                LEFT JOIN s.semester sem\n                LEFT JOIN AttendanceRecord ar ON ar.slot.id = s.id AND ar.student.id = :studentId\n                LEFT JOIN ExamAttendance ea ON ea.slot.id = s.id AND ea.student.id = :studentId\n                LEFT JOIN Enrollment e ON e.academicClass.id = c.id AND e.student.id = :studentId\n                \"\"\"\n                + (whereClause.isEmpty() ? \" WHERE 1=1\" : \" WHERE \" + whereClause) + catFilter;\n\n        var query = em.createQuery(jpql, Tuple.class);\n        query.setParameter(\"studentId\", studentId);\n        parameters.forEach(query::setParameter);\n        if (!categories.isEmpty()) {\n            query.setParameter(\"categories\", categories);\n        }\n        Tuple t = query.getSingleResult();\n        int totalSlots = ((Number) t.get(0)).intValue();\n        int presentCount = ((Number) t.get(1)).intValue();\n        int absentCount = ((Number) t.get(2)).intValue();\n        int notYetCount = ((Number) t.get(3)).intValue();\n        return new AttendanceSummaryDTO(totalSlots, presentCount, absentCount, notYetCount);\n    }\n\n    private String buildWhereClause(Map<String, Object> parameters, Integer studentId,\n            AttendanceHistorySearchRequest request) {\n        List<String> whereClauses = new ArrayList<>();\n\n        // Only include slots for classes where the student is enrolled\n        whereClauses.add(\"e.isEnrolled = true\");\n\n        if (request.getSemesterId() != null) {\n            whereClauses.add(\"sem.id = :semesterId\");\n            parameters.put(\"semesterId\", request.getSemesterId());\n        }\n\n        if (request.getClassId() != null) {\n            whereClauses.add(\"c.id = :classId\");\n            parameters.put(\"classId\", request.getClassId());\n            // Smart rule: if classId is specified, exclude FINAL_EXAM\n            whereClauses.add(\"s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\");\n        }\n\n        if (request.getAttendanceStatus() != null) {\n            whereClauses.add(\n                    \"COALESCE(ar.status, ea.status, com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET) = :attendanceStatus\");\n            parameters.put(\"attendanceStatus\", request.getAttendanceStatus());\n        }\n\n        if (request.getSlotCategory() != null) {\n            whereClauses.add(\"s.slotCategory = :slotCategory\");\n            parameters.put(\"slotCategory\", request.getSlotCategory());\n        }\n\n        if (request.getSubjectId() != null) {\n            whereClauses.add(\"sub.id = :subjectId\");\n            parameters.put(\"subjectId\", request.getSubjectId());\n        }\n\n        // attendanceType: class | exam | all\n        if (StringUtils.hasText(request.getAttendanceType())) {\n            String type = request.getAttendanceType().toLowerCase();\n            if (type.equals(\"class\")) {\n                whereClauses.add(\"s.slotCategory IN (:classCats)\");\n                parameters.put(\"classCats\", List.of(SlotCategory.LECTURE, SlotCategory.LECTURE_WITH_PT));\n            } else if (type.equals(\"exam\")) {\n                // Exam attendance: include LECTURE_WITH_PT + FINAL_EXAM\n                whereClauses.add(\"s.slotCategory IN (:examCats)\");\n                parameters.put(\"examCats\", List.of(SlotCategory.LECTURE_WITH_PT, SlotCategory.FINAL_EXAM));\n            }\n        }\n\n        if (request.getStartDate() != null) {\n            whereClauses.add(\"s.startTime >= :startDateTime\");\n            parameters.put(\"startDateTime\", request.getStartDate().atStartOfDay());\n        }\n\n        if (request.getEndDate() != null) {\n            whereClauses.add(\"s.startTime < :endDateTime\");\n            parameters.put(\"endDateTime\", request.getEndDate().plusDays(1).atStartOfDay());\n        }\n\n        if (StringUtils.hasText(request.getSearch())) {\n            whereClauses.add(\"(LOWER(c.code) LIKE :search OR LOWER(sub.name) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + request.getSearch().toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", whereClauses);\n    }\n\n    private String getOrderByField(String sortBy) {\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            return SORTABLE_FIELDS.get(sortBy);\n        }\n        return \"s.startTime\"; // Default sort field\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\AttendanceRecordRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/AttendanceRecordRepositoryImpl.java",
      "filename": "AttendanceRecordRepositoryImpl.java",
      "size_bytes": 10258,
      "lines": 233,
      "last_modified": "2025-11-28T11:04:38.675162",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.AttendanceRecordSearchRequest;\nimport com.fuacs.backend.dto.response.AttendanceRecordDTO;\nimport com.fuacs.backend.repository.custom.CustomAttendanceRecordRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Repository\npublic class AttendanceRecordRepositoryImpl implements CustomAttendanceRecordRepository {\n    private static final Map<String, String> SORTABLE_FIELDS = Map.of(\n            \"id\", \"ar.id\",\n            \"recordedAt\", \"ar.recordedAt\",\n            \"createdAt\", \"ar.createdAt\",\n            \"updatedAt\", \"ar.updatedAt\",\n            \"studentFullName\", \"u.fullName\",\n            \"studentRollNumber\", \"sp.rollNumber\",\n            \"slotTitle\", \"s.title\",\n            \"slotStartTime\", \"s.startTime\"\n    );\n\n    @PersistenceContext\n    private EntityManager em;\n\n    @Override\n    public List<AttendanceRecordDTO> search(AttendanceRecordSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT NEW com.fuacs.backend.dto.response.AttendanceRecordDTO(\" +\n                        \"ar.id, \" +\n                        \"u.id, u.fullName, sp.rollNumber, u.email, m.name, \" +\n                        \"s.id, s.title, s.startTime, s.endTime, s.slotCategory, \" +\n                        \"r.id, r.name, r.location, \" +\n                        \"su.id, su.fullName, \" +\n                        \"c.id, c.code, sub.id, sub.name, sub.code, sem.id, sem.name, sem.code, \" +\n                        \"ar.status, ar.method, ar.recordedAt, ar.needsReview, ar.createdAt, ar.updatedAt) \" +\n                        \"FROM AttendanceRecord ar \" +\n                        \"JOIN ar.student u \" +\n                        \"LEFT JOIN StudentProfile sp ON sp.user.id = u.id \" +\n                        \"LEFT JOIN sp.major m \" +\n                        \"JOIN ar.slot s \" +\n                        \"LEFT JOIN s.room r \" +\n                        \"LEFT JOIN s.staff su \" +\n                        \"LEFT JOIN s.academicClass c \" +\n                        \"LEFT JOIN c.subject sub \" +\n                        \"LEFT JOIN c.semester sem\"\n        );\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        String sortBy = request.getSortBy();\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            String sortField = SORTABLE_FIELDS.get(sortBy);\n            jpql.append(\" ORDER BY \").append(sortField).append(\" \").append(request.getSort());\n        } else {\n            jpql.append(\" ORDER BY ar.recordedAt DESC\");\n        }\n\n        TypedQuery<AttendanceRecordDTO> query = em.createQuery(jpql.toString(), AttendanceRecordDTO.class);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public Long count(AttendanceRecordSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT COUNT(DISTINCT ar.id) \" +\n                        \"FROM AttendanceRecord ar \" +\n                        \"JOIN ar.student u \" +\n                        \"LEFT JOIN StudentProfile sp ON sp.user.id = u.id \" +\n                        \"LEFT JOIN sp.major m \" +\n                        \"JOIN ar.slot s \" +\n                        \"LEFT JOIN s.room r \" +\n                        \"LEFT JOIN s.staff su \" +\n                        \"LEFT JOIN s.academicClass c \" +\n                        \"LEFT JOIN c.subject sub \" +\n                        \"LEFT JOIN c.semester sem\"\n        );\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    private String buildWhereClause(Map<String, Object> parameters, AttendanceRecordSearchRequest request) {\n        List<String> whereClauses = new ArrayList<>();\n\n        if (request.getSlotId() != null) {\n            whereClauses.add(\"s.id = :slotId\");\n            parameters.put(\"slotId\", request.getSlotId());\n        }\n\n        if (request.getStudentUserId() != null) {\n            whereClauses.add(\"u.id = :studentUserId\");\n            parameters.put(\"studentUserId\", request.getStudentUserId());\n        }\n\n        if (request.getClassId() != null) {\n            whereClauses.add(\"c.id = :classId\");\n            parameters.put(\"classId\", request.getClassId());\n        }\n\n        if (request.getSemesterId() != null) {\n            whereClauses.add(\"sem.id = :semesterId\");\n            parameters.put(\"semesterId\", request.getSemesterId());\n        }\n\n        if (request.getStatus() != null) {\n            whereClauses.add(\"ar.status = :status\");\n            parameters.put(\"status\", request.getStatus());\n        }\n\n        if (request.getMethod() != null) {\n            whereClauses.add(\"ar.method = :method\");\n            parameters.put(\"method\", request.getMethod());\n        }\n\n        if (request.getStartDate() != null) {\n            LocalDateTime startOfDay = request.getStartDate().atStartOfDay();\n            whereClauses.add(\"s.startTime >= :startDate\");\n            parameters.put(\"startDate\", startOfDay);\n        }\n\n        if (request.getEndDate() != null) {\n            LocalDateTime endOfDay = request.getEndDate().atTime(23, 59, 59);\n            whereClauses.add(\"s.startTime <= :endDate\");\n            parameters.put(\"endDate\", endOfDay);\n        }\n\n        String search = request.getSearch();\n        if (StringUtils.hasText(search)) {\n            whereClauses.add(\"(LOWER(u.fullName) LIKE :search OR \" +\n                    \"LOWER(sp.rollNumber) LIKE :search OR \" +\n                    \"LOWER(s.title) LIKE :search OR \" +\n                    \"LOWER(c.code) LIKE :search OR \" +\n                    \"LOWER(sub.name) LIKE :search OR \" +\n                    \"LOWER(sub.code) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", whereClauses);\n    }\n\n    @Override\n    public AttendanceRecordDTO findByIdWithDetails(Long id) {\n        String jpql = \"SELECT NEW com.fuacs.backend.dto.response.AttendanceRecordDTO(\" +\n                \"ar.id, \" +\n                \"u.id, u.fullName, sp.rollNumber, u.email, m.name, \" +\n                \"s.id, s.title, s.startTime, s.endTime, s.slotCategory, \" +\n                \"r.id, r.name, r.location, \" +\n                \"su.id, su.fullName, \" +\n                \"c.id, c.code, sub.id, sub.name, sub.code, sem.id, sem.name, sem.code, \" +\n                \"ar.status, ar.method, ar.recordedAt, ar.needsReview, ar.createdAt, ar.updatedAt) \" +\n                \"FROM AttendanceRecord ar \" +\n                \"JOIN ar.student u \" +\n                \"LEFT JOIN StudentProfile sp ON sp.user.id = u.id \" +\n                \"LEFT JOIN sp.major m \" +\n                \"JOIN ar.slot s \" +\n                \"LEFT JOIN s.room r \" +\n                \"LEFT JOIN s.staff su \" +\n                \"LEFT JOIN s.academicClass c \" +\n                \"LEFT JOIN c.subject sub \" +\n                \"LEFT JOIN c.semester sem \" +\n                \"WHERE ar.id = :id\";\n\n        TypedQuery<AttendanceRecordDTO> query = em.createQuery(jpql, AttendanceRecordDTO.class);\n        query.setParameter(\"id\", id);\n\n        List<AttendanceRecordDTO> results = query.getResultList();\n        return results.isEmpty() ? null : results.get(0);\n    }\n\n    @Override\n    public List<com.fuacs.backend.entity.AttendanceRecord> findByClassAndSemesterWithSlotFiltering(Short classId, Short semesterId) {\n        String jpql = \"\"\"\n                SELECT ar\n                FROM AttendanceRecord ar\n                JOIN ar.slot s\n                WHERE s.academicClass.id = :classId\n                  AND s.academicClass.semester.id = :semesterId\n                  AND s.slotCategory IN (com.fuacs.backend.constant.enums.SlotCategory.LECTURE, \n                                        com.fuacs.backend.constant.enums.SlotCategory.LECTURE_WITH_PT)\n                ORDER BY s.startTime ASC, ar.student.id ASC\n                \"\"\";\n\n        TypedQuery<com.fuacs.backend.entity.AttendanceRecord> query = em.createQuery(jpql, com.fuacs.backend.entity.AttendanceRecord.class);\n        query.setParameter(\"classId\", classId);\n        query.setParameter(\"semesterId\", semesterId);\n        return query.getResultList();\n    }\n\n    @Override\n    public Long countAttendanceByStudentAndClass(Integer studentUserId, Short classId, Short semesterId) {\n        String jpql = \"\"\"\n                SELECT COUNT(ar.id)\n                FROM AttendanceRecord ar\n                JOIN ar.slot s\n                WHERE ar.student.id = :studentUserId\n                  AND s.academicClass.id = :classId\n                  AND s.academicClass.semester.id = :semesterId\n                  AND s.slotCategory IN (com.fuacs.backend.constant.enums.SlotCategory.LECTURE, \n                                        com.fuacs.backend.constant.enums.SlotCategory.LECTURE_WITH_PT)\n                \"\"\";\n\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"studentUserId\", studentUserId);\n        query.setParameter(\"classId\", classId);\n        query.setParameter(\"semesterId\", semesterId);\n        return query.getSingleResult();\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\CameraRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/CameraRepositoryImpl.java",
      "filename": "CameraRepositoryImpl.java",
      "size_bytes": 5131,
      "lines": 122,
      "last_modified": "2025-11-28T08:56:33.014549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.CameraSearchBaseRequest;\nimport com.fuacs.backend.dto.response.CameraDTO;\nimport com.fuacs.backend.repository.custom.CustomCameraRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Implementation của CustomCameraRepository sử dụng EntityManager và JPQL.\n * Xử lý tìm kiếm camera với filters động: search keyword, isActive, roomId, và sorting.\n *\n * @see CustomCameraRepository\n */\n@Repository\npublic class CameraRepositoryImpl implements CustomCameraRepository {\n    /** Mapping từ field name trong request sang JPQL field path cho sorting */\n    private static final Map<String, String> SORTABLE_FIELDS = Map.of(\n            \"name\", \"c.name\",\n            \"location\", \"r.location\",\n            \"rtspUrl\", \"c.rtspUrl\");\n\n    @PersistenceContext\n    private EntityManager em;\n\n    /**\n     * Tìm kiếm camera với filters và pagination, trả về CameraDTO kèm RoomDTO.\n     */\n    @Override\n    public List<CameraDTO> search(CameraSearchBaseRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n\n        // Build WHERE clause động từ filters\n        String whereClause = buildWhereClause(parameters, request);\n\n        // JPQL SELECT với constructor expression để map trực tiếp sang DTO\n        // JOIN với Room để lấy thông tin phòng, CAST NULL cho các field không cần thiết\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT NEW com.fuacs.backend.dto.response.CameraDTO(c.id, c.name, c.rtspUrl, c.isActive, c.createdAt, c.updatedAt, \" +\n                        \"NEW com.fuacs.backend.dto.response.RoomDTO(r.id, r.name, r.location, r.isActive, r.createdAt, r.updatedAt, \" +\n                        \"CAST(NULL AS long), CAST(NULL AS long))) \" +\n                        \"FROM Camera c JOIN c.room r\"\n        );\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        // Apply sorting theo sortBy field (default: c.id ASC)\n        String sortBy = request.getSortBy();\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            String sortField = SORTABLE_FIELDS.get(sortBy);\n            jpql.append(\" ORDER BY \").append(sortField).append(\" \").append(request.getSort());\n        } else {\n            jpql.append(\" ORDER BY c.id ASC\");\n        }\n\n        // Execute query với pagination\n        TypedQuery<CameraDTO> query = em.createQuery(jpql.toString(), CameraDTO.class);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    /**\n     * Đếm tổng số camera thỏa mãn filters (dùng cho tính total pages).\n     */\n    @Override\n    public Long count(CameraSearchBaseRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n\n        // Build WHERE clause động (giống search method)\n        String whereClause = buildWhereClause(parameters, request);\n\n        // COUNT query, JOIN với Room để filter theo roomId nếu có\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(c.id) FROM Camera c JOIN c.room r\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    /**\n     * Build WHERE clause động từ các filters trong request.\n     * Hỗ trợ: isActive, roomId, và search keyword (name/rtspUrl).\n     */\n    private String buildWhereClause(Map<String, Object> parameters, CameraSearchBaseRequest request) {\n        List<String> whereClauses = new ArrayList<>();\n\n        // Filter theo trạng thái active/inactive\n        if (request.getActive() != null) {\n            whereClauses.add(\"c.isActive = :isActive\");\n            parameters.put(\"isActive\", request.getActive());\n        }\n\n        // Filter theo phòng cụ thể\n        if (request.getRoomId() != null) {\n            whereClauses.add(\"r.id = :roomId\");\n            parameters.put(\"roomId\", request.getRoomId());\n        }\n\n        // Search keyword trên name hoặc rtspUrl (case-insensitive LIKE)\n        String search = request.getSearch();\n        if (StringUtils.hasText(search)) {\n            whereClauses.add(\"(LOWER(c.name) LIKE :search OR LOWER(c.rtspUrl) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", whereClauses);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\ClassRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/ClassRepositoryImpl.java",
      "filename": "ClassRepositoryImpl.java",
      "size_bytes": 21773,
      "lines": 494,
      "last_modified": "2025-11-28T08:56:33.015549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.ClassSearchRequest;\nimport com.fuacs.backend.dto.response.ClassDTO;\nimport com.fuacs.backend.dto.response.MyClassDTO;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.dto.response.SubjectDTO;\nimport com.fuacs.backend.dto.response.StaffDTO;\nimport com.fuacs.backend.repository.custom.CustomClassRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.util.StringUtils;\n\nimport org.springframework.stereotype.Repository;\n\nimport java.time.ZoneId;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Repository\npublic class ClassRepositoryImpl implements CustomClassRepository {\n\n    // TODO: thiếu subject name/code\n    private static final Map<String, String> SORTABLE_FIELDS = Map.ofEntries(\n            Map.entry(\"id\", \"c.id\"),\n            Map.entry(\"code\", \"c.code\"));\n\n    @PersistenceContext\n    private EntityManager em;\n\n    @Override\n    public List<ClassDTO> search(ClassSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request, false);\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT NEW com.fuacs.backend.dto.response.ClassDTO(\" +\n                        \"c.id, c.code, \" +\n                        \"NEW com.fuacs.backend.dto.response.SemesterDTO(s.id, s.name, s.code, s.startDate, s.endDate, s.isActive), \"\n                        +\n                        \"NEW com.fuacs.backend.dto.response.SubjectDTO(sub.id, sub.name, sub.code, sub.isActive), \" +\n                        \"(SELECT COUNT(e.id) FROM Enrollment e WHERE e.academicClass.id = c.id), \" +\n                        \"(SELECT COUNT(e.id) FROM Enrollment e WHERE e.academicClass.id = c.id AND e.isEnrolled = true), \"\n                        +\n                        \"(SELECT COUNT(sl.id) FROM Slot sl WHERE sl.academicClass.id = c.id), \" +\n                        \"(SELECT COUNT(sl.id) FROM Slot sl WHERE sl.academicClass.id = c.id AND sl.isActive = true), \" +\n                        \"c.isActive, c.createdAt, c.updatedAt) \" +\n                        \"FROM AcademicClass c JOIN c.semester s JOIN c.subject sub\");\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        String sortBy = request.getSortBy();\n        String sortDirection = request.getSort();\n\n        String sortColumn;\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            sortColumn = SORTABLE_FIELDS.get(sortBy);\n        } else {\n            sortColumn = \"c.id\";\n        }\n        jpql.append(\" ORDER BY \").append(sortColumn).append(\" \").append(sortDirection);\n\n        TypedQuery<ClassDTO> query = em.createQuery(jpql.toString(), ClassDTO.class);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public Long count(ClassSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request, false);\n\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(c.id) FROM AcademicClass c\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public List<ClassDTO> searchClassBySemesterId(Short semesterId, ClassSearchRequest request) {\n        request.setSemesterId(semesterId);\n        return search(request);\n    }\n\n    @Override\n    public Long countBySemesterId(Short semesterId, ClassSearchRequest request) {\n        request.setSemesterId(semesterId);\n        return count(request);\n    }\n\n    private List<ClassDTO> searchBySemesterId(ClassSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request, false);\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT NEW com.fuacs.backend.dto.response.ClassDTO(\" +\n                        \"c.id, c.code, \" +\n                        \"c.isActive, c.createdAt, c.updatedAt) \" +\n                        \"FROM AcademicClass c JOIN c.semester s JOIN c.subject sub\");\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        String sortBy = request.getSortBy();\n        String sortDirection = request.getSort();\n\n        String sortColumn;\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            sortColumn = SORTABLE_FIELDS.get(sortBy);\n        } else {\n            sortColumn = \"c.id\";\n        }\n        jpql.append(\" ORDER BY \").append(sortColumn).append(\" \").append(sortDirection);\n\n        TypedQuery<ClassDTO> query = em.createQuery(jpql.toString(), ClassDTO.class);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public List<ClassDTO> searchClassBySubjectId(Short subjectId, ClassSearchRequest request) {\n        request.setSubjectId(subjectId);\n        return search(request);\n    }\n\n    @Override\n    public Long countBySubjectId(Short subjectId, ClassSearchRequest request) {\n        request.setSubjectId(subjectId);\n        return count(request);\n    }\n\n    @Override\n    public List<ClassDTO> searchClassesByStudentId(Integer studentId, ClassSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request, true);\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT NEW com.fuacs.backend.dto.response.ClassDTO(\" +\n                        \"c.id, c.code, \" +\n                        \"NEW com.fuacs.backend.dto.response.SubjectDTO(sub.id, sub.name, sub.code, sub.isActive), \" +\n                        \"NEW com.fuacs.backend.dto.response.SemesterDTO(s.id, s.name, s.code, s.startDate, s.endDate, s.isActive), \" +\n                        \"e.isEnrolled, \" +\n                        \"c.isActive, \" +\n                        \"c.createdAt, \" +\n                        \"c.updatedAt) \" +\n                        \"FROM AcademicClass c \" +\n                        \"JOIN c.semester s \" +\n                        \"JOIN c.subject sub \" +\n                        \"JOIN Enrollment e ON e.academicClass.id = c.id \" +\n                        \"JOIN e.student stu \" +\n                        \"WHERE stu.id = :studentId\");\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" AND \").append(whereClause);\n        }\n\n        String sortBy = request.getSortBy();\n        String sortDirection = request.getSort();\n\n        String sortColumn;\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            sortColumn = SORTABLE_FIELDS.get(sortBy);\n        } else {\n            sortColumn = \"c.id\";\n        }\n        jpql.append(\" ORDER BY \").append(sortColumn).append(\" \").append(sortDirection);\n\n        TypedQuery<ClassDTO> query = em.createQuery(jpql.toString(), ClassDTO.class);\n        query.setParameter(\"studentId\", studentId);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public Long countClassesByStudentId(Integer studentId, ClassSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request, true);\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT COUNT(c.id) \" +\n                        \"FROM AcademicClass c \" +\n                        \"JOIN Enrollment e ON e.academicClass.id = c.id \" +\n                        \"JOIN e.student stu \" +\n                        \"WHERE stu.id = :studentId\");\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" AND \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        query.setParameter(\"studentId\", studentId);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public List<ClassDTO> searchClassesByStaffId(Integer staffId, ClassSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request, false);\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT DISTINCT NEW com.fuacs.backend.dto.response.ClassDTO(\" +\n                        \"c.id, c.code, \" +\n                        \"NEW com.fuacs.backend.dto.response.SubjectDTO(sub.id, sub.name, sub.code, sub.isActive), \" +\n                        \"NEW com.fuacs.backend.dto.response.SemesterDTO(s.id, s.name, s.code, s.startDate, s.endDate, s.isActive), \" +\n                        \"CASE WHEN EXISTS (\" +\n                        \"   SELECT 1 FROM Slot sl2 WHERE sl2.academicClass.id = c.id AND sl2.staff.id = :staffId AND sl2.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\"\n                        +\n                        \") THEN 'SUPERVISOR' ELSE 'LECTURER' END, \" +\n                        \"c.isActive, \" +\n                        \"c.createdAt, \" +\n                        \"c.updatedAt) \" +\n                        \"FROM AcademicClass c \" +\n                        \"JOIN c.semester s \" +\n                        \"JOIN c.subject sub \" +\n                        \"JOIN Slot sl ON sl.academicClass.id = c.id \" +\n                        \"JOIN sl.staff st \" +\n                        \"WHERE st.id = :staffId\");\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" AND \").append(whereClause);\n        }\n\n        String sortBy = request.getSortBy();\n        String sortDirection = request.getSort();\n\n        String sortColumn;\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            sortColumn = SORTABLE_FIELDS.get(sortBy);\n        } else {\n            sortColumn = \"c.id\";\n        }\n        jpql.append(\" ORDER BY \").append(sortColumn).append(\" \").append(sortDirection);\n\n        TypedQuery<ClassDTO> query = em.createQuery(jpql.toString(), ClassDTO.class);\n        query.setParameter(\"staffId\", staffId);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public Long countClassesByStaffId(Integer staffId, ClassSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request, false);\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT COUNT(DISTINCT c.id) \" +\n                        \"FROM AcademicClass c \" +\n                        \"JOIN Slot sl ON sl.academicClass.id = c.id \" +\n                        \"JOIN sl.staff st \" +\n                        \"WHERE st.id = :staffId\");\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" AND \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        query.setParameter(\"staffId\", staffId);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    private String buildWhereClause(Map<String, Object> parameters, ClassSearchRequest request,\n            boolean includeEnrollment) {\n        List<String> whereClauses = new ArrayList<>();\n        if (request.getActive() != null) {\n            whereClauses.add(\"c.isActive = :isActive\");\n            parameters.put(\"isActive\", request.getActive());\n        }\n        if (request.getSemesterId() != null) {\n            whereClauses.add(\"c.semester.id = :semesterId\");\n            parameters.put(\"semesterId\", request.getSemesterId());\n        }\n        if (request.getSubjectId() != null) {\n            whereClauses.add(\"c.subject.id = :subjectId\");\n            parameters.put(\"subjectId\", request.getSubjectId());\n        }\n        if (StringUtils.hasText(request.getSubjectName())) {\n            whereClauses.add(\"c.subject.name = :subjectName\");\n            parameters.put(\"subjectName\", request.getSubjectName());\n        }\n        if (StringUtils.hasText(request.getSubjectCode())) {\n            whereClauses.add(\"c.subject.code = :subjectCode\");\n            parameters.put(\"subjectCode\", request.getSubjectCode());\n        }\n        String search = request.getSearch();\n        if (StringUtils.hasText(search)) {\n            whereClauses.add(\"(LOWER(c.code) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n\n        if (includeEnrollment && request.getEnrollmentStatus() != null) {\n            whereClauses.add(\"e.isEnrolled = :enrollmentStatus\");\n            parameters.put(\"enrollmentStatus\", request.getEnrollmentStatus());\n        }\n\n        return String.join(\" AND \", whereClauses);\n    }\n\n    @Override\n    public java.util.List<MyClassDTO> findClassesWithStatsByLecturerAndSemester(Integer lecturerId, Short semesterId) {\n        String jpql = \"\"\"\n            SELECT \n                c.id as classId,\n                c.code as classCode,\n                sub.id as subjectId,\n                sub.code as subjectCode,\n                sub.name as subjectName,\n                sem.id as semesterId,\n                sem.name as semesterName,\n                sem.code as semesterCode,\n                COUNT(DISTINCT s.id) as totalSlots,\n                COUNT(DISTINCT (CASE WHEN s.endTime < CURRENT_TIMESTAMP THEN s.id END)) as finalizedSlots,\n                COUNT(DISTINCT e.id) as totalStudents,\n                COUNT(ar.id) as totalAttendanceRecords,\n                SUM(CASE WHEN ar.status = 'present' THEN 1 ELSE 0 END) as presentCount\n            FROM AcademicClass c\n            JOIN c.subject sub\n            JOIN c.semester sem\n            JOIN Slot s ON s.academicClass.id = c.id\n            LEFT JOIN Enrollment e ON e.academicClass.id = c.id AND e.isEnrolled = true\n            LEFT JOIN AttendanceRecord ar ON ar.slot.id = s.id\n            WHERE s.staff.id = :lecturerId\n              AND c.semester.id = :semesterId\n              AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n            GROUP BY c.id, c.code, sub.id, sub.code, sub.name, sem.id, sem.name, sem.code\n            ORDER BY c.code ASC\n        \"\"\";\n\n        var query = em.createQuery(jpql, jakarta.persistence.Tuple.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"semesterId\", semesterId);\n        var tuples = query.getResultList();\n        java.util.List<MyClassDTO> results = new java.util.ArrayList<>();\n        for (var t : tuples) {\n            MyClassDTO dto = new MyClassDTO();\n            dto.setId(t.get(\"classId\", Short.class));\n            dto.setCode(t.get(\"classCode\", String.class));\n\n            SubjectDTO subject = new SubjectDTO(\n                    t.get(\"subjectId\", Short.class),\n                    t.get(\"subjectName\", String.class),\n                    t.get(\"subjectCode\", String.class)\n            );\n            dto.setSubject(subject);\n\n            // Note: This method uses Tuple and doesn't fetch semester dates from query\n            // If semester dates are needed here, the JPQL query must be updated to select them\n            SemesterDTO semester = new SemesterDTO(\n                    t.get(\"semesterId\", Short.class),\n                    t.get(\"semesterName\", String.class),\n                    t.get(\"semesterCode\", String.class)\n            );\n            dto.setSemester(semester);\n\n            long totalSlots = t.get(\"totalSlots\", Long.class);\n            long totalStudents = t.get(\"totalStudents\", Long.class) != null ? t.get(\"totalStudents\", Long.class) : 0L;\n\n            MyClassDTO.ClassStatsDTO stats = new MyClassDTO.ClassStatsDTO(\n                    (int) totalSlots,\n                    (int) totalStudents\n            );\n            dto.setStats(stats);\n            results.add(dto);\n        }\n        return results;\n    }\n\n    @Override\n    public java.util.List<MyClassDTO> findClassesWithStatsByLecturer(Integer lecturerId) {\n        String jpql = \"\"\"\n            SELECT\n                c.id as classId,\n                c.code as classCode,\n                sub.id as subjectId,\n                sub.code as subjectCode,\n                sub.name as subjectName,\n                sem.id as semesterId,\n                sem.name as semesterName,\n                sem.code as semesterCode,\n                sem.startDate as semesterStartDate,\n                COUNT(DISTINCT s.id) as totalSlots,\n                COUNT(DISTINCT (CASE WHEN s.endTime < CURRENT_TIMESTAMP THEN s.id END)) as finalizedSlots,\n                COUNT(DISTINCT e.id) as totalStudents,\n                COUNT(ar.id) as totalAttendanceRecords,\n                SUM(CASE WHEN ar.status = 'present' THEN 1 ELSE 0 END) as presentCount\n            FROM AcademicClass c\n            JOIN c.subject sub\n            JOIN c.semester sem\n            JOIN Slot s ON s.academicClass.id = c.id\n            LEFT JOIN Enrollment e ON e.academicClass.id = c.id AND e.isEnrolled = true\n            LEFT JOIN AttendanceRecord ar ON ar.slot.id = s.id\n            WHERE s.staff.id = :lecturerId\n              AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n            GROUP BY c.id, c.code, sub.id, sub.code, sub.name, sem.id, sem.name, sem.code, sem.startDate\n            ORDER BY sem.startDate DESC, c.code ASC\n        \"\"\";\n\n        var query = em.createQuery(jpql, jakarta.persistence.Tuple.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        var tuples = query.getResultList();\n        java.util.List<MyClassDTO> results = new java.util.ArrayList<>();\n        for (var t : tuples) {\n            MyClassDTO dto = new MyClassDTO();\n            dto.setId(t.get(\"classId\", Short.class));\n            dto.setCode(t.get(\"classCode\", String.class));\n\n            SubjectDTO subject = new SubjectDTO(\n                    t.get(\"subjectId\", Short.class),\n                    t.get(\"subjectName\", String.class),\n                    t.get(\"subjectCode\", String.class)\n            );\n            dto.setSubject(subject);\n\n            SemesterDTO semester = new SemesterDTO(\n                    t.get(\"semesterId\", Short.class),\n                    t.get(\"semesterName\", String.class),\n                    t.get(\"semesterCode\", String.class)\n            );\n            dto.setSemester(semester);\n\n            long totalSlots = t.get(\"totalSlots\", Long.class);\n            long totalStudents = t.get(\"totalStudents\", Long.class) != null ? t.get(\"totalStudents\", Long.class) : 0L;\n\n            MyClassDTO.ClassStatsDTO stats = new MyClassDTO.ClassStatsDTO(\n                    (int) totalSlots,\n                    (int) totalStudents\n            );\n            dto.setStats(stats);\n            results.add(dto);\n        }\n        return results;\n    }\n\n    @Override\n    public java.util.List<com.fuacs.backend.dto.response.TodaySlotDTO> findUpcomingSlotsForClass(Short classId, int limit) {\n        String jpql = \"\"\"\n                SELECT s\n                FROM Slot s\n                LEFT JOIN FETCH s.room r\n                WHERE s.academicClass.id = :classId\n                  AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND s.endTime > CURRENT_TIMESTAMP\n                ORDER BY s.startTime ASC\n            \"\"\";\n\n        jakarta.persistence.TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"classId\", classId);\n        query.setMaxResults(limit);\n\n        java.util.List<com.fuacs.backend.entity.Slot> slots = query.getResultList();\n\n        // Map to TodaySlotDTO\n        java.util.List<com.fuacs.backend.dto.response.TodaySlotDTO> result = new java.util.ArrayList<>();\n        for (com.fuacs.backend.entity.Slot s : slots) {\n            com.fuacs.backend.dto.response.TodaySlotDTO dto = new com.fuacs.backend.dto.response.TodaySlotDTO();\n            dto.setId(s.getId());\n            dto.setTitle(s.getTitle());\n            dto.setStartTime(s.getStartTime());\n            dto.setEndTime(s.getEndTime());\n\n            if (s.getRoom() != null) {\n                dto.setRoom(new com.fuacs.backend.dto.response.RoomDTO(\n                    s.getRoom().getId(),\n                    s.getRoom().getName(),\n                    s.getRoom().getLocation()\n                ));\n            }\n\n            result.add(dto);\n        }\n\n        return result;\n    }\n\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\EnrollmentRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/EnrollmentRepositoryImpl.java",
      "filename": "EnrollmentRepositoryImpl.java",
      "size_bytes": 27165,
      "lines": 645,
      "last_modified": "2025-11-28T08:56:33.015549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.EnrollmentSearchRequest;\nimport com.fuacs.backend.dto.request.StudentSemesterSearchRequest;\nimport com.fuacs.backend.dto.response.EnrollmentDTO;\nimport com.fuacs.backend.dto.response.MajorDTO;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.dto.response.StudentProfileDTO;\nimport com.fuacs.backend.dto.response.StudentSemesterDTO;\nimport com.fuacs.backend.dto.response.EnrolledSubjectDTO;\nimport com.fuacs.backend.entity.EnrollmentId;\nimport com.fuacs.backend.repository.custom.CustomEnrollmentRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.Tuple;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n@Repository\npublic class EnrollmentRepositoryImpl implements CustomEnrollmentRepository {\n    private static final Map<String, String> SORTABLE_FIELDS = Map.of(\n            \"createdAt\", \"e.createdAt\",\n            \"updatedAt\", \"e.updatedAt\",\n            \"fullName\", \"u.fullName\",\n            \"rollNumber\", \"sp.rollNumber\",\n            \"email\", \"u.email\");\n\n    private static final Map<String, String> ROSTER_SORTABLE_FIELDS = Map.of(\n            \"fullName\", \"u.fullName\",\n            \"rollNumber\", \"sp.rollNumber\",\n            \"createdAt\", \"e.createdAt\",\n            \"updatedAt\", \"e.updatedAt\",\n            \"email\", \"u.email\");\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    @Override\n    public List<EnrollmentDTO> search(EnrollmentSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        // Fixed: Use $ for nested static DTOs\n        String jpql = \"\"\"\n                SELECT NEW com.fuacs.backend.dto.response.EnrollmentDTO(\n                    e.academicClass.id,\n                    e.student.id,\n                    NEW com.fuacs.backend.dto.response.StudentProfileDTO(\n                        u.id,\n                        u.fullName,\n                        sp.rollNumber,\n                        u.email,\n                        m.name,\n                        m.code\n                    ),\n                    NEW com.fuacs.backend.dto.response.ClassDTO(\n                        c.id,\n                        c.code,\n                        NEW com.fuacs.backend.dto.response.SubjectDTO(\n                            s.id,\n                            s.name,\n                            s.code\n                        ),\n                        NEW com.fuacs.backend.dto.response.SemesterDTO(\n                            sem.id,\n                            sem.name,\n                            sem.code\n                        )\n                    ),\n                    e.isEnrolled,\n                    e.createdAt,\n                    e.updatedAt\n                )\n                FROM Enrollment e\n                JOIN e.student u\n                LEFT JOIN StudentProfile sp ON sp.user.id = u.id\n                LEFT JOIN sp.major m\n                JOIN e.academicClass c\n                JOIN c.subject s\n                JOIN c.semester sem\n                \"\"\" +\n                (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause + \" \") +\n                buildOrderBy(request.getSortBy(), request.getSort());\n\n        jakarta.persistence.TypedQuery<EnrollmentDTO> query = entityManager.createQuery(jpql, EnrollmentDTO.class);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public Long count(EnrollmentSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(e) FROM Enrollment e\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        jakarta.persistence.TypedQuery<Long> query = entityManager.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public EnrollmentDTO findByEnrollmentId(EnrollmentId id) {\n        if (id == null || id.getClassId() == null || id.getStudentUserId() == null) {\n            return null;\n        }\n\n        String jpql = \"\"\"\n                SELECT NEW com.fuacs.backend.dto.response.EnrollmentDTO(\n                    e.academicClass.id,\n                    e.student.id,\n                    NEW com.fuacs.backend.dto.response.StudentProfileDTO(\n                        u.id,\n                        u.fullName,\n                        sp.rollNumber,\n                        u.email,\n                        m.name,\n                        m.code\n                    ),\n                    NEW com.fuacs.backend.dto.response.ClassDTO(\n                        c.id,\n                        c.code,\n                        NEW com.fuacs.backend.dto.response.SubjectDTO(\n                            s.id,\n                            s.name,\n                            s.code\n                        ),\n                        NEW com.fuacs.backend.dto.response.SemesterDTO(\n                            sem.id,\n                            sem.name,\n                            sem.code\n                        )\n                    ),\n                    e.isEnrolled,\n                    e.createdAt,\n                    e.updatedAt\n                )\n                FROM Enrollment e\n                JOIN e.student u\n                LEFT JOIN StudentProfile sp ON sp.user.id = u.id\n                LEFT JOIN sp.major m\n                JOIN e.academicClass c\n                JOIN c.subject s\n                JOIN c.semester sem\n                WHERE e.id.classId = :classId AND e.id.studentUserId = :studentUserId\n                \"\"\";\n\n        jakarta.persistence.TypedQuery<EnrollmentDTO> query = entityManager.createQuery(jpql, EnrollmentDTO.class);\n        query.setParameter(\"classId\", id.getClassId());\n        query.setParameter(\"studentUserId\", id.getStudentUserId());\n\n        List<EnrollmentDTO> results = query.getResultList();\n        return results.isEmpty() ? null : results.get(0);\n    }\n\n    @Override\n    public List<StudentProfileDTO> findByClassId(Short classId,\n            EnrollmentSearchRequest request) {\n        if (classId == null) {\n            return new ArrayList<>();\n        }\n\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildRosterWhereClause(parameters, classId, request.getEnrolled(), request.getSearch());\n\n        String jpql = \"\"\"\n                SELECT NEW com.fuacs.backend.dto.response.StudentProfileDTO(\n                    u.id,\n                    u.fullName,\n                    sp.rollNumber,\n                    u.email,\n                    m.name,\n                    m.code,\n                    e.isEnrolled,\n                    e.createdAt,\n                    e.updatedAt\n                )\n                FROM Enrollment e\n                JOIN e.student u\n                LEFT JOIN StudentProfile sp ON sp.user.id = u.id\n                LEFT JOIN sp.major m\n                \"\"\" +\n                (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause + \" \") +\n                buildRosterOrderBy(request.getSortBy(), request.getSort());\n\n        jakarta.persistence.TypedQuery<StudentProfileDTO> query = entityManager.createQuery(jpql,\n                StudentProfileDTO.class);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public Long countByClassId(Short classId, EnrollmentSearchRequest request) {\n        if (classId == null) {\n            return 0L;\n        }\n\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildRosterWhereClause(parameters, classId, request.getEnrolled(), request.getSearch());\n\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(e) FROM Enrollment e\");\n        jpql.append(\" JOIN e.student u\");\n        jpql.append(\" LEFT JOIN StudentProfile sp ON sp.user.id = u.id\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        jakarta.persistence.TypedQuery<Long> query = entityManager.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public Long countByClassId(Short classId, Boolean isEnrolled, String search) {\n        if (classId == null) {\n            return 0L;\n        }\n\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildRosterWhereClause(parameters, classId, isEnrolled, search);\n\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(e) FROM Enrollment e\");\n        jpql.append(\" JOIN e.student u\");\n        jpql.append(\" LEFT JOIN StudentProfile sp ON sp.user.id = u.id\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        jakarta.persistence.TypedQuery<Long> query = entityManager.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public Long countEnrolledByClassId(Short classId) {\n        if (classId == null) {\n            return 0L;\n        }\n\n        String jpql = \"SELECT COUNT(e) FROM Enrollment e WHERE e.academicClass.id = :classId AND e.isEnrolled = true\";\n        jakarta.persistence.TypedQuery<Long> query = entityManager.createQuery(jpql, Long.class);\n        query.setParameter(\"classId\", classId);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public Long countWithdrawnByClassId(Short classId) {\n        if (classId == null) {\n            return 0L;\n        }\n\n        String jpql = \"SELECT COUNT(e) FROM Enrollment e WHERE e.academicClass.id = :classId AND e.isEnrolled = false\";\n        jakarta.persistence.TypedQuery<Long> query = entityManager.createQuery(jpql, Long.class);\n        query.setParameter(\"classId\", classId);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public boolean existsByEnrollmentId(EnrollmentId id) {\n        if (id == null || id.getClassId() == null || id.getStudentUserId() == null) {\n            return false;\n        }\n\n        String jpql = \"SELECT COUNT(e) FROM Enrollment e WHERE e.id.classId = :classId AND e.id.studentUserId = :studentUserId\";\n        jakarta.persistence.TypedQuery<Long> query = entityManager.createQuery(jpql, Long.class);\n        query.setParameter(\"classId\", id.getClassId());\n        query.setParameter(\"studentUserId\", id.getStudentUserId());\n\n        return query.getSingleResult() > 0;\n    }\n\n    @Override\n    public boolean existsByIdAndIsEnrolled(EnrollmentId id, boolean isEnrolled) {\n        if (id == null || id.getClassId() == null || id.getStudentUserId() == null) {\n            return false;\n        }\n\n        String jpql = \"SELECT COUNT(e) FROM Enrollment e WHERE e.id.classId = :classId AND e.id.studentUserId = :studentUserId AND e.isEnrolled = :isEnrolled\";\n        jakarta.persistence.TypedQuery<Long> query = entityManager.createQuery(jpql, Long.class);\n        query.setParameter(\"classId\", id.getClassId());\n        query.setParameter(\"studentUserId\", id.getStudentUserId());\n        query.setParameter(\"isEnrolled\", isEnrolled);\n\n        return query.getSingleResult() > 0;\n    }\n\n    @Override\n    public boolean existsByStudentIdAndClassId(Integer studentUserId, Short classId) {\n        if (studentUserId == null || classId == null) {\n            return false;\n        }\n\n        String jpql = \"SELECT COUNT(e) FROM Enrollment e WHERE e.student.id = :studentUserId AND e.academicClass.id = :classId\";\n        jakarta.persistence.TypedQuery<Long> query = entityManager.createQuery(jpql, Long.class);\n        query.setParameter(\"studentUserId\", studentUserId);\n        query.setParameter(\"classId\", classId);\n\n        return query.getSingleResult() > 0;\n    }\n\n    private String buildWhereClause(Map<String, Object> parameters, EnrollmentSearchRequest request) {\n        List<String> whereClauses = new ArrayList<>();\n\n        if (request.getClassId() != null) {\n            whereClauses.add(\"e.academicClass.id = :classId\");\n            parameters.put(\"classId\", request.getClassId());\n        }\n\n        if (request.getStudentUserId() != null) {\n            whereClauses.add(\"e.student.id = :studentUserId\");\n            parameters.put(\"studentUserId\", request.getStudentUserId());\n        }\n\n        if (request.getSemesterId() != null) {\n            whereClauses.add(\"e.academicClass.semester.id = :semesterId\");\n            parameters.put(\"semesterId\", request.getSemesterId());\n        }\n\n        if (request.getEnrolled() != null) {\n            whereClauses.add(\"e.isEnrolled = :isEnrolled\");\n            parameters.put(\"isEnrolled\", request.getEnrolled());\n        }\n\n        String search = request.getSearch();\n        if (StringUtils.hasText(search)) {\n            whereClauses.add(\n                    \"(LOWER(u.fullName) LIKE :search OR LOWER(COALESCE(sp.rollNumber, '')) LIKE :search OR LOWER(u.email) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", whereClauses);\n    }\n\n    private String buildRosterWhereClause(Map<String, Object> parameters, Short classId, Boolean isEnrolled,\n            String search) {\n        List<String> whereClauses = new ArrayList<>();\n\n        whereClauses.add(\"e.academicClass.id = :classId\");\n        parameters.put(\"classId\", classId);\n\n        if (isEnrolled != null) {\n            whereClauses.add(\"e.isEnrolled = :isEnrolled\");\n            parameters.put(\"isEnrolled\", isEnrolled);\n        }\n\n        if (StringUtils.hasText(search)) {\n            whereClauses.add(\n                    \"(LOWER(u.fullName) LIKE :search OR LOWER(COALESCE(sp.rollNumber, '')) LIKE :search OR LOWER(u.email) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", whereClauses);\n    }\n\n    private String buildOrderBy(String sortBy, String sort) {\n        String direction = (sort == null || sort.isBlank()) ? \"ASC\" : sort;\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            return \"ORDER BY \" + SORTABLE_FIELDS.get(sortBy) + \" \" + direction;\n        }\n        return \"ORDER BY e.createdAt \" + direction;\n    }\n\n    private String buildRosterOrderBy(String sortBy, String sort) {\n        String direction = (sort == null || sort.isBlank()) ? \"ASC\" : sort;\n        if (StringUtils.hasText(sortBy) && ROSTER_SORTABLE_FIELDS.containsKey(sortBy)) {\n            return \"ORDER BY \" + ROSTER_SORTABLE_FIELDS.get(sortBy) + \" \" + direction;\n        }\n        // Default sort for roster is by full name\n        return \"ORDER BY u.fullName \" + direction;\n    }\n\n    @Override\n    public List<StudentSemesterDTO> searchBySemesterId(Short semesterId, StudentSemesterSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClauseForSemester(parameters, semesterId, request);\n\n        String jpql = \"\"\"\n                SELECT DISTINCT\n                    u.id AS userId,\n                    u.fullName AS fullName,\n                    u.email AS email,\n                    u.username AS username,\n                    sp.rollNumber AS rollNumber,\n                    m.id AS majorId,\n                    m.name AS majorName,\n                    m.code AS majorCode,\n                    m.isActive AS majorIsActive,\n                    u.isActive AS isActive,\n                    u.createdAt AS createdAt,\n                    u.updatedAt AS updatedAt,\n                    COUNT(DISTINCT CASE WHEN e.isEnrolled = true OR e.isEnrolled = false THEN e.academicClass.id ELSE null END) AS totalEnrollments,\n                    COUNT(DISTINCT CASE WHEN e.isEnrolled = true THEN e.academicClass.id ELSE null END) AS activeEnrollments\n                FROM Enrollment e\n                JOIN e.student u\n                LEFT JOIN StudentProfile sp ON sp.user.id = u.id\n                LEFT JOIN sp.major m\n                JOIN e.academicClass c\n                JOIN c.semester sem\n                WHERE sem.id = :semesterId AND e.isEnrolled = true AND c.isActive = true AND u.isActive = true\n                \"\"\"\n                + (whereClause.isEmpty() ? \"\" : \" AND \" + whereClause) + \" \"\n                + \"\"\"\n                        GROUP BY u.id, u.fullName, u.email, u.username, sp.rollNumber, m.id, m.name, m.code, m.isActive, u.isActive, u.createdAt, u.updatedAt\n                        \"\"\"\n                + buildOrderByForSemester(request.getSortBy(), request.getSort());\n\n        var query = entityManager.createQuery(jpql, Tuple.class);\n        query.setParameter(\"semesterId\", semesterId);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n\n        List<Tuple> tuples = query.getResultList();\n        List<StudentSemesterDTO> students = tuples.stream()\n                .map(this::tupleToStudentSemesterDTO)\n                .collect(Collectors.toList());\n\n        if (students.isEmpty()) {\n            return students;\n        }\n\n        // Fetch enrolled subjects for each student\n        List<Integer> userIds = students.stream()\n                .map(StudentSemesterDTO::getUserId)\n                .filter(Objects::nonNull)\n                .distinct()\n                .collect(Collectors.toList());\n\n        if (!userIds.isEmpty()) {\n            String subjectsJpql = \"\"\"\n                        SELECT DISTINCT\n                            u.id AS userId,\n                            s.id AS subjectId,\n                            s.code AS subjectCode,\n                            s.name AS subjectName\n                        FROM Enrollment e\n                        JOIN e.student u\n                        JOIN e.academicClass c\n                        JOIN c.subject s\n                        JOIN c.semester sem\n                        WHERE sem.id = :semesterId AND e.isEnrolled = true AND c.isActive = true AND u.id IN :userIds\n                        ORDER BY s.code\n                    \"\"\";\n\n            List<Tuple> subjectTuples = entityManager.createQuery(subjectsJpql, Tuple.class)\n                    .setParameter(\"semesterId\", semesterId)\n                    .setParameter(\"userIds\", userIds)\n                    .getResultList();\n\n            Map<Integer, List<EnrolledSubjectDTO>> subjectsByUser = new HashMap<>();\n            for (Tuple t : subjectTuples) {\n                Integer userId = t.get(\"userId\", Integer.class);\n                EnrolledSubjectDTO subject = new EnrolledSubjectDTO(\n                        t.get(\"subjectId\", Short.class),\n                        t.get(\"subjectCode\", String.class),\n                        t.get(\"subjectName\", String.class));\n                subjectsByUser.computeIfAbsent(userId, k -> new ArrayList<>()).add(subject);\n            }\n\n            students.forEach(\n                    s -> s.setEnrolledSubjects(subjectsByUser.getOrDefault(s.getUserId(), Collections.emptyList())));\n        }\n\n        return students;\n    }\n\n    @Override\n    public Long countBySemesterId(Short semesterId, StudentSemesterSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClauseForSemester(parameters, semesterId, request);\n\n        String jpql = \"\"\"\n                SELECT COUNT(DISTINCT u.id) FROM Enrollment e\n                JOIN e.student u\n                JOIN e.academicClass c\n                JOIN c.semester sem\n                WHERE sem.id = :semesterId AND e.isEnrolled = true AND c.isActive = true AND u.isActive = true\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" AND \" + whereClause);\n\n        var query = entityManager.createQuery(jpql, Long.class);\n        query.setParameter(\"semesterId\", semesterId);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    private String buildWhereClauseForSemester(Map<String, Object> parameters, Short semesterId,\n            StudentSemesterSearchRequest request) {\n        List<String> whereClauses = new ArrayList<>();\n\n        if (request.getActive() != null) {\n            whereClauses.add(\"u.isActive = :isActive\");\n            parameters.put(\"isActive\", request.getActive());\n        }\n\n        if (request.getMajorId() != null) {\n            whereClauses.add(\"sp.major.id = :majorId\");\n            parameters.put(\"majorId\", request.getMajorId());\n        }\n\n        if (request.getSubjectId() != null) {\n            whereClauses.add(\"c.subject.id = :subjectId\");\n            parameters.put(\"subjectId\", request.getSubjectId());\n        }\n\n        if (StringUtils.hasText(request.getSearch())) {\n            whereClauses.add(\n                    \"(LOWER(u.fullName) LIKE :search OR LOWER(sp.rollNumber) LIKE :search OR LOWER(u.email) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + request.getSearch().toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", whereClauses);\n    }\n\n    private String buildOrderByForSemester(String sortBy, String direction) {\n        if (!StringUtils.hasText(sortBy)) {\n            sortBy = \"fullName\";\n        }\n\n        String dir = (StringUtils.hasText(direction) && direction.equalsIgnoreCase(\"ASC\")) ? \"ASC\" : \"DESC\";\n        String column = switch (sortBy) {\n            case \"rollNumber\" -> \"sp.rollNumber\";\n            case \"email\" -> \"u.email\";\n            default -> \"u.fullName\";\n        };\n        return \" ORDER BY \" + column + \" \" + dir;\n    }\n\n    private StudentSemesterDTO tupleToStudentSemesterDTO(Tuple t) {\n        StudentSemesterDTO dto = new StudentSemesterDTO();\n        dto.setUserId(t.get(\"userId\", Integer.class));\n        dto.setFullName(t.get(\"fullName\", String.class));\n        dto.setEmail(t.get(\"email\", String.class));\n        dto.setUsername(t.get(\"username\", String.class));\n        dto.setRollNumber(t.get(\"rollNumber\", String.class));\n\n        // Create nested MajorDTO\n        MajorDTO major = new MajorDTO();\n        major.setId(t.get(\"majorId\", Short.class));\n        major.setName(t.get(\"majorName\", String.class));\n        major.setCode(t.get(\"majorCode\", String.class));\n        major.setActive(t.get(\"majorIsActive\", Boolean.class));\n        dto.setMajor(major);\n\n        dto.setActive(t.get(\"isActive\", Boolean.class));\n        dto.setCreatedAt(t.get(\"createdAt\", java.time.Instant.class));\n        dto.setUpdatedAt(t.get(\"updatedAt\", java.time.Instant.class));\n\n        Long totalEnrollments = t.get(\"totalEnrollments\", Long.class);\n        Long activeEnrollments = t.get(\"activeEnrollments\", Long.class);\n\n        dto.setTotalEnrollmentsInSemester(totalEnrollments != null ? totalEnrollments.intValue() : 0);\n        dto.setActiveEnrollmentsInSemester(activeEnrollments != null ? activeEnrollments.intValue() : 0);\n        dto.setEnrolledSubjects(Collections.emptyList()); // Will be populated separately\n\n        return dto;\n    }\n\n    // Student Dashboard queries implementation\n    @Override\n    public List<com.fuacs.backend.dto.response.StudentSubjectDTO> findCurrentSemesterSubjectsByStudentId(Integer studentUserId, Short currentSemesterId) {\n        String jpql = \"\"\"\n                SELECT\n                    sub.id,\n                    sub.name,\n                    sub.code,\n                    c.code,\n                    c.id,\n                    c.semester.id,\n                    e.isEnrolled\n                FROM Enrollment e\n                JOIN e.academicClass c\n                JOIN c.subject sub\n                WHERE e.student.id = :studentUserId\n                  AND (:currentSemesterId IS NULL OR c.semester.id = :currentSemesterId)\n                  AND c.isActive = true\n                ORDER BY sub.name ASC\n                \"\"\";\n\n        TypedQuery<Object[]> query = entityManager.createQuery(jpql, Object[].class);\n        query.setParameter(\"studentUserId\", studentUserId);\n        query.setParameter(\"currentSemesterId\", currentSemesterId);\n\n        List<Object[]> results = query.getResultList();\n        List<com.fuacs.backend.dto.response.StudentSubjectDTO> subjects = new ArrayList<>();\n\n        for (Object[] row : results) {\n            com.fuacs.backend.dto.response.StudentSubjectDTO dto = new com.fuacs.backend.dto.response.StudentSubjectDTO();\n            dto.setSubjectId((Short) row[0]);\n            dto.setSubjectName((String) row[1]);\n            dto.setSubjectCode((String) row[2]);\n            dto.setClassCode((String) row[3]);\n            dto.setClassId((Short) row[4]);\n            dto.setSemesterId((Short) row[5]);\n            dto.setEnrolled((Boolean) row[6]);\n            subjects.add(dto);\n        }\n\n        return subjects;\n    }\n\n    @Override\n    public List<SemesterDTO> findDistinctSemestersByStudentId(Integer studentId) {\n        if (studentId == null) {\n            return Collections.emptyList();\n        }\n\n        String jpql = \"\"\"\n                SELECT DISTINCT NEW com.fuacs.backend.dto.response.SemesterDTO(\n                    s.id,\n                    s.name,\n                    s.code,\n                    s.startDate,\n                    s.endDate,\n                    s.isActive\n                )\n                FROM Enrollment e\n                JOIN e.academicClass c\n                JOIN c.semester s\n                WHERE e.student.id = :studentId\n                  AND e.isEnrolled = true\n                  AND s.isActive = true\n                ORDER BY s.startDate DESC\n                \"\"\";\n\n        return entityManager.createQuery(jpql, SemesterDTO.class)\n                .setParameter(\"studentId\", studentId)\n                .getResultList();\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\ExamAttendanceRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/ExamAttendanceRepositoryImpl.java",
      "filename": "ExamAttendanceRepositoryImpl.java",
      "size_bytes": 8689,
      "lines": 172,
      "last_modified": "2025-11-28T08:56:33.015549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.dto.request.ExamAttendanceSearchRequest;\nimport com.fuacs.backend.dto.response.ExamAttendanceDTO;\nimport com.fuacs.backend.dto.response.ClassDTO;\nimport com.fuacs.backend.dto.response.RoomDTO;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.dto.response.SlotDTO;\nimport com.fuacs.backend.dto.response.StaffDTO;\nimport com.fuacs.backend.dto.response.StudentProfileDTO;\nimport com.fuacs.backend.dto.response.SubjectDTO;\nimport com.fuacs.backend.repository.custom.CustomExamAttendanceRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.Tuple;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.time.LocalDate;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Repository\npublic class ExamAttendanceRepositoryImpl implements CustomExamAttendanceRepository {\n\n    private final EntityManager em;\n\n    public ExamAttendanceRepositoryImpl(EntityManager em) {\n        this.em = em;\n    }\n\n    @Override\n    public List<ExamAttendanceDTO> search(ExamAttendanceSearchRequest request) {\n        Map<String, Object> params = new HashMap<>();\n        String where = buildWhereClause(params, request);\n\n        String jpql = \"\"\"\n                SELECT\n                   ea.id AS id,\n                   u.id AS studentUserId, u.fullName AS studentFullName, u.email AS studentEmail, u.username AS studentUsername,\n                   s.id AS slotId, s.title AS slotTitle, s.description AS slotDescription,\n                   s.startTime AS startTime, s.endTime AS endTime, s.slotCategory AS slotCategory,\n                   r.id AS roomId, r.name AS roomName, r.location AS roomLocation,\n                   su.id AS staffId, su.fullName AS staffFullName,\n                   c.id AS classId, c.code AS classCode,\n                   sub.id AS subjectId, sub.name AS subjectName, sub.code AS subjectCode,\n                   essSubject.id AS examSubjectId, essSubject.name AS examSubjectName, essSubject.code AS examSubjectCode,\n                   sem.id AS semesterId, sem.name AS semesterName, sem.code AS semesterCode,\n                   ea.status AS status, ea.method AS method, ea.recordedAt AS recordedAt, ea.needsReview AS needsReview,\n                   ea.createdAt AS createdAt, ea.updatedAt AS updatedAt\n                FROM ExamAttendance ea\n                JOIN ea.student u\n                JOIN ea.slot s\n                LEFT JOIN s.room r\n                LEFT JOIN s.staff su\n                LEFT JOIN s.academicClass c\n                LEFT JOIN c.subject sub\n                LEFT JOIN c.semester sem\n                LEFT JOIN ExamSlotSubject ess ON s.slotCategory = :finalExam AND ess.slot = s\n                LEFT JOIN ess.subject essSubject\n                \"\"\" + (where.isEmpty() ? \"\" : \" WHERE \" + where) + \" ORDER BY ea.recordedAt DESC\";\n\n        TypedQuery<Tuple> q = em.createQuery(jpql, Tuple.class);\n        params.forEach(q::setParameter);\n        q.setParameter(\"finalExam\", SlotCategory.FINAL_EXAM);\n        q.setFirstResult(request.getPage() * request.getPageSize());\n        q.setMaxResults(request.getPageSize());\n        List<Tuple> tuples = q.getResultList();\n\n        List<ExamAttendanceDTO> results = new ArrayList<>();\n        for (Tuple t : tuples) {\n            // Student\n            StudentProfileDTO student = new StudentProfileDTO();\n            student.setUserId(t.get(\"studentUserId\", Integer.class));\n            student.setFullName(t.get(\"studentFullName\", String.class));\n            student.setEmail(t.get(\"studentEmail\", String.class));\n            student.setUsername(t.get(\"studentUsername\", String.class));\n\n            // Slot\n            RoomDTO room = t.get(\"roomId\") != null\n                    ? new RoomDTO(t.get(\"roomId\", Short.class), t.get(\"roomName\", String.class), t.get(\"roomLocation\", String.class))\n                    : null;\n            StaffDTO staff = t.get(\"staffId\") != null\n                    ? new StaffDTO(t.get(\"staffId\", Integer.class), t.get(\"staffFullName\", String.class))\n                    : null;\n            ClassDTO classObj = (t.get(\"classId\") != null)\n                    ? new ClassDTO(\n                        t.get(\"classId\", Short.class),\n                        t.get(\"classCode\", String.class),\n                        new SubjectDTO(t.get(\"subjectId\", Short.class), t.get(\"subjectName\", String.class), t.get(\"subjectCode\", String.class)),\n                        new SemesterDTO(t.get(\"semesterId\", Short.class), t.get(\"semesterName\", String.class), t.get(\"semesterCode\", String.class))\n                    ) : null;\n\n            SlotDTO slot = new SlotDTO(\n                    t.get(\"slotId\", Integer.class),\n                    t.get(\"slotTitle\", String.class),\n                    t.get(\"slotDescription\", String.class),\n                    t.get(\"startTime\", java.time.LocalDateTime.class),\n                    t.get(\"endTime\", java.time.LocalDateTime.class),\n                    t.get(\"slotCategory\", com.fuacs.backend.constant.enums.SlotCategory.class),\n                    null,\n                    t.get(\"createdAt\", java.time.Instant.class),\n                    t.get(\"updatedAt\", java.time.Instant.class),\n                    staff,\n                    room);\n            slot.setClassObj(classObj);\n\n            // Subject for FINAL_EXAM slots\n            SubjectDTO examSubject = null;\n            if (t.get(\"examSubjectId\") != null) {\n                examSubject = new SubjectDTO(\n                        t.get(\"examSubjectId\", Short.class),\n                        t.get(\"examSubjectName\", String.class),\n                        t.get(\"examSubjectCode\", String.class));\n            }\n\n            ExamAttendanceDTO dto = new ExamAttendanceDTO(\n                    null,\n                    t.get(\"createdAt\", java.time.Instant.class),\n                    t.get(\"updatedAt\", java.time.Instant.class),\n                    t.get(\"id\", Long.class),\n                    student,\n                    slot,\n                    examSubject,\n                    t.get(\"status\", com.fuacs.backend.constant.enums.AttendanceStatus.class),\n                    t.get(\"method\", com.fuacs.backend.constant.enums.AttendanceMethod.class),\n                    t.get(\"recordedAt\", java.time.Instant.class),\n                    null,\n                    t.get(\"needsReview\", Boolean.class)\n            );\n            results.add(dto);\n        }\n\n        return results;\n    }\n\n    @Override\n    public Long count(ExamAttendanceSearchRequest request) {\n        Map<String, Object> params = new HashMap<>();\n        String where = buildWhereClause(params, request);\n\n        String jpql = \"SELECT COUNT(DISTINCT ea.id) FROM ExamAttendance ea JOIN ea.slot s LEFT JOIN s.academicClass c LEFT JOIN c.semester sem \"\n                + (where.isEmpty() ? \"\" : \" WHERE \" + where);\n        TypedQuery<Long> q = em.createQuery(jpql, Long.class);\n        params.forEach(q::setParameter);\n        return q.getSingleResult();\n    }\n\n    private String buildWhereClause(Map<String, Object> params, ExamAttendanceSearchRequest r) {\n        List<String> where = new ArrayList<>();\n\n        if (r.getSlotId() != null) { where.add(\"s.id = :slotId\"); params.put(\"slotId\", r.getSlotId()); }\n        if (r.getStudentUserId() != null) { where.add(\"ea.student.id = :studentUserId\"); params.put(\"studentUserId\", r.getStudentUserId()); }\n        if (r.getClassId() != null) { where.add(\"c.id = :classId\"); params.put(\"classId\", r.getClassId()); }\n        if (r.getSemesterId() != null) { where.add(\"sem.id = :semesterId\"); params.put(\"semesterId\", r.getSemesterId()); }\n        if (r.getStatus() != null) { where.add(\"ea.status = :status\"); params.put(\"status\", r.getStatus()); }\n        if (r.getMethod() != null) { where.add(\"ea.method = :method\"); params.put(\"method\", r.getMethod()); }\n\n        if (StringUtils.hasText(r.getStartDate())) {\n            where.add(\"s.startTime >= :startDate\");\n            params.put(\"startDate\", java.time.LocalDate.parse(r.getStartDate()).atStartOfDay());\n        }\n        if (StringUtils.hasText(r.getEndDate())) {\n            where.add(\"s.endTime <= :endDate\");\n            params.put(\"endDate\", LocalDate.parse(r.getEndDate()).atTime(23,59,59));\n        }\n        return String.join(\" AND \", where);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\ExamSlotParticipantRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/ExamSlotParticipantRepositoryImpl.java",
      "filename": "ExamSlotParticipantRepositoryImpl.java",
      "size_bytes": 25821,
      "lines": 541,
      "last_modified": "2025-11-28T08:56:33.016549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.ExamSlotParticipantSearchRequest;\nimport com.fuacs.backend.dto.response.ExamSlotParticipantDTO;\nimport com.fuacs.backend.dto.response.RoomDTO;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.dto.response.SlotDTO;\nimport com.fuacs.backend.dto.response.StudentProfileDTO;\nimport com.fuacs.backend.dto.response.SubjectDTO;\nimport com.fuacs.backend.entity.ExamSlotParticipant;\nimport com.fuacs.backend.entity.ExamSlotSubject;\nimport com.fuacs.backend.entity.Room;\nimport com.fuacs.backend.entity.Semester;\nimport com.fuacs.backend.entity.Slot;\nimport com.fuacs.backend.entity.StudentProfile;\nimport com.fuacs.backend.entity.Subject;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.repository.custom.CustomExamSlotParticipantRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.criteria.CriteriaBuilder;\nimport jakarta.persistence.criteria.CriteriaQuery;\nimport jakarta.persistence.criteria.Join;\nimport jakarta.persistence.criteria.JoinType;\nimport jakarta.persistence.criteria.Predicate;\nimport jakarta.persistence.criteria.Root;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class ExamSlotParticipantRepositoryImpl implements CustomExamSlotParticipantRepository {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    @Override\n    public List<ExamSlotParticipantDTO> search(Integer slotId, ExamSlotParticipantSearchRequest request) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<ExamSlotParticipant> query = cb.createQuery(ExamSlotParticipant.class);\n        Root<ExamSlotParticipant> root = query.from(ExamSlotParticipant.class);\n\n        // Use joins instead of fetch for filtering\n        Join<ExamSlotParticipant, ExamSlotSubject> examSlotSubjectJoin = root.join(\"examSlotSubject\", JoinType.LEFT);\n        Join<ExamSlotSubject, Slot> slotJoin = examSlotSubjectJoin.join(\"slot\", JoinType.LEFT);\n        Join<ExamSlotParticipant, User> studentJoin = root.join(\"studentUser\", JoinType.LEFT);\n        Join<User, com.fuacs.backend.entity.StudentProfile> studentProfileJoin = studentJoin.join(\"studentProfile\", JoinType.LEFT);\n\n        List<Predicate> predicates = buildPredicates(cb, root, examSlotSubjectJoin, slotJoin, studentJoin, studentProfileJoin, slotId,\n                request);\n        query.where(predicates.toArray(new Predicate[0]));\n\n        // Sorting\n        if (\"fullName\".equalsIgnoreCase(request.getSortBy())) {\n            query.orderBy(\"asc\".equalsIgnoreCase(request.getSort())\n                    ? cb.asc(studentJoin.get(\"fullName\"))\n                    : cb.desc(studentJoin.get(\"fullName\")));\n        } else if (\"createdAt\".equalsIgnoreCase(request.getSortBy())) {\n            query.orderBy(\"asc\".equalsIgnoreCase(request.getSort())\n                    ? cb.asc(root.get(\"createdAt\"))\n                    : cb.desc(root.get(\"createdAt\")));\n        } else if (\"updatedAt\".equalsIgnoreCase(request.getSortBy())) {\n            query.orderBy(\"asc\".equalsIgnoreCase(request.getSort())\n                    ? cb.asc(root.get(\"updatedAt\"))\n                    : cb.desc(root.get(\"updatedAt\")));\n        }\n\n        // Pagination (getPage() already returns 0-based index)\n        int offset = request.getPage() * request.getPageSize();\n        List<ExamSlotParticipant> participants = entityManager.createQuery(query)\n                .setFirstResult(offset)\n                .setMaxResults(request.getPageSize())\n                .getResultList();\n\n        return mapToDTOWithProfiles(participants);\n    }\n\n    @Override\n    public Long count(Integer slotId, ExamSlotParticipantSearchRequest request) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<Long> query = cb.createQuery(Long.class);\n        Root<ExamSlotParticipant> root = query.from(ExamSlotParticipant.class);\n\n        Join<ExamSlotParticipant, ExamSlotSubject> examSlotSubjectJoin = root.join(\"examSlotSubject\", JoinType.LEFT);\n        Join<ExamSlotSubject, Slot> slotJoin = examSlotSubjectJoin.join(\"slot\", JoinType.LEFT);\n        Join<ExamSlotParticipant, User> studentJoin = root.join(\"studentUser\", JoinType.LEFT);\n        Join<User, com.fuacs.backend.entity.StudentProfile> studentProfileJoin = studentJoin.join(\"studentProfile\", JoinType.LEFT);\n\n        List<Predicate> predicates = buildPredicates(cb, root, examSlotSubjectJoin, slotJoin, studentJoin, studentProfileJoin, slotId,\n                request);\n        query.select(cb.count(root));\n        query.where(predicates.toArray(new Predicate[0]));\n\n        return entityManager.createQuery(query).getSingleResult();\n    }\n\n    @Override\n    public List<ExamSlotParticipantDTO> searchAllBySlotId(Integer slotId, com.fuacs.backend.dto.request.PagedRequest request) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<ExamSlotParticipant> query = cb.createQuery(ExamSlotParticipant.class);\n        Root<ExamSlotParticipant> root = query.from(ExamSlotParticipant.class);\n\n        // Same joins as search()\n        Join<ExamSlotParticipant, ExamSlotSubject> examSlotSubjectJoin = root.join(\"examSlotSubject\", JoinType.LEFT);\n        Join<ExamSlotSubject, Slot> slotJoin = examSlotSubjectJoin.join(\"slot\", JoinType.LEFT);\n        Join<ExamSlotParticipant, User> studentJoin = root.join(\"studentUser\", JoinType.LEFT);\n        Join<User, com.fuacs.backend.entity.StudentProfile> studentProfileJoin = studentJoin.join(\"studentProfile\", JoinType.LEFT);\n\n        // Build predicates WITHOUT subject filter\n        List<Predicate> predicates = buildPredicatesAllSlot(cb, root, examSlotSubjectJoin, slotJoin, studentJoin, studentProfileJoin, slotId, request);\n        query.where(predicates.toArray(new Predicate[0]));\n\n        // Sorting\n        if (\"fullName\".equalsIgnoreCase(request.getSortBy())) {\n            query.orderBy(\"asc\".equalsIgnoreCase(request.getSort())\n                    ? cb.asc(studentJoin.get(\"fullName\"))\n                    : cb.desc(studentJoin.get(\"fullName\")));\n        } else if (\"createdAt\".equalsIgnoreCase(request.getSortBy())) {\n            query.orderBy(\"asc\".equalsIgnoreCase(request.getSort())\n                    ? cb.asc(root.get(\"createdAt\"))\n                    : cb.desc(root.get(\"createdAt\")));\n        } else if (\"updatedAt\".equalsIgnoreCase(request.getSortBy())) {\n            query.orderBy(\"asc\".equalsIgnoreCase(request.getSort())\n                    ? cb.asc(root.get(\"updatedAt\"))\n                    : cb.desc(root.get(\"updatedAt\")));\n        }\n\n        // Pagination\n        int offset = request.getPage() * request.getPageSize();\n        List<ExamSlotParticipant> participants = entityManager.createQuery(query)\n                .setFirstResult(offset)\n                .setMaxResults(request.getPageSize())\n                .getResultList();\n\n        // Use new mapToDTOWithProfiles (fetch profiles for rollNumber)\n        return mapToDTOWithProfiles(participants);\n    }\n\n    @Override\n    public Long countAllBySlotId(Integer slotId, com.fuacs.backend.dto.request.PagedRequest request) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<Long> query = cb.createQuery(Long.class);\n        Root<ExamSlotParticipant> root = query.from(ExamSlotParticipant.class);\n\n        Join<ExamSlotParticipant, ExamSlotSubject> examSlotSubjectJoin = root.join(\"examSlotSubject\", JoinType.LEFT);\n        Join<ExamSlotSubject, Slot> slotJoin = examSlotSubjectJoin.join(\"slot\", JoinType.LEFT);\n        Join<ExamSlotParticipant, User> studentJoin = root.join(\"studentUser\", JoinType.LEFT);\n        Join<User, com.fuacs.backend.entity.StudentProfile> studentProfileJoin = studentJoin.join(\"studentProfile\", JoinType.LEFT);\n\n        List<Predicate> predicates = buildPredicatesAllSlot(cb, root, examSlotSubjectJoin, slotJoin, studentJoin, studentProfileJoin, slotId, request);\n\n        query.select(cb.count(root));\n        query.where(predicates.toArray(new Predicate[0]));\n\n        return entityManager.createQuery(query).getSingleResult();\n    }\n\n    @Override\n    public ExamSlotParticipantDTO findByIdWithDetails(Long participantId) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<ExamSlotParticipant> query = cb.createQuery(ExamSlotParticipant.class);\n        Root<ExamSlotParticipant> root = query.from(ExamSlotParticipant.class);\n\n        // Fetch joins\n        root.fetch(\"examSlotSubject\", JoinType.LEFT).fetch(\"slot\", JoinType.LEFT);\n        root.fetch(\"examSlotSubject\", JoinType.LEFT).fetch(\"subject\", JoinType.LEFT);\n        root.fetch(\"studentUser\", JoinType.LEFT);\n\n        query.where(cb.equal(root.get(\"id\"), participantId));\n\n        List<ExamSlotParticipant> results = entityManager.createQuery(query).getResultList();\n        if (results.isEmpty()) {\n            return null;\n        }\n\n        List<ExamSlotParticipantDTO> dtos = mapToDTO(results);\n        return dtos.isEmpty() ? null : dtos.get(0);\n    }\n\n    private List<Predicate> buildPredicates(CriteriaBuilder cb, Root<ExamSlotParticipant> root,\n            Join<ExamSlotParticipant, ExamSlotSubject> examSlotSubjectJoin,\n            Join<ExamSlotSubject, Slot> slotJoin,\n            Join<ExamSlotParticipant, User> studentJoin,\n            Join<User, com.fuacs.backend.entity.StudentProfile> studentProfileJoin,\n            Integer slotId, ExamSlotParticipantSearchRequest request) {\n        List<Predicate> predicates = new ArrayList<>();\n\n        // Slot ID filter\n        predicates.add(cb.equal(slotJoin.get(\"id\"), slotId));\n\n        // Subject ID filter (required)\n        predicates.add(cb.equal(examSlotSubjectJoin.get(\"subject\").get(\"id\"), request.getSubjectId()));\n\n        // isEnrolled filter\n        if (request.getIsEnrolled() != null) {\n            predicates.add(cb.equal(root.get(\"isEnrolled\"), request.getIsEnrolled()));\n        }\n\n        // Search filter (fullName, rollNumber, email)\n        if (request.getSearch() != null && !request.getSearch().isEmpty()) {\n            String searchPattern = \"%\" + request.getSearch().toLowerCase() + \"%\";\n            Predicate searchPredicate = cb.or(\n                    cb.like(cb.lower(studentJoin.get(\"fullName\")), searchPattern),\n                    cb.like(cb.lower(studentJoin.get(\"email\")), searchPattern),\n                    cb.like(cb.lower(studentProfileJoin.get(\"rollNumber\")), searchPattern));\n            predicates.add(searchPredicate);\n        }\n\n        return predicates;\n    }\n\n    // Helper method for searchAllBySlotId - NO subject filter\n    private List<Predicate> buildPredicatesAllSlot(CriteriaBuilder cb, Root<ExamSlotParticipant> root,\n            Join<ExamSlotParticipant, ExamSlotSubject> examSlotSubjectJoin,\n            Join<ExamSlotSubject, Slot> slotJoin,\n            Join<ExamSlotParticipant, User> studentJoin,\n            Join<User, com.fuacs.backend.entity.StudentProfile> studentProfileJoin,\n            Integer slotId, com.fuacs.backend.dto.request.PagedRequest request) {\n        List<Predicate> predicates = new ArrayList<>();\n\n        // Slot ID filter\n        predicates.add(cb.equal(slotJoin.get(\"id\"), slotId));\n\n        // NO SUBJECT FILTER - key difference from buildPredicates()\n\n        // isEnrolled filter (if request is ExamSlotParticipantSearchRequest)\n        if (request instanceof ExamSlotParticipantSearchRequest) {\n            ExamSlotParticipantSearchRequest searchRequest = (ExamSlotParticipantSearchRequest) request;\n\n            if (searchRequest.getIsEnrolled() != null) {\n                predicates.add(cb.equal(root.get(\"isEnrolled\"), searchRequest.getIsEnrolled()));\n            }\n\n            // Search filter (fullName, email, rollNumber)\n            if (searchRequest.getSearch() != null && !searchRequest.getSearch().isEmpty()) {\n                String searchPattern = \"%\" + searchRequest.getSearch().toLowerCase() + \"%\";\n                Predicate searchPredicate = cb.or(\n                        cb.like(cb.lower(studentJoin.get(\"fullName\")), searchPattern),\n                        cb.like(cb.lower(studentJoin.get(\"email\")), searchPattern),\n                        cb.like(cb.lower(studentProfileJoin.get(\"rollNumber\")), searchPattern));\n                predicates.add(searchPredicate);\n            }\n        }\n\n        return predicates;\n    }\n\n    private List<ExamSlotParticipantDTO> mapToDTO(List<ExamSlotParticipant> participants) {\n        List<ExamSlotParticipantDTO> dtos = new ArrayList<>();\n        for (ExamSlotParticipant participant : participants) {\n            ExamSlotParticipantDTO dto = new ExamSlotParticipantDTO();\n            dto.setId(participant.getId());\n            dto.setIsEnrolled(participant.getIsEnrolled());\n            dto.setCreatedAt(participant.getCreatedAt());\n            dto.setUpdatedAt(participant.getUpdatedAt());\n\n            // Map student\n            User student = participant.getStudentUser();\n            if (student != null) {\n                dto.setStudentUserId(student.getId());\n                StudentProfileDTO studentDTO = new StudentProfileDTO();\n                studentDTO.setUserId(student.getId());\n                studentDTO.setFullName(student.getFullName());\n                studentDTO.setEmail(student.getEmail());\n\n                // Get student profile for rollNumber and major - need to fetch separately\n                // Since User doesn't have a direct getStudentProfile() method\n                // The profile will be fetched via repository if needed\n                studentDTO.setRollNumber(null); // Will be populated if profile exists\n                studentDTO.setMajor(null);\n                dto.setStudent(studentDTO);\n            }\n\n            // Map exam slot subject\n            ExamSlotSubject examSlotSubject = participant.getExamSlotSubject();\n            if (examSlotSubject != null) {\n                // Map slot\n                Slot slot = examSlotSubject.getSlot();\n                if (slot != null) {\n                    dto.setSlotId(slot.getId());\n                    SlotDTO slotDTO = new SlotDTO();\n                    slotDTO.setId(slot.getId());\n                    slotDTO.setTitle(slot.getTitle());\n                    slotDTO.setStartTime(slot.getStartTime());\n                    slotDTO.setEndTime(slot.getEndTime());\n                    slotDTO.setSlotCategory(slot.getSlotCategory());\n\n                    // Map room\n                    Room room = slot.getRoom();\n                    if (room != null) {\n                        RoomDTO roomDTO = new RoomDTO();\n                        roomDTO.setId(room.getId());\n                        roomDTO.setName(room.getName());\n                        roomDTO.setLocation(room.getLocation());\n                        slotDTO.setRoom(roomDTO);\n                    }\n\n                    // Map semester\n                    Semester semester = slot.getSemester();\n                    if (semester != null) {\n                        SemesterDTO semesterDTO = new SemesterDTO();\n                        semesterDTO.setId(semester.getId());\n                        semesterDTO.setName(semester.getName());\n                        semesterDTO.setCode(semester.getCode());\n                        slotDTO.setSemester(semesterDTO);\n                    }\n\n                    dto.setSlot(slotDTO);\n                }\n\n                // Map subject\n                Subject subject = examSlotSubject.getSubject();\n                if (subject != null) {\n                    dto.setSubjectId(subject.getId().intValue());\n                    SubjectDTO subjectDTO = new SubjectDTO();\n                    subjectDTO.setId(subject.getId());\n                    subjectDTO.setName(subject.getName());\n                    subjectDTO.setCode(subject.getCode());\n                    dto.setSubject(subjectDTO);\n                }\n            }\n\n            dtos.add(dto);\n        }\n        return dtos;\n    }\n\n    /**\n     * Map entities to DTOs with StudentProfile data (rollNumber, major, baseUrl)\n     * This method fetches StudentProfile for each student to populate rollNumber\n     */\n    private List<ExamSlotParticipantDTO> mapToDTOWithProfiles(List<ExamSlotParticipant> participants) {\n        List<ExamSlotParticipantDTO> dtos = new ArrayList<>();\n\n        // Collect all student user IDs to batch fetch profiles\n        List<Integer> studentUserIds = participants.stream()\n                .map(p -> p.getStudentUser().getId())\n                .distinct()\n                .collect(Collectors.toList());\n\n        // Batch fetch student profiles\n        Map<Integer, StudentProfile> profileMap = new LinkedHashMap<>();\n        if (!studentUserIds.isEmpty()) {\n            String jpql = \"SELECT sp FROM StudentProfile sp WHERE sp.userId IN :userIds\";\n            List<StudentProfile> profiles = entityManager.createQuery(jpql, StudentProfile.class)\n                    .setParameter(\"userIds\", studentUserIds)\n                    .getResultList();\n\n            for (StudentProfile profile : profiles) {\n                profileMap.put(profile.getUserId(), profile);\n            }\n        }\n\n        // Map participants to DTOs\n        for (ExamSlotParticipant participant : participants) {\n            ExamSlotParticipantDTO dto = new ExamSlotParticipantDTO();\n            dto.setId(participant.getId());\n            dto.setIsEnrolled(participant.getIsEnrolled());\n            dto.setCreatedAt(participant.getCreatedAt());\n            dto.setUpdatedAt(participant.getUpdatedAt());\n\n            // Map student\n            User student = participant.getStudentUser();\n            if (student != null) {\n                dto.setStudentUserId(student.getId());\n                StudentProfileDTO studentDTO = new StudentProfileDTO();\n                studentDTO.setUserId(student.getId());\n                studentDTO.setFullName(student.getFullName());\n                studentDTO.setEmail(student.getEmail());\n\n                // Get student profile for rollNumber\n                StudentProfile profile = profileMap.get(student.getId());\n                if (profile != null) {\n                    studentDTO.setRollNumber(profile.getRollNumber());\n                    studentDTO.setBaseUrl(profile.getBaseUrl());\n                }\n\n                dto.setStudent(studentDTO);\n            }\n\n            // Map exam slot subject\n            ExamSlotSubject examSlotSubject = participant.getExamSlotSubject();\n            if (examSlotSubject != null) {\n                // Map slot\n                Slot slot = examSlotSubject.getSlot();\n                if (slot != null) {\n                    dto.setSlotId(slot.getId());\n                    SlotDTO slotDTO = new SlotDTO();\n                    slotDTO.setId(slot.getId());\n                    slotDTO.setTitle(slot.getTitle());\n                    slotDTO.setStartTime(slot.getStartTime());\n                    slotDTO.setEndTime(slot.getEndTime());\n                    slotDTO.setSlotCategory(slot.getSlotCategory());\n\n                    // Map room\n                    Room room = slot.getRoom();\n                    if (room != null) {\n                        RoomDTO roomDTO = new RoomDTO();\n                        roomDTO.setId(room.getId());\n                        roomDTO.setName(room.getName());\n                        roomDTO.setLocation(room.getLocation());\n                        slotDTO.setRoom(roomDTO);\n                    }\n\n                    // Map semester\n                    Semester semester = slot.getSemester();\n                    if (semester != null) {\n                        SemesterDTO semesterDTO = new SemesterDTO();\n                        semesterDTO.setId(semester.getId());\n                        semesterDTO.setName(semester.getName());\n                        semesterDTO.setCode(semester.getCode());\n                        slotDTO.setSemester(semesterDTO);\n                    }\n\n                    dto.setSlot(slotDTO);\n                }\n\n                // Map subject\n                Subject subject = examSlotSubject.getSubject();\n                if (subject != null) {\n                    dto.setSubjectId(subject.getId().intValue());\n                    SubjectDTO subjectDTO = new SubjectDTO();\n                    subjectDTO.setId(subject.getId());\n                    subjectDTO.setName(subject.getName());\n                    subjectDTO.setCode(subject.getCode());\n                    dto.setSubject(subjectDTO);\n                }\n            }\n\n            dtos.add(dto);\n        }\n        return dtos;\n    }\n\n    @Override\n    public List<com.fuacs.backend.dto.response.StudentAttendanceInfoDTO> findStudentsWithAttendanceBySlotId(Integer slotId) {\n        // Optimized query to fetch all data in a single query with proper JOINs to avoid N+1 problems\n        String jpql = \"\"\"\n            SELECT\n                u.id,\n                sp.rollNumber,\n                u.fullName,\n                sp.baseUrl,\n                s.code,\n                s.name,\n                ea.id,\n                ea.status,\n                ea.method,\n                ea.recordedAt,\n                eae.id,\n                eae.imageUrl,\n                eae.createdAt,\n                ea.remark\n            FROM ExamSlotParticipant esp\n            JOIN esp.examSlotSubject ess\n            JOIN ess.subject s\n            JOIN esp.studentUser u\n            LEFT JOIN StudentProfile sp ON sp.userId = u.id\n            LEFT JOIN ExamAttendance ea ON ea.student.id = u.id AND ea.slot.id = :slotId\n            LEFT JOIN ExamAttendanceEvidence eae ON eae.examAttendance.id = ea.id\n            WHERE ess.slot.id = :slotId\n            AND ess.isActive = true\n            AND esp.isEnrolled = true\n            GROUP BY u.id, sp.rollNumber, u.fullName, sp.baseUrl, s.code, s.name,\n                     ea.id, ea.status, ea.method, ea.recordedAt, eae.id, eae.imageUrl, eae.createdAt, ea.remark\n            ORDER BY u.fullName, s.code\n            \"\"\";\n        \n        List<Object[]> results = entityManager.createQuery(jpql, Object[].class)\n                .setParameter(\"slotId\", slotId)\n                .getResultList();\n        \n        // Use a map to consolidate students with multiple evidence/remark\n        Map<String, com.fuacs.backend.dto.response.StudentAttendanceInfoDTO> studentMap = new LinkedHashMap<>();\n        \n        for (Object[] row : results) {\n            Integer studentId = (Integer) row[0];\n            String rollNumber = (String) row[1];\n            String fullName = (String) row[2];\n            String photoUrl = (String) row[3];\n            String subjectCode = (String) row[4];\n            String subjectName = (String) row[5];\n            Long attendanceId = (Long) row[6];\n            com.fuacs.backend.constant.enums.AttendanceStatus status =\n                (com.fuacs.backend.constant.enums.AttendanceStatus) row[7];\n            com.fuacs.backend.constant.enums.AttendanceMethod method =\n                (com.fuacs.backend.constant.enums.AttendanceMethod) row[8];\n            java.time.Instant recordedAt = (java.time.Instant) row[9];\n            Long evidenceId = (Long) row[10];\n            String evidenceImageUrl = (String) row[11];\n            java.time.Instant evidenceCreatedAt = (java.time.Instant) row[12];\n            String remark = (String) row[13];\n\n            // Create unique key for student-subject combination\n            String key = studentId + \"-\" + subjectCode;\n\n            // Set default status if no attendance record\n            if (status == null) {\n                status = com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET;\n            }\n\n            // Create evidence DTO if exists\n            com.fuacs.backend.dto.response.AttendanceEvidenceDTO evidence = null;\n            if (evidenceId != null) {\n                evidence = new com.fuacs.backend.dto.response.AttendanceEvidenceDTO();\n                evidence.setId(evidenceId);\n                evidence.setImageUrl(evidenceImageUrl);\n                evidence.setCreatedAt(evidenceCreatedAt);\n            }\n\n            // For check-in/check-out times, we use recordedAt as check-in time\n            // In a real system, you might have separate check-in/check-out records\n            java.time.Instant checkInTime = recordedAt;\n            java.time.Instant checkOutTime = null; // Will be null unless there's a separate check-out record\n\n            com.fuacs.backend.dto.response.StudentAttendanceInfoDTO studentInfo =\n                new com.fuacs.backend.dto.response.StudentAttendanceInfoDTO(\n                    studentId,\n                    rollNumber,\n                    fullName,\n                    photoUrl,\n                    subjectCode,\n                    subjectName,\n                    attendanceId,\n                    status,\n                    method,\n                    recordedAt,\n                    checkInTime,\n                    checkOutTime,\n                    evidence,\n                    remark\n                );\n\n            studentMap.put(key, studentInfo);\n        }\n\n        return new ArrayList<>(studentMap.values());\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\ExamSlotSubjectRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/ExamSlotSubjectRepositoryImpl.java",
      "filename": "ExamSlotSubjectRepositoryImpl.java",
      "size_bytes": 1645,
      "lines": 45,
      "last_modified": "2025-11-28T08:56:33.016549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.response.SubjectDTO;\nimport com.fuacs.backend.entity.ExamSlotSubject;\nimport com.fuacs.backend.entity.Subject;\nimport com.fuacs.backend.repository.custom.CustomExamSlotSubjectRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.criteria.CriteriaBuilder;\nimport jakarta.persistence.criteria.CriteriaQuery;\nimport jakarta.persistence.criteria.Join;\nimport jakarta.persistence.criteria.Root;\n\nimport java.util.List;\n\npublic class ExamSlotSubjectRepositoryImpl implements CustomExamSlotSubjectRepository {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    @Override\n    public List<SubjectDTO> findSubjectsBySlotId(Integer slotId) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<SubjectDTO> query = cb.createQuery(SubjectDTO.class);\n        Root<ExamSlotSubject> root = query.from(ExamSlotSubject.class);\n        Join<ExamSlotSubject, Subject> subjectJoin = root.join(\"subject\");\n\n        query.select(cb.construct(\n                SubjectDTO.class,\n                subjectJoin.get(\"id\"),\n                subjectJoin.get(\"name\"),\n                subjectJoin.get(\"code\")\n        ));\n\n        query.where(\n            cb.and(\n                cb.equal(root.get(\"slot\").get(\"id\"), slotId),\n                cb.equal(root.get(\"isActive\"), true)\n            )\n        );\n        query.orderBy(cb.asc(subjectJoin.get(\"name\")));\n\n        return entityManager.createQuery(query).getResultList();\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\MajorRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/MajorRepositoryImpl.java",
      "filename": "MajorRepositoryImpl.java",
      "size_bytes": 3474,
      "lines": 87,
      "last_modified": "2025-11-28T08:56:33.016549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\n\nimport com.fuacs.backend.dto.request.MajorSearchRequest;\nimport com.fuacs.backend.dto.response.MajorDTO;\nimport com.fuacs.backend.repository.custom.CustomMajorRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Repository\npublic class MajorRepositoryImpl implements CustomMajorRepository {\n    private static final Map<String, String> SORTABLE_FIELDS = Map.of(\n            \"name\", \"m.name\",\n            \"code\", \"m.code\"\n    );\n    @PersistenceContext\n    private EntityManager em;\n\n    @Override\n    public List<MajorDTO> search(MajorSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT NEW com.fuacs.backend.dto.response.MajorDTO(m.id, m.name, m.code, m.isActive, \" +\n                        \"m.createdAt, m.updatedAt, COUNT(s.id)) \" +\n                        \"FROM Major m LEFT JOIN m.subjects s\"\n        );\n\n        String whereClause = buildWhereClause(request, parameters);\n        if (StringUtils.hasText(whereClause)) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        jpql.append(\" GROUP BY m.id, m.name, m.code, m.isActive, m.createdAt, m.updatedAt\");\n        String sortBy = request.getSortBy();\n        String sortDir = request.getSort();\n\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            jpql.append(\" ORDER BY \").append(SORTABLE_FIELDS.get(sortBy)).append(\" \").append(sortDir);\n        } else {\n            jpql.append(\" ORDER BY m.id \").append(sortDir);\n        }\n\n        TypedQuery<MajorDTO> query = em.createQuery(jpql.toString(), MajorDTO.class);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n\n        return query.getResultList();\n    }\n\n    @Override\n    public Long count(MajorSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(m.id) FROM Major m\");\n        String whereClause = buildWhereClause(request, parameters);\n        if (StringUtils.hasText(whereClause)) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    private String buildWhereClause(MajorSearchRequest request, Map<String, Object> parameters) {\n        List<String> conditions = new ArrayList<>();\n        String search = request.getSearch();\n\n        if (StringUtils.hasText(search)) {\n            conditions.add(\"(LOWER(m.name) LIKE :search OR LOWER(m.code) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n        if (request.getActive() != null) {\n            conditions.add(\"m.isActive = :isActive\");\n            parameters.put(\"isActive\", request.getActive());\n        }\n        return String.join(\" AND \", conditions);\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\RoleRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/RoleRepositoryImpl.java",
      "filename": "RoleRepositoryImpl.java",
      "size_bytes": 3351,
      "lines": 89,
      "last_modified": "2025-11-28T08:56:33.016549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.entity.Role;\nimport com.fuacs.backend.repository.custom.CustomRoleRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.TypedQuery;\nimport jakarta.persistence.criteria.CriteriaBuilder;\nimport jakarta.persistence.criteria.CriteriaQuery;\nimport jakarta.persistence.criteria.Predicate;\nimport jakarta.persistence.criteria.Root;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n@Repository\npublic class RoleRepositoryImpl implements CustomRoleRepository {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    @Override\n    public List<Role> searchRoles(String search, Boolean isActive, Set<String> exclude, Pageable pageable) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<Role> cq = cb.createQuery(Role.class);\n        Root<Role> root = cq.from(Role.class);\n\n        List<Predicate> predicates = buildPredicates(cb, root, search, isActive, exclude);\n        cq.where(predicates.toArray(new Predicate[0]));\n\n        // Sorting\n        if (pageable != null && pageable.getSort().isSorted()) {\n            pageable.getSort().forEach(order -> {\n                if (order.isAscending()) {\n                    cq.orderBy(cb.asc(root.get(order.getProperty())));\n                } else {\n                    cq.orderBy(cb.desc(root.get(order.getProperty())));\n                }\n            });\n        }\n\n        TypedQuery<Role> query = entityManager.createQuery(cq);\n        if (pageable != null) {\n            query.setFirstResult((int) pageable.getOffset());\n            query.setMaxResults(pageable.getPageSize());\n        }\n        return query.getResultList();\n    }\n\n    @Override\n    public Long countAllRoles(String search, Boolean isActive, Set<String> exclude) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<Long> cq = cb.createQuery(Long.class);\n        Root<Role> root = cq.from(Role.class);\n\n        List<Predicate> predicates = buildPredicates(cb, root, search, isActive, exclude);\n        cq.select(cb.count(root));\n        cq.where(predicates.toArray(new Predicate[0]));\n\n        return entityManager.createQuery(cq).getSingleResult();\n    }\n\n    private List<Predicate> buildPredicates(CriteriaBuilder cb,\n                                            Root<Role> root,\n                                            String search,\n                                            Boolean isActive,\n                                            Set<String> exclude) {\n        List<Predicate> predicates = new ArrayList<>();\n\n        if (search != null && !search.isBlank()) {\n            String like = \"%\" + search.toLowerCase() + \"%\";\n            predicates.add(cb.like(cb.lower(root.get(\"name\")), like));\n        }\n\n        if (isActive != null) {\n            predicates.add(cb.equal(root.get(\"isActive\"), isActive));\n        }\n\n        if (exclude != null && !exclude.isEmpty()) {\n            predicates.add(cb.not(root.get(\"name\").in(exclude)));\n        }\n\n        return predicates;\n    }\n}\n\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\RoomRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/RoomRepositoryImpl.java",
      "filename": "RoomRepositoryImpl.java",
      "size_bytes": 19108,
      "lines": 410,
      "last_modified": "2025-11-28T08:56:33.017551",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.RoomSearchRequest;\nimport com.fuacs.backend.dto.response.RoomDTO;\nimport com.fuacs.backend.repository.custom.CustomRoomRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Implementation của CustomRoomRepository sử dụng EntityManager và JPQL.\n * Xử lý các query phức tạp với dynamic WHERE clause và staff-scoped filtering.\n *\n * @see CustomRoomRepository\n */\n@Repository\npublic class RoomRepositoryImpl implements CustomRoomRepository {\n    /**\n     * Mapping từ field name trong request sang JPQL field expression.\n     * Chỉ cho phép sort theo các field được định nghĩa trong map này.\n     */\n    private static final Map<String, String> SORTABLE_FIELDS = Map.of(\n            \"name\", \"r.name\",\n            \"location\", \"r.location\");\n\n    @PersistenceContext\n    private EntityManager em;\n\n    /**\n     * Search phòng thông thường với camera statistics.\n     * JPQL sử dụng LEFT JOIN với cameras và GROUP BY để tính totalCameras và activeCameras.\n     * Kết quả được map trực tiếp vào RoomDTO constructor (7 parameters).\n     *\n     * @param request Chứa filters và pagination\n     * @return Danh sách RoomDTO với totalCameras và activeCameras\n     */\n    @Override\n    public List<RoomDTO> search(RoomSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n\n        // Build dynamic WHERE clause dựa trên filters trong request\n        String whereClause = buildWhereClause(parameters, request);\n\n        // Construct JPQL với LEFT JOIN cameras để tính statistics\n        // COUNT(c.id): đếm tổng số camera (bao gồm inactive)\n        // SUM(CASE...): đếm chỉ camera active\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT NEW com.fuacs.backend.dto.response.RoomDTO(r.id, r.name, r.location, r.isActive, r.createdAt, r.updatedAt, COUNT(c.id), \"\n                        +\n                        \"SUM(CASE WHEN c.isActive = true THEN 1 ELSE 0 END)) \" +\n                        \"FROM Room r LEFT JOIN r.cameras c\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n        // GROUP BY cần thiết vì sử dụng aggregate functions (COUNT, SUM)\n        jpql.append(\" GROUP BY r.id, r.name, r.location\");\n\n        // Validate và apply sorting (chỉ cho phép sort theo name hoặc location)\n        String sortBy = request.getSortBy();\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            String sortField = SORTABLE_FIELDS.get(sortBy);\n            jpql.append(\" ORDER BY \").append(sortField).append(\" \").append(request.getSort());\n        } else {\n            // Default sort by id nếu không có hoặc invalid sortBy\n            jpql.append(\" ORDER BY r.id ASC\");\n        }\n\n        // Execute query với pagination\n        TypedQuery<RoomDTO> query = em.createQuery(jpql.toString(), RoomDTO.class);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    /**\n     * Đếm tổng số phòng thỏa mãn filter thông thường.\n     * Không cần JOIN với cameras vì chỉ đếm số room.\n     *\n     * @param request Chứa filters: isActive, hasCamera, search\n     * @return Tổng số phòng\n     */\n    @Override\n    public Long count(RoomSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n\n        String whereClause = buildWhereClause(parameters, request);\n\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(r.id) FROM Room r\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    /**\n     * Search phòng theo staff ID với usage statistics.\n     * JPQL JOIN với Slot để lọc phòng mà staff có slot, và tính usageCount và lastUsedAt.\n     * Kết quả trả về Object[] vì cần convert LocalDateTime sang Instant.\n     *\n     * @param staffId ID của staff cần filter\n     * @param request Chứa filters: search, isActive, semesterId, pagination\n     * @return Danh sách RoomDTO với usageCount và lastUsedAt cho staff\n     */\n    @Override\n    public List<RoomDTO> searchByStaffId(Integer staffId, RoomSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n\n        // Build WHERE clause với filters cho staff-scoped search\n        String whereClause = buildWhereClauseForStaff(parameters, request, null, null);\n\n        // JPQL JOIN với Slot để filter phòng mà staff có slot\n        // JOIN Slot: chỉ lấy phòng có slot của staff này\n        // LEFT JOIN AcademicClass và Semester: để filter theo semesterId nếu có\n        // COUNT(DISTINCT sl.id): đếm số slot của staff tại phòng này\n        // MAX(sl.endTime): lấy thời điểm slot cuối cùng kết thúc\n        String jpql = \"\"\"\n                SELECT r.id, r.name, r.location,\n                       COUNT(DISTINCT sl.id),\n                       MAX(sl.endTime),\n                       r.isActive, r.createdAt, r.updatedAt\n                FROM Room r\n                JOIN Slot sl ON sl.room.id = r.id\n                LEFT JOIN sl.academicClass ac\n                LEFT JOIN ac.semester sem\n                JOIN sl.staff st\n                WHERE st.id = :staffId\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" AND \" + whereClause) + \"\"\"\n\n                GROUP BY r.id, r.name, r.location, r.isActive, r.createdAt, r.updatedAt\n                ORDER BY r.name ASC\n                \"\"\";\n\n        // Execute query với pagination\n        TypedQuery<Object[]> query = em.createQuery(jpql, Object[].class);\n        query.setParameter(\"staffId\", staffId);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n\n        // Map Object[] results sang RoomDTO với proper type conversion\n        List<Object[]> results = query.getResultList();\n        return results.stream()\n                .map(row -> {\n                    // JPQL MAX() trả về LocalDateTime, cần convert sang Instant\n                    // Sử dụng UTC timezone vì DB lưu timestamp dạng UTC\n                    java.time.LocalDateTime lastUsedLocalDateTime = (java.time.LocalDateTime) row[4];\n                    Instant lastUsedAt = lastUsedLocalDateTime != null\n                        ? lastUsedLocalDateTime.atZone(java.time.ZoneOffset.UTC).toInstant()\n                        : null;\n\n                    // Map vào RoomDTO constructor dùng cho staff-scoped query\n                    return new RoomDTO(\n                        (Short) row[0],          // id\n                        (String) row[1],         // name\n                        (String) row[2],         // location\n                        (Long) row[3],           // usageCount\n                        lastUsedAt,              // lastUsedAt (converted from LocalDateTime)\n                        (Boolean) row[5],        // isActive\n                        (Instant) row[6],        // createdAt\n                        (Instant) row[7]         // updatedAt\n                    );\n                })\n                .collect(java.util.stream.Collectors.toList());\n    }\n\n    /**\n     * Đếm tổng số phòng mà staff có slot (staff-scoped count).\n     * Sử dụng COUNT(DISTINCT r.id) vì một phòng có thể có nhiều slot của staff.\n     *\n     * @param staffId ID của staff\n     * @param request Chứa filters: search, isActive, semesterId\n     * @return Tổng số phòng unique mà staff có slot\n     */\n    @Override\n    public Long countByStaffId(Integer staffId, RoomSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n\n        String whereClause = buildWhereClauseForStaff(parameters, request, null, null);\n\n        // DISTINCT cần thiết vì một phòng có thể có nhiều slot của cùng staff\n        // Ví dụ: Phòng 301 có 15 slot của Lecturer A → chỉ đếm 1 lần phòng 301\n        String jpql = \"\"\"\n                SELECT COUNT(DISTINCT r.id)\n                FROM Room r\n                JOIN Slot sl ON sl.room.id = r.id\n                LEFT JOIN sl.academicClass ac\n                LEFT JOIN ac.semester sem\n                JOIN sl.staff st\n                WHERE st.id = :staffId\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" AND \" + whereClause);\n\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"staffId\", staffId);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    /**\n     * Search phòng theo staff ID với date range filter.\n     * Tương tự searchByStaffId nhưng filter thêm theo khoảng thời gian slot.\n     * Ví dụ: Tìm phòng mà Lecturer A có slot trong tháng 12/2024.\n     *\n     * @param staffId ID của staff\n     * @param request Chứa filters: search, isActive, semesterId, pagination\n     * @param startDate Ngày bắt đầu (slot.startTime >= startDate 00:00:00)\n     * @param endDate Ngày kết thúc (slot.endTime <= endDate 23:59:59)\n     * @return Danh sách RoomDTO với usage statistics trong khoảng thời gian\n     */\n    @Override\n    public List<RoomDTO> searchByStaffIdWithDateRange(Integer staffId, RoomSearchRequest request,\n            LocalDate startDate, LocalDate endDate) {\n        Map<String, Object> parameters = new HashMap<>();\n\n        // Build WHERE clause với date range filter (startDate và endDate được thêm vào conditions)\n        String whereClause = buildWhereClauseForStaff(parameters, request, startDate, endDate);\n\n        // JPQL tương tự searchByStaffId() nhưng có thêm date range conditions trong whereClause\n        String jpql = \"\"\"\n                SELECT r.id, r.name, r.location,\n                       COUNT(DISTINCT sl.id),\n                       MAX(sl.endTime),\n                       r.isActive, r.createdAt, r.updatedAt\n                FROM Room r\n                JOIN Slot sl ON sl.room.id = r.id\n                LEFT JOIN sl.academicClass ac\n                LEFT JOIN ac.semester sem\n                JOIN sl.staff st\n                WHERE st.id = :staffId\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" AND \" + whereClause) + \"\"\"\n\n                GROUP BY r.id, r.name, r.location, r.isActive, r.createdAt, r.updatedAt\n                ORDER BY r.name ASC\n                \"\"\";\n\n        TypedQuery<Object[]> query = em.createQuery(jpql, Object[].class);\n        query.setParameter(\"staffId\", staffId);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n\n        // Map Object[] sang RoomDTO, logic tương tự searchByStaffId()\n        List<Object[]> results = query.getResultList();\n        return results.stream()\n                .map(row -> {\n                    java.time.LocalDateTime lastUsedLocalDateTime = (java.time.LocalDateTime) row[4];\n                    Instant lastUsedAt = lastUsedLocalDateTime != null\n                        ? lastUsedLocalDateTime.atZone(java.time.ZoneOffset.UTC).toInstant()\n                        : null;\n\n                    return new RoomDTO(\n                        (Short) row[0],          // id\n                        (String) row[1],         // name\n                        (String) row[2],         // location\n                        (Long) row[3],           // usageCount\n                        lastUsedAt,              // lastUsedAt (converted from LocalDateTime)\n                        (Boolean) row[5],        // isActive\n                        (Instant) row[6],        // createdAt\n                        (Instant) row[7]         // updatedAt\n                    );\n                })\n                .collect(java.util.stream.Collectors.toList());\n    }\n\n    /**\n     * Đếm tổng số phòng mà staff có slot trong date range.\n     * Sử dụng COUNT(DISTINCT r.id) với filter theo khoảng thời gian.\n     *\n     * @param staffId ID của staff\n     * @param request Chứa filters: search, isActive, semesterId\n     * @param startDate Ngày bắt đầu filter\n     * @param endDate Ngày kết thúc filter\n     * @return Tổng số phòng unique trong khoảng thời gian\n     */\n    @Override\n    public Long countByStaffIdWithDateRange(Integer staffId, RoomSearchRequest request,\n            LocalDate startDate, LocalDate endDate) {\n        Map<String, Object> parameters = new HashMap<>();\n\n        // Build WHERE clause với date range filter\n        String whereClause = buildWhereClauseForStaff(parameters, request, startDate, endDate);\n\n        // DISTINCT đếm phòng unique, date range được apply trong whereClause\n        String jpql = \"\"\"\n                SELECT COUNT(DISTINCT r.id)\n                FROM Room r\n                JOIN Slot sl ON sl.room.id = r.id\n                LEFT JOIN sl.academicClass ac\n                LEFT JOIN ac.semester sem\n                JOIN sl.staff st\n                WHERE st.id = :staffId\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" AND \" + whereClause);\n\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"staffId\", staffId);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    /**\n     * Build WHERE clause cho search thông thường (không staff-scoped).\n     * Xử lý các filters: isActive, hasCamera, search keyword.\n     * hasCamera sử dụng EXISTS subquery để check camera active trong phòng.\n     *\n     * @param parameters Map để lưu JPQL parameters (output)\n     * @param request Chứa các filter values\n     * @return WHERE clause string (không bao gồm keyword WHERE)\n     */\n    private String buildWhereClause(Map<String, Object> parameters, RoomSearchRequest request) {\n        List<String> whereClauses = new ArrayList<>();\n\n        // Filter theo trạng thái active/inactive\n        if (request.getActive() != null) {\n            whereClauses.add(\"r.isActive = :isActive\");\n            parameters.put(\"isActive\", request.getActive());\n        }\n\n        // Filter theo hasCamera (có/không có camera active)\n        // Sử dụng EXISTS/NOT EXISTS subquery để check\n        if (request.getHasCamera() != null) {\n            if (request.getHasCamera()) {\n                // true: Phòng có ít nhất 1 camera active\n                whereClauses.add(\"EXISTS (SELECT 1 FROM r.cameras c WHERE c.isActive = true)\");\n            } else {\n                // false: Phòng không có camera active nào\n                whereClauses.add(\"NOT EXISTS (SELECT 1 FROM r.cameras c WHERE c.isActive = true)\");\n            }\n        }\n\n        // Filter theo keyword search (tìm trong name hoặc location)\n        // Sử dụng LOWER() cho case-insensitive search\n        String search = request.getSearch();\n        if (StringUtils.hasText(search)) {\n            whereClauses.add(\"(LOWER(r.name) LIKE :search OR LOWER(r.location) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n\n        // Join tất cả conditions với AND\n        return String.join(\" AND \", whereClauses);\n    }\n\n    /**\n     * Build WHERE clause cho staff-scoped search.\n     * Xử lý các filters: isActive, search keyword, semesterId, và date range.\n     * Date range được convert thành LocalDateTime với atStartOfDay() và atTime(LocalTime.MAX).\n     *\n     * @param parameters Map để lưu JPQL parameters (output)\n     * @param request Chứa các filter values\n     * @param startDate Ngày bắt đầu filter (nullable)\n     * @param endDate Ngày kết thúc filter (nullable)\n     * @return WHERE clause string (không bao gồm keyword WHERE)\n     */\n    private String buildWhereClauseForStaff(Map<String, Object> parameters, RoomSearchRequest request,\n            LocalDate startDate, LocalDate endDate) {\n        List<String> whereClauses = new ArrayList<>();\n\n        // Filter theo trạng thái active/inactive của phòng\n        if (request.getActive() != null) {\n            whereClauses.add(\"r.isActive = :isActive\");\n            parameters.put(\"isActive\", request.getActive());\n        }\n\n        // Filter theo keyword search trong name hoặc location\n        String search = request.getSearch();\n        if (StringUtils.hasText(search)) {\n            whereClauses.add(\"(LOWER(r.name) LIKE :search OR LOWER(r.location) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n\n        // Filter theo semester (chỉ lấy phòng có slot trong semester này)\n        // Ví dụ: semesterId=5 → chỉ lấy phòng mà staff có slot trong Fall2024\n        if (request.getSemesterId() != null) {\n            whereClauses.add(\"sem.id = :semesterId\");\n            parameters.put(\"semesterId\", request.getSemesterId());\n        }\n\n        // Filter theo date range (khoảng thời gian slot diễn ra)\n        // Convert LocalDate sang LocalDateTime để compare với slot.startTime/endTime\n        if (startDate != null) {\n            // atStartOfDay(): 2024-12-01 → 2024-12-01 00:00:00\n            LocalDateTime startDateTime = startDate.atStartOfDay();\n            whereClauses.add(\"sl.startTime >= :startDate\");\n            parameters.put(\"startDate\", startDateTime);\n        }\n\n        if (endDate != null) {\n            // atTime(LocalTime.MAX): 2024-12-31 → 2024-12-31 23:59:59.999999999\n            LocalDateTime endDateTime = endDate.atTime(LocalTime.MAX);\n            whereClauses.add(\"sl.endTime <= :endDate\");\n            parameters.put(\"endDate\", endDateTime);\n        }\n\n        // Join tất cả conditions với AND\n        return String.join(\" AND \", whereClauses);\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\SemesterRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/SemesterRepositoryImpl.java",
      "filename": "SemesterRepositoryImpl.java",
      "size_bytes": 5863,
      "lines": 135,
      "last_modified": "2025-11-28T08:56:33.017551",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.SemesterSearchRequest;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.repository.custom.CustomSemesterRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Repository\npublic class SemesterRepositoryImpl implements CustomSemesterRepository {\n    private static final Map<String, String> SORTABLE_FIELDS = Map.of(\n            \"name\", \"name\",\n            \"code\", \"s.code\",\n            \"startDate\", \"startDate\",\n            \"endDate\", \"endDate\"\n    );\n    @PersistenceContext\n    private EntityManager em;\n\n    @Override\n    public List<SemesterDTO> search(SemesterSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        String jpql = \"\"\"\n                SELECT NEW com.fuacs.backend.dto.response.SemesterDTO(\n                    s.id,\n                    s.name,\n                    s.code,\n                    s.startDate,\n                    s.endDate,\n                    COUNT(ac.id),\n                    s.isActive,\n                    s.createdAt,\n                    s.updatedAt\n                )\n                FROM Semester s\n                LEFT JOIN s.academicClasses ac\n                \"\"\" +\n                (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause + \" \") +\n                \"GROUP BY s.id, s.name, s.code, s.startDate, s.endDate \" +\n                buildOrderBy(request.getSortBy(), request.getSort());\n\n        TypedQuery<SemesterDTO> query = em.createQuery(jpql, SemesterDTO.class);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public Long count(SemesterSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(s.id) FROM Semester s\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    private String buildWhereClause(Map<String, Object> parameters, SemesterSearchRequest request) {\n        List<String> whereClauses = new ArrayList<>();\n        if (request.getActive() != null) {\n            whereClauses.add(\"s.isActive = :isActive\");\n            parameters.put(\"isActive\", request.getActive());\n        }\n        String search = request.getSearch();\n        if (StringUtils.hasText(search)) {\n            whereClauses.add(\"(LOWER(s.name) LIKE :search OR LOWER(s.code) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n        return String.join(\" AND \", whereClauses);\n    }\n\n    private String buildOrderBy(String sortBy, String sort) {\n        String direction = (sort == null || sort.isBlank()) ? \"ASC\" : sort;\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            return \"ORDER BY \" + SORTABLE_FIELDS.get(sortBy) + \" \" + direction;\n        }\n        return \"ORDER BY s.id \" + direction;\n    }\n\n    @Override\n    public List<com.fuacs.backend.entity.Semester> findSemestersWithSupervisionData(Integer supervisorId) {\n        // Find semesters from class-based slots\n        String classSemestersJpql = \"\"\"\n                SELECT DISTINCT classSem\n                FROM Slot s\n                JOIN s.academicClass ac\n                JOIN ac.semester classSem\n                WHERE s.staff.id = :supervisorId\n                ORDER BY classSem.startDate DESC\n                \"\"\";\n        TypedQuery<com.fuacs.backend.entity.Semester> classQuery = em.createQuery(classSemestersJpql, com.fuacs.backend.entity.Semester.class);\n        classQuery.setParameter(\"supervisorId\", supervisorId);\n        List<com.fuacs.backend.entity.Semester> classSemesters = classQuery.getResultList();\n\n        // Find semesters from independent slots\n        String independentSemestersJpql = \"\"\"\n                SELECT DISTINCT independentSem\n                FROM Slot s\n                JOIN s.semester independentSem\n                WHERE s.staff.id = :supervisorId\n                  AND s.academicClass IS NULL\n                ORDER BY independentSem.startDate DESC\n                \"\"\";\n        TypedQuery<com.fuacs.backend.entity.Semester> independentQuery = em.createQuery(independentSemestersJpql, com.fuacs.backend.entity.Semester.class);\n        independentQuery.setParameter(\"supervisorId\", supervisorId);\n        List<com.fuacs.backend.entity.Semester> independentSemesters = independentQuery.getResultList();\n\n        // Merge semesters while preserving order (most recent first) and avoiding duplicates\n        java.util.LinkedHashMap<Short, com.fuacs.backend.entity.Semester> merged = new java.util.LinkedHashMap<>();\n        for (com.fuacs.backend.entity.Semester s : classSemesters) {\n            merged.put(s.getId(), s);\n        }\n        for (com.fuacs.backend.entity.Semester s : independentSemesters) {\n            merged.putIfAbsent(s.getId(), s);\n        }\n        \n        return new java.util.ArrayList<>(merged.values());\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\SlotRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/SlotRepositoryImpl.java",
      "filename": "SlotRepositoryImpl.java",
      "size_bytes": 133877,
      "lines": 2702,
      "last_modified": "2025-11-28T08:56:33.018550",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.dto.request.SlotSearchRequest;\nimport com.fuacs.backend.dto.response.AttendanceStatsDTO;\nimport com.fuacs.backend.dto.response.ClassDTO;\nimport com.fuacs.backend.dto.response.DashboardStatsDTO;\nimport com.fuacs.backend.dto.response.RecentActivitySlotDTO;\nimport com.fuacs.backend.dto.response.RoomDTO;\nimport com.fuacs.backend.dto.response.SemesterDTO;\nimport com.fuacs.backend.dto.response.SlotDTO;\nimport com.fuacs.backend.dto.response.SubjectDTO;\nimport com.fuacs.backend.dto.response.TodaySlotDTO;\nimport com.fuacs.backend.dto.response.UserDTO;\nimport com.fuacs.backend.repository.custom.CustomSlotRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.Tuple;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\n@Repository\npublic class SlotRepositoryImpl implements CustomSlotRepository {\n    private static final Map<String, String> SORTABLE_FIELDS = Map.of(\n            \"id\", \"s.id\",\n            \"startTime\", \"s.startTime\",\n            \"endTime\", \"s.endTime\",\n            \"slotCategory\", \"s.slotCategory\",\n            \"roomName\", \"r.name\",\n            \"staffFullName\", \"u.fullName\",\n            \"classCode\", \"c.code\");\n\n    @PersistenceContext\n    private EntityManager em;\n\n    @Override\n    public List<SlotDTO> search(SlotSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        String jpql;\n        List<SlotCategory> categories = request.getSlotCategory();\n        // Only use optimized query (without ess join) if:\n        // 1. Categories are only LECTURE/LECTURE_WITH_PT\n        // 2. NOT searching text (would need ess.subject.name/code in WHERE)\n        // Note: We CAN filter by subjectId without ess join for LECTURE slots\n        boolean onlyRegularCategories = categories != null && !categories.isEmpty()\n                && categories.stream().allMatch(c -> c == SlotCategory.LECTURE || c == SlotCategory.LECTURE_WITH_PT)\n                && !StringUtils.hasText(request.getSearch());\n\n        if (onlyRegularCategories) {\n            // Optimized query for LECTURE/LECTURE_WITH_PT only.\n            // No need to join ExamSlotSubject.\n            jpql = \"\"\"\n                    SELECT\n                        s.id AS id,\n                        s.title AS title,\n                        s.description AS description,\n                        s.startTime AS startTime,\n                        s.endTime AS endTime,\n                        s.slotCategory AS slotCategory,\n                        r.id AS roomId,\n                        r.name AS roomName,\n                        r.location AS roomLocation,\n                        u.id AS staffId,\n                        u.username AS staffUsername,\n                        u.fullName AS staffFullName,\n                        c.id AS classId,\n                        c.code AS classCode,\n                        sub.id AS subjectId,\n                        sub.name AS subjectName,\n                        sub.code AS subjectCode,\n                        COALESCE(classSem.id, independentSem.id) AS semesterId,\n                        COALESCE(classSem.name, independentSem.name) AS semesterName,\n                        COALESCE(classSem.code, independentSem.code) AS semesterCode,\n                        COUNT(DISTINCT e.id) AS totalStudent,\n                        COUNT(DISTINCT CASE WHEN ar.status = 'present' THEN ar.id END) AS totalPresentStudent,\n                        COUNT(DISTINCT CASE WHEN ar.status = 'absent' THEN ar.id END) AS totalAbsentStudent,\n                        COUNT(DISTINCT CASE WHEN ar.status = 'not_yet' THEN ar.id END) AS totalNotYetStudent,\n                        s.isActive AS isActive,\n                        s.createdAt AS createdAt,\n                        s.updatedAt AS updatedAt,\n                        CAST(null AS string) AS examSubjectName,\n                        CAST(null AS string) AS examSubjectCode,\n                        CAST(null AS short) AS examSubjectId\n                    \n                    FROM Slot s\n                    LEFT JOIN s.room r\n                    LEFT JOIN s.staff u\n                    LEFT JOIN s.academicClass c\n                    LEFT JOIN c.subject sub\n                    LEFT JOIN c.semester classSem\n                    LEFT JOIN s.semester independentSem\n                    LEFT JOIN c.enrollments e ON e.isEnrolled = true\n                    LEFT JOIN s.attendanceRecords ar ON ar.student IN (SELECT e2.student FROM c.enrollments e2 WHERE e2.isEnrolled = true)\n                    \"\"\"\n                    // Intentionally no LEFT JOIN for ExamSlotSubject\n                    + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause) + \"\"\"\n                        GROUP BY\n                            s.id, s.title, s.description, s.startTime, s.endTime, s.slotCategory,\n                            r.id, r.name, r.location,\n                            u.id, u.username, u.fullName,\n                            c.id, c.code,\n                            sub.id, sub.name, sub.code,\n                            COALESCE(classSem.id, independentSem.id),\n                            COALESCE(classSem.name, independentSem.name),\n                            COALESCE(classSem.code, independentSem.code),\n                            s.isActive, s.createdAt, s.updatedAt\n                    \"\"\";\n        } else {\n            // This handles FINAL_EXAM and null (all types).\n            // Both require joining ExamSlotSubject.\n            jpql = \"\"\"\n                         SELECT\n                             s.id AS id,\n                             s.title AS title,\n                             s.description AS description,\n                             s.startTime AS startTime,\n                             s.endTime AS endTime,\n                             s.slotCategory AS slotCategory,\n                             r.id AS roomId,\n                             r.name AS roomName,\n                             r.location AS roomLocation,\n                             u.id AS staffId,\n                             u.username AS staffUsername,\n                             u.fullName AS staffFullName,\n                             c.id AS classId,\n                             c.code AS classCode,\n                             sub.id AS subjectId,\n                             sub.name AS subjectName,\n                             sub.code AS subjectCode,\n                             COALESCE(classSem.id, independentSem.id) AS semesterId,\n                             COALESCE(classSem.name, independentSem.name) AS semesterName,\n                             COALESCE(classSem.code, independentSem.code) AS semesterCode,\n                             CASE\n                                 WHEN s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                                 THEN (SELECT COUNT(esp) FROM ExamSlotParticipant esp\n                                       JOIN esp.examSlotSubject ess2\n                                       WHERE ess2.slot.id = s.id\n                                       AND esp.isEnrolled = true)\n                                 ELSE COUNT(DISTINCT e.id)\n                             END AS totalStudent,\n                             COUNT(DISTINCT CASE WHEN ar.status = 'present' THEN ar.id END) AS totalPresentStudent,\n                             COUNT(DISTINCT CASE WHEN ar.status = 'absent' THEN ar.id END) AS totalAbsentStudent,\n                             COUNT(DISTINCT CASE WHEN ar.status = 'not_yet' THEN ar.id END) AS totalNotYetStudent,\n                             s.isActive AS isActive,\n                             s.createdAt AS createdAt,\n                             s.updatedAt AS updatedAt,\n                             ess.subject.name AS examSubjectName,\n                             ess.subject.code AS examSubjectCode,\n                             ess.subject.id AS examSubjectId\n                    \n                         FROM Slot s\n                         LEFT JOIN s.room r\n                         LEFT JOIN s.staff u\n                         LEFT JOIN s.academicClass c\n                         LEFT JOIN c.subject sub\n                         LEFT JOIN c.semester classSem\n                         LEFT JOIN s.semester independentSem\n                         LEFT JOIN c.enrollments e ON e.isEnrolled = true\n                         LEFT JOIN s.attendanceRecords ar ON ar.student IN (SELECT e2.student FROM c.enrollments e2 WHERE e2.isEnrolled = true)\n                         LEFT JOIN ExamSlotSubject ess ON ess.slot = s\n                    \"\"\" + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause) + \"\"\"\n                        GROUP BY\n                            s.id, s.title, s.description, s.startTime, s.endTime, s.slotCategory,\n                            r.id, r.name, r.location,\n                            u.id, u.username, u.fullName,\n                            c.id, c.code,\n                            sub.id, sub.name, sub.code,\n                            COALESCE(classSem.id, independentSem.id),\n                            COALESCE(classSem.name, independentSem.name),\n                            COALESCE(classSem.code, independentSem.code),\n                            s.isActive, s.createdAt, s.updatedAt,\n                            ess.subject.name, ess.subject.code, ess.subject.id\n                    \"\"\";\n        }\n\n        // Add ORDER BY clause for consistent ordering\n        String sortBy = request.getSortBy() != null ? request.getSortBy() : \"startTime\";\n        String sortField = SORTABLE_FIELDS.getOrDefault(sortBy, \"s.startTime\");\n        String sortDirection = \"desc\".equalsIgnoreCase(request.getSort()) ? \"DESC\" : \"ASC\";\n        jpql += \" ORDER BY \" + sortField + \" \" + sortDirection;\n\n        var tupleQuery = em.createQuery(jpql, Tuple.class);\n        parameters.forEach(tupleQuery::setParameter);\n\n        // CRITICAL FIX: Do NOT apply pagination here - fetch all matching rows first\n        // tupleQuery.setFirstResult(request.getPage() * request.getPageSize());\n        // tupleQuery.setMaxResults(request.getPageSize());\n\n        List<Tuple> tuples = tupleQuery.getResultList();\n\n        // Use a LinkedHashMap to consolidate results and maintain insertion order\n        // This is CRITICAL for handling the one-to-many join with ExamSlotSubject\n        Map<Integer, SlotDTO> slotMap = new LinkedHashMap<>();\n\n        for (Tuple t : tuples) {\n            Integer id = t.get(\"id\", Integer.class);\n\n            // Check if we've already created the base SlotDTO for this ID\n            SlotDTO dto = slotMap.get(id);\n\n            // If this is the first time seeing this slot, create the main DTO\n            if (dto == null) {\n                String title = t.get(\"title\", String.class);\n                String description = t.get(\"description\", String.class);\n                java.time.LocalDateTime startTime = t.get(\"startTime\", java.time.LocalDateTime.class);\n                java.time.LocalDateTime endTime = t.get(\"endTime\", java.time.LocalDateTime.class);\n                com.fuacs.backend.constant.enums.SlotCategory slotCategory = t.get(\"slotCategory\",\n                        com.fuacs.backend.constant.enums.SlotCategory.class);\n\n                // --- Build nested DTOs ---\n\n                com.fuacs.backend.dto.response.RoomDTO room = null;\n                if (t.get(\"roomId\") != null) {\n                    room = new com.fuacs.backend.dto.response.RoomDTO(\n                            t.get(\"roomId\", Short.class),\n                            t.get(\"roomName\", String.class),\n                            t.get(\"roomLocation\", String.class));\n                }\n\n                com.fuacs.backend.dto.response.StaffDTO staff = null;\n                if (t.get(\"staffId\") != null) {\n                    staff = new com.fuacs.backend.dto.response.StaffDTO(\n                            t.get(\"staffId\", Integer.class),\n                            t.get(\"staffUsername\", String.class),\n                            t.get(\"staffFullName\", String.class));\n                }\n\n                // --- Build Semester (from COALESCE) ---\n                com.fuacs.backend.dto.response.SemesterDTO semester = null;\n                if (t.get(\"semesterId\") != null) {\n                    semester = new com.fuacs.backend.dto.response.SemesterDTO(\n                            t.get(\"semesterId\", Short.class),\n                            t.get(\"semesterName\", String.class),\n                            t.get(\"semesterCode\", String.class));\n                }\n\n                // --- Build Class (if it exists) ---\n                com.fuacs.backend.dto.response.ClassDTO classObj = null;\n                if (t.get(\"classId\") != null) {\n                    com.fuacs.backend.dto.response.SubjectDTO subject = null;\n                    if (t.get(\"subjectId\") != null) {\n                        subject = new com.fuacs.backend.dto.response.SubjectDTO(\n                                t.get(\"subjectId\", Short.class),\n                                t.get(\"subjectName\", String.class),\n                                t.get(\"subjectCode\", String.class));\n                    }\n\n                    classObj = new com.fuacs.backend.dto.response.ClassDTO(\n                            t.get(\"classId\", Short.class),\n                            t.get(\"classCode\", String.class),\n                            subject,\n                            // Only associate semester with class if it's a class-based slot\n                            (slotCategory == SlotCategory.LECTURE || slotCategory == SlotCategory.LECTURE_WITH_PT)\n                                    ? semester\n                                    : null);\n                }\n\n                // --- Aggregated counts ---\n                Integer totalStudent = Optional.ofNullable(t.get(\"totalStudent\", Long.class)).orElse(0L).intValue();\n                Integer totalPresent = Optional.ofNullable(t.get(\"totalPresentStudent\", Long.class)).orElse(0L)\n                        .intValue();\n                Integer totalAbsent = Optional.ofNullable(t.get(\"totalAbsentStudent\", Long.class)).orElse(0L)\n                        .intValue();\n                Integer totalNotYet = Optional.ofNullable(t.get(\"totalNotYetStudent\", Long.class)).orElse(0L)\n                        .intValue();\n\n                Boolean isActive = t.get(\"isActive\", Boolean.class);\n                java.time.Instant createdAt = t.get(\"createdAt\", java.time.Instant.class);\n                java.time.Instant updatedAt = t.get(\"updatedAt\", java.time.Instant.class);\n\n                // --- Create the main DTO ---\n                dto = new SlotDTO(\n                        isActive,\n                        createdAt,\n                        updatedAt,\n                        id,\n                        title,\n                        description,\n                        startTime,\n                        endTime,\n                        slotCategory,\n                        totalNotYet,\n                        totalAbsent,\n                        totalPresent,\n                        totalStudent,\n                        classObj,\n                        staff,\n                        room);\n\n                dto.setExamSubjects(new ArrayList<>());\n\n                // Set subjects list based on category\n                if (slotCategory == com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM) {\n                    // For FINAL_EXAM, set the top-level semester\n                    dto.setSemester(semester);\n                    // The subjects will be added from the `examSubjects` list populated below\n                    //dto.setSubjects(new ArrayList<>());\n                }\n//                else if (classObj != null && classObj.getSubject() != null) {\n//                    // For LECTURE, the subject comes from the class\n//                    dto.setSubjects(List.of(classObj.getSubject()));\n//                } else {\n//                    dto.setSubjects(new ArrayList<>());\n//                }\n\n                // Add the newly created DTO to our map\n                slotMap.put(id, dto);\n            }\n\n            // --- This part runs for EVERY row (tuple) ---\n            // Check if this row contains exam subject data\n            // This works for both queries:\n            // 1. For LECTURE query, examSubjectId will be null (from CAST)\n            // 2. For FINAL_EXAM/all query, it will be populated\n            Short examSubjectId = t.get(\"examSubjectId\", Short.class);\n            if (examSubjectId != null) {\n                SubjectDTO examSubject = new SubjectDTO(\n                        examSubjectId,\n                        t.get(\"examSubjectName\", String.class),\n                        t.get(\"examSubjectCode\", String.class));\n\n                // Add the exam subject to its corresponding DTO, checking for duplicates\n                if (!dto.getExamSubjects().contains(examSubject)) {\n                    dto.getExamSubjects().add(examSubject);\n                }\n            }\n        }\n\n        // CRITICAL FIX: Apply pagination AFTER consolidation\n        // Convert map to list (maintains insertion order from LinkedHashMap)\n        List<SlotDTO> allSlots = new ArrayList<>(slotMap.values());\n\n        // Calculate pagination boundaries\n        int fromIndex = request.getPage() * request.getPageSize();\n        int toIndex = Math.min(fromIndex + request.getPageSize(), allSlots.size());\n\n        // Return paginated sublist\n        if (fromIndex >= allSlots.size()) {\n            return new ArrayList<>(); // Return empty list if page is out of bounds\n        }\n\n        return allSlots.subList(fromIndex, toIndex);\n    }\n\n    private List<SlotDTO> searchByClassId(SlotSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        String jpql = \"\"\"\n                    SELECT\n                        s.id AS id,\n                        s.title AS title,\n                        s.description AS description,\n                        s.startTime AS startTime,\n                        s.endTime AS endTime,\n                        s.slotCategory AS slotCategory,\n                        r.id AS roomId,\n                        r.name AS roomName,\n                        r.location AS roomLocation,\n                        u.id AS staffId,\n                        u.username AS staffUsername,\n                        u.fullName AS staffFullName,\n                        s.isActive AS isActive,\n                        s.createdAt AS createdAt,\n                        s.updatedAt AS updatedAt\n                    FROM Slot s\n                    LEFT JOIN s.room r\n                    LEFT JOIN s.staff u\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause) + \"\"\"\n                    GROUP BY\n                        s.id, s.title, s.description, s.startTime, s.endTime, s.slotCategory,\n                        r.id, r.name, r.location,\n                        u.id, u.username, u.fullName,\n                        s.isActive, s.createdAt, s.updatedAt\n                \"\"\";\n\n        var tupleQuery = em.createQuery(jpql, Tuple.class);\n        parameters.forEach(tupleQuery::setParameter);\n        tupleQuery.setFirstResult(request.getPage() * request.getPageSize());\n        tupleQuery.setMaxResults(request.getPageSize());\n\n        List<Tuple> tuples = tupleQuery.getResultList();\n        List<SlotDTO> results = new ArrayList<>();\n\n        for (Tuple t : tuples) {\n            SlotDTO dto = new SlotDTO(\n                    t.get(\"id\", Integer.class),\n                    t.get(\"title\", String.class),\n                    t.get(\"description\", String.class),\n                    t.get(\"startTime\", java.time.LocalDateTime.class),\n                    t.get(\"endTime\", java.time.LocalDateTime.class),\n                    t.get(\"slotCategory\", com.fuacs.backend.constant.enums.SlotCategory.class),\n                    t.get(\"isActive\", Boolean.class),\n                    t.get(\"createdAt\", java.time.Instant.class),\n                    t.get(\"updatedAt\", java.time.Instant.class),\n                    new com.fuacs.backend.dto.response.StaffDTO(\n                            t.get(\"staffId\", Integer.class),\n                            t.get(\"staffUsername\", String.class),\n                            t.get(\"staffFullName\", String.class)),\n                    new com.fuacs.backend.dto.response.RoomDTO(\n                            t.get(\"roomId\", Short.class),\n                            t.get(\"roomName\", String.class),\n                            t.get(\"roomLocation\", String.class)));\n            results.add(dto);\n        }\n        return results;\n    }\n\n    @Override\n    public Long count(SlotSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        // --- BẮT ĐẦU: Logic được sao chép từ search() ---\n        // Logic này PHẢI giống hệt phương thức search()\n        // để đảm bảo whereClause và các JOINs tương thích.\n        List<SlotCategory> categories = request.getSlotCategory();\n        boolean onlyRegularCategories = categories != null && !categories.isEmpty()\n                && categories.stream().allMatch(c -> c == SlotCategory.LECTURE || c == SlotCategory.LECTURE_WITH_PT)\n                && request.getSubjectId() == null\n                && !StringUtils.hasText(request.getSearch());\n        // --- KẾT THÚC: Logic được sao chép từ search() ---\n\n        // Chúng ta phải JOIN ExamSlotSubject TRỪ KHI\n        // các điều kiện tối ưu hóa (onlyRegularCategories) được đáp ứng.\n        boolean includeExamJoin = !onlyRegularCategories;\n\n        // Phải join ExamSlotSubject ở đây để filtering trong WHERE clause hoạt động\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(DISTINCT s.id) FROM Slot s \" +\n                \"LEFT JOIN s.room r \" +\n                \"LEFT JOIN s.staff u \" +\n                \"LEFT JOIN s.academicClass c \" +\n                \"LEFT JOIN c.subject sub \" +\n                \"LEFT JOIN c.semester classSem \" +\n                \"LEFT JOIN s.semester independentSem \");\n\n        if (includeExamJoin) {\n            jpql.append(\"LEFT JOIN ExamSlotSubject ess ON ess.slot = s \"); // Join để filter\n        }\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    // ---------------- Dashboard aggregate queries ----------------\n    @Override\n    public DashboardStatsDTO calculateLecturerStats(Integer lecturerId, Short semesterId) {\n        // Debug: Log parameters\n        System.out.println(\"DEBUG calculateLecturerStats - lecturerId: \" + lecturerId + \", semesterId: \" + semesterId);\n\n        // First, let's check if lecturer has any slots at all\n        String debugJpql = \"\"\"\n                    SELECT COUNT(s.id) as totalSlotsForLecturer\n                    FROM Slot s\n                    WHERE s.staff.id = :lecturerId\n                \"\"\";\n        TypedQuery<Long> debugQuery = em.createQuery(debugJpql, Long.class);\n        debugQuery.setParameter(\"lecturerId\", lecturerId);\n        Long totalSlotsForLecturer = debugQuery.getSingleResult();\n        System.out.println(\"DEBUG - Total slots for lecturer (all semesters): \" + totalSlotsForLecturer);\n\n        // Fixed query to properly handle both class-based and independent slots\n        String jpql = \"\"\"\n                    SELECT \n                        COUNT(DISTINCT (CASE WHEN s.academicClass IS NOT NULL THEN s.academicClass.id END)) as totalClasses,\n                        COUNT(s.id) as totalSlots\n                    FROM Slot s\n                    LEFT JOIN s.academicClass ac\n                    LEFT JOIN ac.semester classSem\n                    LEFT JOIN s.semester independentSem\n                    WHERE s.staff.id = :lecturerId\n                      AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                      AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                \"\"\";\n\n        TypedQuery<Tuple> query = em.createQuery(jpql, Tuple.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"semesterId\", semesterId);\n        Tuple result = query.getSingleResult();\n\n        Number n0 = (Number) result.get(0);\n        Number n1 = (Number) result.get(1);\n\n        Integer totalClasses = n0 == null ? 0 : n0.intValue();\n        Integer totalSlots = n1 == null ? 0 : n1.intValue();\n\n        System.out.println(\"DEBUG - totalClasses: \" + totalClasses + \", totalSlots: \" + totalSlots);\n\n        // Calculate finalized slots based on attendance records completion\n        Integer finalizedSlots = calculateFinalizedSlots(lecturerId, semesterId);\n\n        // Calculate upcoming slots and total students\n        Integer upcomingSlots = calculateUpcomingSlots(lecturerId, semesterId);\n        Integer totalStudents = calculateTotalStudents(lecturerId, semesterId);\n\n        System.out.println(\"DEBUG - finalizedSlots: \" + finalizedSlots + \", upcomingSlots: \" + upcomingSlots + \", totalStudents: \" + totalStudents);\n\n        return new DashboardStatsDTO(totalClasses, totalSlots, finalizedSlots, upcomingSlots, totalStudents);\n    }\n\n    private Integer calculateFinalizedSlots(Integer lecturerId, Short semesterId) {\n        String jpql = \"\"\"\n                    SELECT COUNT(DISTINCT s.id)\n                    FROM Slot s\n                    LEFT JOIN s.academicClass ac\n                    LEFT JOIN ac.semester classSem\n                    LEFT JOIN s.semester independentSem\n                    WHERE s.staff.id = :lecturerId\n                      AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                      AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                      AND s.endTime < CURRENT_TIMESTAMP\n                      AND EXISTS (\n                          SELECT 1 FROM AttendanceRecord ar \n                          WHERE ar.slot.id = s.id\n                      )\n                \"\"\";\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"semesterId\", semesterId);\n        Long result = query.getSingleResult();\n        return result != null ? result.intValue() : 0;\n    }\n\n    private Double calculateAverageAttendanceRate(Integer lecturerId, Short semesterId) {\n        String jpql = \"\"\"\n                    SELECT \n                        COUNT(ar.id) as totalRecords,\n                        SUM(CASE WHEN ar.status = 'present' THEN 1 ELSE 0 END) as presentCount\n                    FROM AttendanceRecord ar\n                    JOIN ar.slot s\n                    LEFT JOIN s.academicClass ac\n                    LEFT JOIN ac.semester classSem\n                    LEFT JOIN s.semester independentSem\n                    WHERE s.staff.id = :lecturerId\n                      AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                      AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                \"\"\";\n        TypedQuery<Tuple> q = em.createQuery(jpql, Tuple.class);\n        q.setParameter(\"lecturerId\", lecturerId);\n        q.setParameter(\"semesterId\", semesterId);\n        Tuple t = q.getSingleResult();\n        long total = t.get(0) == null ? 0L : ((Number) t.get(0)).longValue();\n        long present = t.get(1) == null ? 0L : ((Number) t.get(1)).longValue();\n        if (total == 0L) return 0.0;\n        return Math.round((present * 100.0 / total) * 10.0) / 10.0;\n    }\n\n    // ---- All Semester variants (no semester filter) ----\n    @Override\n    public DashboardStatsDTO calculateLecturerStatsAllSemesters(Integer lecturerId) {\n        System.out.println(\"DEBUG calculateLecturerStatsAllSemesters - lecturerId: \" + lecturerId);\n\n        // Calculate stats across ALL semesters (no semester filter)\n        String jpql = \"\"\"\n                    SELECT\n                        COUNT(DISTINCT (CASE WHEN s.academicClass IS NOT NULL THEN s.academicClass.id END)) as totalClasses,\n                        COUNT(s.id) as totalSlots\n                    FROM Slot s\n                    WHERE s.staff.id = :lecturerId\n                      AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                \"\"\";\n\n        TypedQuery<Tuple> query = em.createQuery(jpql, Tuple.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        Tuple result = query.getSingleResult();\n\n        Number n0 = (Number) result.get(0);\n        Number n1 = (Number) result.get(1);\n\n        Integer totalClasses = n0 == null ? 0 : n0.intValue();\n        Integer totalSlots = n1 == null ? 0 : n1.intValue();\n\n        System.out.println(\"DEBUG - totalClasses: \" + totalClasses + \", totalSlots: \" + totalSlots);\n\n        // Calculate finalized slots (all semesters)\n        Integer finalizedSlots = calculateFinalizedSlotsAllSemesters(lecturerId);\n\n        // Calculate upcoming slots and total students (all semesters)\n        Integer upcomingSlots = calculateUpcomingSlotsAllSemesters(lecturerId);\n        Integer totalStudents = calculateTotalStudentsAllSemesters(lecturerId);\n\n        System.out.println(\"DEBUG - finalizedSlots: \" + finalizedSlots + \", upcomingSlots: \" + upcomingSlots + \", totalStudents: \" + totalStudents);\n\n        return new DashboardStatsDTO(totalClasses, totalSlots, finalizedSlots, upcomingSlots, totalStudents);\n    }\n\n    private Integer calculateFinalizedSlotsAllSemesters(Integer lecturerId) {\n        String jpql = \"\"\"\n                    SELECT COUNT(DISTINCT s.id)\n                    FROM Slot s\n                    WHERE s.staff.id = :lecturerId\n                      AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                      AND s.endTime < CURRENT_TIMESTAMP\n                      AND EXISTS (\n                          SELECT 1 FROM AttendanceRecord ar\n                          WHERE ar.slot.id = s.id\n                      )\n                \"\"\";\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        Long result = query.getSingleResult();\n        return result != null ? result.intValue() : 0;\n    }\n\n    private Double calculateAverageAttendanceRateAllSemesters(Integer lecturerId) {\n        String jpql = \"\"\"\n                    SELECT\n                        COUNT(ar.id) as totalRecords,\n                        SUM(CASE WHEN ar.status = 'present' THEN 1 ELSE 0 END) as presentCount\n                    FROM AttendanceRecord ar\n                    JOIN ar.slot s\n                    WHERE s.staff.id = :lecturerId\n                      AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                \"\"\";\n        TypedQuery<Tuple> q = em.createQuery(jpql, Tuple.class);\n        q.setParameter(\"lecturerId\", lecturerId);\n        Tuple t = q.getSingleResult();\n        long total = t.get(0) == null ? 0L : ((Number) t.get(0)).longValue();\n        long present = t.get(1) == null ? 0L : ((Number) t.get(1)).longValue();\n        if (total == 0L) return 0.0;\n        return Math.round((present * 100.0 / total) * 10.0) / 10.0;\n    }\n\n    @Override\n    public Integer calculateUpcomingSlots(Integer lecturerId, Short semesterId) {\n        String jpql = \"\"\"\n                    SELECT COUNT(s.id)\n                    FROM Slot s\n                    LEFT JOIN s.academicClass ac\n                    LEFT JOIN ac.semester classSem\n                    LEFT JOIN s.semester independentSem\n                    WHERE s.staff.id = :lecturerId\n                      AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                      AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                      AND s.startTime > CURRENT_TIMESTAMP\n                \"\"\";\n\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"semesterId\", semesterId);\n        Long count = query.getSingleResult();\n\n        return count != null ? count.intValue() : 0;\n    }\n\n    @Override\n    public Integer calculateUpcomingSlotsAllSemesters(Integer lecturerId) {\n        String jpql = \"\"\"\n                    SELECT COUNT(s.id)\n                    FROM Slot s\n                    WHERE s.staff.id = :lecturerId\n                      AND s.slotCategory <> com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                      AND s.startTime > CURRENT_TIMESTAMP\n                \"\"\";\n\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        Long count = query.getSingleResult();\n\n        return count != null ? count.intValue() : 0;\n    }\n\n    @Override\n    public Integer calculateTotalStudents(Integer lecturerId, Short semesterId) {\n        String jpql = \"\"\"\n                    SELECT COUNT(DISTINCT e.student.id)\n                    FROM Enrollment e\n                    JOIN e.academicClass c\n                    JOIN Slot s ON s.academicClass.id = c.id\n                    WHERE s.staff.id = :lecturerId\n                      AND c.semester.id = :semesterId\n                      AND e.isEnrolled = true\n                \"\"\";\n\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"semesterId\", semesterId);\n        Long count = query.getSingleResult();\n\n        return count != null ? count.intValue() : 0;\n    }\n\n    @Override\n    public Integer calculateTotalStudentsAllSemesters(Integer lecturerId) {\n        String jpql = \"\"\"\n                    SELECT COUNT(DISTINCT e.student.id)\n                    FROM Enrollment e\n                    JOIN e.academicClass c\n                    JOIN Slot s ON s.academicClass.id = c.id\n                    WHERE s.staff.id = :lecturerId\n                      AND e.isEnrolled = true\n                \"\"\";\n\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        Long count = query.getSingleResult();\n\n        return count != null ? count.intValue() : 0;\n    }\n\n    @Override\n    public List<TodaySlotDTO> findTodaySlots(Integer lecturerId, LocalDateTime startOfDay, LocalDateTime endOfDay) {\n        String jpql = \"\"\"\n                    SELECT s\n                    FROM Slot s\n                    LEFT JOIN FETCH s.room r\n                    LEFT JOIN FETCH s.academicClass c\n                    LEFT JOIN FETCH c.subject sub\n                    WHERE s.staff.id = :lecturerId\n                      AND s.startTime >= :startOfDay\n                      AND s.startTime <= :endOfDay\n                    ORDER BY s.startTime ASC\n                \"\"\";\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"startOfDay\", startOfDay);\n        query.setParameter(\"endOfDay\", endOfDay);\n        List<com.fuacs.backend.entity.Slot> slots = query.getResultList();\n        List<TodaySlotDTO> res = new ArrayList<>();\n        for (var s : slots) {\n            TodaySlotDTO dto = new TodaySlotDTO();\n            dto.setId(s.getId());\n            dto.setTitle(s.getTitle());\n            dto.setStartTime(s.getStartTime());\n            dto.setEndTime(s.getEndTime());\n            if (s.getRoom() != null) {\n                dto.setRoom(new com.fuacs.backend.dto.response.RoomDTO(s.getRoom().getId(), s.getRoom().getName(), s.getRoom().getLocation()));\n            }\n            if (s.getAcademicClass() != null) {\n                var c = s.getAcademicClass();\n                dto.setClassObj(new com.fuacs.backend.dto.response.ClassDTO(c.getId(), c.getCode()));\n                if (c.getSubject() != null) {\n                    var sub = c.getSubject();\n                    dto.setSubject(new com.fuacs.backend.dto.response.SubjectDTO(sub.getId(), sub.getName(), sub.getCode()));\n                }\n            }\n            res.add(dto);\n        }\n        return res;\n    }\n\n    @Override\n    public List<RecentActivitySlotDTO> findRecentActivitySlots(Integer lecturerId, LocalDateTime startDate, LocalDateTime endDate) {\n        String jpql = \"\"\"\n                    SELECT s\n                    FROM Slot s\n                    LEFT JOIN FETCH s.academicClass c\n                    LEFT JOIN FETCH c.subject sub\n                    WHERE s.staff.id = :lecturerId\n                      AND s.startTime >= :startDate\n                      AND s.startTime <= :endDate\n                    ORDER BY s.startTime DESC\n                \"\"\";\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"startDate\", startDate);\n        query.setParameter(\"endDate\", endDate);\n        query.setMaxResults(10); // Limit to 10 recent activities\n        List<com.fuacs.backend.entity.Slot> slots = query.getResultList();\n        List<RecentActivitySlotDTO> res = new ArrayList<>();\n        for (var s : slots) {\n            RecentActivitySlotDTO dto = new RecentActivitySlotDTO();\n            dto.setId(s.getId());\n            dto.setTitle(s.getTitle());\n            dto.setStartTime(s.getStartTime());\n            dto.setEndTime(s.getEndTime());\n\n            // Set activity type based on whether slot has ended and has attendance records\n            boolean hasAttendanceRecords = !s.getAttendanceRecords().isEmpty();\n            boolean hasEnded = s.getEndTime().isBefore(LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\")));\n            dto.setActivityType(hasEnded && hasAttendanceRecords ? \"finalized\" : \"pending\");\n\n            if (s.getAcademicClass() != null) {\n                var c = s.getAcademicClass();\n                dto.setClassObj(new com.fuacs.backend.dto.response.ClassDTO(c.getId(), c.getCode()));\n                if (c.getSubject() != null) {\n                    var sub = c.getSubject();\n                    dto.setSubject(new com.fuacs.backend.dto.response.SubjectDTO(sub.getId(), sub.getName(), sub.getCode()));\n                }\n            }\n            res.add(dto);\n        }\n        return res;\n    }\n\n    @Override\n    public List<TodaySlotDTO> findTodaySlotsBySemester(Integer lecturerId, Short semesterId, LocalDateTime startOfDay, LocalDateTime endOfDay) {\n        String jpql = \"\"\"\n                    SELECT s\n                    FROM Slot s\n                    LEFT JOIN FETCH s.room r\n                    LEFT JOIN FETCH s.academicClass c\n                    LEFT JOIN FETCH c.subject sub\n                    LEFT JOIN FETCH c.semester classSem\n                    LEFT JOIN FETCH s.semester independentSem\n                    WHERE s.staff.id = :lecturerId\n                      AND s.startTime >= :startOfDay\n                      AND s.startTime <= :endOfDay\n                      AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                    ORDER BY s.startTime ASC\n                \"\"\";\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"semesterId\", semesterId);\n        query.setParameter(\"startOfDay\", startOfDay);\n        query.setParameter(\"endOfDay\", endOfDay);\n        List<com.fuacs.backend.entity.Slot> slots = query.getResultList();\n        List<TodaySlotDTO> res = new ArrayList<>();\n        for (var s : slots) {\n            TodaySlotDTO dto = new TodaySlotDTO();\n            dto.setId(s.getId());\n            dto.setTitle(s.getTitle());\n            dto.setStartTime(s.getStartTime());\n            dto.setEndTime(s.getEndTime());\n            if (s.getRoom() != null) {\n                dto.setRoom(new com.fuacs.backend.dto.response.RoomDTO(s.getRoom().getId(), s.getRoom().getName(), s.getRoom().getLocation()));\n            }\n            if (s.getAcademicClass() != null) {\n                var c = s.getAcademicClass();\n                dto.setClassObj(new com.fuacs.backend.dto.response.ClassDTO(c.getId(), c.getCode()));\n                if (c.getSubject() != null) {\n                    var sub = c.getSubject();\n                    dto.setSubject(new com.fuacs.backend.dto.response.SubjectDTO(sub.getId(), sub.getName(), sub.getCode()));\n                }\n            }\n            res.add(dto);\n        }\n        return res;\n    }\n\n    @Override\n    public List<RecentActivitySlotDTO> findRecentActivitySlotsBySemester(Integer lecturerId, Short semesterId, LocalDateTime startDate, LocalDateTime endDate) {\n        String jpql = \"\"\"\n                    SELECT s\n                    FROM Slot s\n                    LEFT JOIN FETCH s.academicClass c\n                    LEFT JOIN FETCH c.subject sub\n                    LEFT JOIN FETCH c.semester classSem\n                    LEFT JOIN FETCH s.semester independentSem\n                    WHERE s.staff.id = :lecturerId\n                      AND s.startTime >= :startDate\n                      AND s.startTime <= :endDate\n                      AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                    ORDER BY s.startTime DESC\n                \"\"\";\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"semesterId\", semesterId);\n        query.setParameter(\"startDate\", startDate);\n        query.setParameter(\"endDate\", endDate);\n        query.setMaxResults(10); // Limit to 10 recent activities\n        List<com.fuacs.backend.entity.Slot> slots = query.getResultList();\n        List<RecentActivitySlotDTO> res = new ArrayList<>();\n        for (var s : slots) {\n            RecentActivitySlotDTO dto = new RecentActivitySlotDTO();\n            dto.setId(s.getId());\n            dto.setTitle(s.getTitle());\n            dto.setStartTime(s.getStartTime());\n            dto.setEndTime(s.getEndTime());\n\n            // Set activity type based on whether slot has ended and has attendance records\n            boolean hasAttendanceRecords = !s.getAttendanceRecords().isEmpty();\n            boolean hasEnded = s.getEndTime().isBefore(LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\")));\n            dto.setActivityType(hasEnded && hasAttendanceRecords ? \"finalized\" : \"pending\");\n\n            if (s.getAcademicClass() != null) {\n                var c = s.getAcademicClass();\n                dto.setClassObj(new com.fuacs.backend.dto.response.ClassDTO(c.getId(), c.getCode()));\n                if (c.getSubject() != null) {\n                    var sub = c.getSubject();\n                    dto.setSubject(new com.fuacs.backend.dto.response.SubjectDTO(sub.getId(), sub.getName(), sub.getCode()));\n                }\n            }\n            res.add(dto);\n        }\n        return res;\n    }\n\n    @Override\n    public AttendanceStatsDTO getAttendanceStats(Integer slotId) {\n        String catJpql = \"SELECT s.slotCategory FROM Slot s WHERE s.id = :slotId\";\n        TypedQuery<com.fuacs.backend.constant.enums.SlotCategory> catQ = em.createQuery(catJpql, com.fuacs.backend.constant.enums.SlotCategory.class);\n        catQ.setParameter(\"slotId\", slotId);\n        com.fuacs.backend.constant.enums.SlotCategory category = catQ.getSingleResult();\n        if (category == com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM) {\n            return getExamAttendanceStats(slotId);\n        } else {\n            return getRegularAttendanceStats(slotId);\n        }\n    }\n\n    private AttendanceStatsDTO getRegularAttendanceStats(Integer slotId) {\n        String jpql = \"\"\"\n                    SELECT \n                        COUNT(e.id) as total,\n                        SUM(CASE WHEN ar.status = 'present' THEN 1 ELSE 0 END) as present,\n                        SUM(CASE WHEN ar.status = 'absent' THEN 1 ELSE 0 END) as absent,\n                        SUM(CASE WHEN ar.id IS NULL OR ar.status = 'not_yet' THEN 1 ELSE 0 END) as notYet\n                    FROM Enrollment e\n                    JOIN e.academicClass c\n                    JOIN Slot s ON s.academicClass.id = c.id\n                    LEFT JOIN AttendanceRecord ar ON ar.slot.id = s.id AND ar.student.id = e.student.id\n                    WHERE s.id = :slotId\n                      AND e.isEnrolled = true\n                \"\"\";\n        TypedQuery<Tuple> q = em.createQuery(jpql, Tuple.class);\n        q.setParameter(\"slotId\", slotId);\n        Tuple t = q.getSingleResult();\n        int total = t.get(0) == null ? 0 : ((Number) t.get(0)).intValue();\n        int present = t.get(1) == null ? 0 : ((Number) t.get(1)).intValue();\n        int absent = t.get(2) == null ? 0 : ((Number) t.get(2)).intValue();\n        int notYet = t.get(3) == null ? 0 : ((Number) t.get(3)).intValue();\n        return new AttendanceStatsDTO(total, present, absent, notYet);\n    }\n\n    private AttendanceStatsDTO getExamAttendanceStats(Integer slotId) {\n        // Count participants and LEFT JOIN with attendance records\n        // Students without attendance records are counted as \"not_yet\"\n        String jpql = \"\"\"\n                    SELECT\n                        COUNT(DISTINCT esp.id) as total,\n                        SUM(CASE WHEN ea.status = com.fuacs.backend.constant.enums.AttendanceStatus.PRESENT THEN 1 ELSE 0 END) as present,\n                        SUM(CASE WHEN ea.status = com.fuacs.backend.constant.enums.AttendanceStatus.ABSENT THEN 1 ELSE 0 END) as absent,\n                        SUM(CASE WHEN ea.id IS NULL OR ea.status = com.fuacs.backend.constant.enums.AttendanceStatus.NOT_YET THEN 1 ELSE 0 END) as notYet\n                    FROM ExamSlotParticipant esp\n                    JOIN esp.examSlotSubject ess\n                    LEFT JOIN ExamAttendance ea ON ea.slot.id = ess.slot.id AND ea.student.id = esp.studentUser.id\n                    WHERE ess.slot.id = :slotId\n                      AND esp.isEnrolled = true\n                \"\"\";\n        TypedQuery<Tuple> q = em.createQuery(jpql, Tuple.class);\n        q.setParameter(\"slotId\", slotId);\n        Tuple t = q.getSingleResult();\n        int total = t.get(0) == null ? 0 : ((Number) t.get(0)).intValue();\n        int present = t.get(1) == null ? 0 : ((Number) t.get(1)).intValue();\n        int absent = t.get(2) == null ? 0 : ((Number) t.get(2)).intValue();\n        int notYet = t.get(3) == null ? 0 : ((Number) t.get(3)).intValue();\n        return new AttendanceStatsDTO(total, present, absent, notYet);\n    }\n\n    private Long countByClassId(SlotSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(DISTINCT s.id) FROM Slot s \" +\n                \"LEFT JOIN s.room r \" +\n                \"LEFT JOIN s.staff u \" +\n                \"LEFT JOIN s.academicClass c \" +\n                \"LEFT JOIN c.subject sub \" +\n                \"LEFT JOIN c.semester classSem \" +\n                \"LEFT JOIN s.semester independentSem\");\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public List<SlotDTO> searchByClassId(Short classId, SlotSearchRequest request) {\n        request.setClassId(classId);\n        return searchByClassId(request);\n    }\n\n    @Override\n    public Long countByClassId(Short classId, SlotSearchRequest request) {\n        request.setClassId(classId);\n        return countByClassId(request);\n    }\n\n    @Override\n    public List<SlotDTO> searchByRoomId(Short roomId, SlotSearchRequest request) {\n        return List.of();\n    }\n\n    @Override\n    public Long countByRoomId(Short roomId, SlotSearchRequest request) {\n        return 0L;\n    }\n\n    @Override\n    public boolean existsByRoomAndTimeRange(Short roomId, LocalDateTime startTime, LocalDateTime endTime,\n                                            Integer excludeId) {\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT COUNT(s) > 0 FROM Slot s WHERE s.room.id = :roomId \" +\n                        \"AND ((s.startTime < :endTime AND s.endTime > :startTime))\");\n\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"roomId\", roomId);\n        params.put(\"startTime\", startTime);\n        params.put(\"endTime\", endTime);\n\n        if (excludeId != null) {\n            jpql.append(\" AND s.id != :excludeId\");\n            params.put(\"excludeId\", excludeId);\n        }\n\n        TypedQuery<Boolean> query = em.createQuery(jpql.toString(), Boolean.class);\n        params.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public boolean existsByStaffAndTimeRange(Integer staffUserId, LocalDateTime startTime, LocalDateTime endTime,\n                                             Integer excludeId) {\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT COUNT(s) > 0 FROM Slot s WHERE s.staff.id = :staffUserId \" +\n                        \"AND ((s.startTime < :endTime AND s.endTime > :startTime))\");\n\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"staffUserId\", staffUserId);\n        params.put(\"startTime\", startTime);\n        params.put(\"endTime\", endTime);\n\n        if (excludeId != null) {\n            jpql.append(\" AND s.id != :excludeId\");\n            params.put(\"excludeId\", excludeId);\n        }\n\n        TypedQuery<Boolean> query = em.createQuery(jpql.toString(), Boolean.class);\n        params.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public Long countAttendanceRecordsBySlotId(Integer slotId) {\n        TypedQuery<Long> query = em.createQuery(\n                \"SELECT COUNT(ar) FROM AttendanceRecord ar WHERE ar.slot.id = :slotId\", Long.class);\n        query.setParameter(\"slotId\", slotId);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public Long countExamAttendanceRecordsBySlotId(Integer slotId) {\n        TypedQuery<Long> query = em.createQuery(\n                \"SELECT COUNT(ea) FROM ExamAttendance ea WHERE ea.slot.id = :slotId\", Long.class);\n        query.setParameter(\"slotId\", slotId);\n        return query.getSingleResult();\n    }\n\n    private String buildWhereClause(Map<String, Object> parameters, SlotSearchRequest request) {\n        List<String> whereClauses = new ArrayList<>();\n\n        if (request.getSlotCategory() != null && !request.getSlotCategory().isEmpty()) {\n            whereClauses.add(\"s.slotCategory IN :slotCategories\");\n            parameters.put(\"slotCategories\", request.getSlotCategory());\n        }\n\n        if (shouldApplyClassFilter(request)) {\n            whereClauses.add(\"s.academicClass.id = :classId\");\n            parameters.put(\"classId\", request.getClassId());\n        }\n\n        if (request.getSubjectId() != null) {\n            // Split logic: LECTURE slots only filter by class subject, EXAM slots filter by both\n            List<SlotCategory> categories = request.getSlotCategory();\n            boolean onlyRegularCategories = categories != null && !categories.isEmpty()\n                    && categories.stream().allMatch(c -> c == SlotCategory.LECTURE || c == SlotCategory.LECTURE_WITH_PT);\n\n            if (onlyRegularCategories) {\n                // For LECTURE/LECTURE_WITH_PT: only filter by class subject (no ess join needed)\n                whereClauses.add(\"sub.id = :subjectId\");\n            } else {\n                // For EXAM or mixed categories: filter SLOTS that have the subject, not filter subjects themselves\n                // Use EXISTS to filter slots without affecting the LEFT JOIN that fetches all subjects\n                whereClauses.add(\"(sub.id = :subjectId OR EXISTS (SELECT 1 FROM ExamSlotSubject ess2 WHERE ess2.slot = s AND ess2.subject.id = :subjectId))\");\n            }\n            parameters.put(\"subjectId\", request.getSubjectId());\n        }\n\n        if (request.getStaffUserId() != null) {\n            whereClauses.add(\"u.id = :staffUserId\");\n            parameters.put(\"staffUserId\", request.getStaffUserId());\n        }\n\n        if (request.getStudentUserId() != null) {\n            // Determine which enrollment table to filter based on slot categories\n            List<SlotCategory> categories = request.getSlotCategory();\n            boolean onlyRegularCategories = categories != null && !categories.isEmpty()\n                    && categories.stream().allMatch(c -> c == SlotCategory.LECTURE || c == SlotCategory.LECTURE_WITH_PT)\n                    && request.getSubjectId() == null\n                    && !StringUtils.hasText(request.getSearch());\n\n            if (onlyRegularCategories) {\n                // For LECTURE/LECTURE_WITH_PT only: filter by class enrollments\n                whereClauses.add(\"e.student.id = :studentUserId AND e.isEnrolled = true\");\n            } else {\n                // For FINAL_EXAM, mixed categories, or all types: use category-aware filter\n                // Regular slots (LECTURE/LECTURE_WITH_PT): check class enrollments\n                // Exam slots (FINAL_EXAM): check exam participants\n                whereClauses.add(\"((s.slotCategory IN (com.fuacs.backend.constant.enums.SlotCategory.LECTURE, com.fuacs.backend.constant.enums.SlotCategory.LECTURE_WITH_PT) AND e.student.id = :studentUserId AND e.isEnrolled = true) OR (s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM AND esp.studentUser.id = :studentUserId AND esp.isEnrolled = true))\");\n            }\n            parameters.put(\"studentUserId\", request.getStudentUserId());\n        }\n\n        if (request.getRoomId() != null) {\n            whereClauses.add(\"r.id = :roomId\");\n            parameters.put(\"roomId\", request.getRoomId());\n        }\n\n        if (request.getSemesterId() != null) {\n            // This clause now correctly filters on the single, coalesced semester ID\n            whereClauses.add(\"(classSem.id = :semesterId OR independentSem.id = :semesterId)\");\n            parameters.put(\"semesterId\", request.getSemesterId());\n        }\n\n        if (request.getActive() != null) {\n            whereClauses.add(\"s.isActive = :isActive\");\n            parameters.put(\"isActive\", request.getActive());\n        }\n\n        if (request.getStartTimeFrom() != null) {\n            LocalDateTime startOfDay = request.getStartTimeFrom().atStartOfDay();\n            whereClauses.add(\"s.startTime >= :startTimeFrom\");\n            parameters.put(\"startTimeFrom\", startOfDay);\n        }\n\n        if (request.getStartTimeTo() != null) {\n            LocalDateTime endOfDay = request.getStartTimeTo().atTime(23, 59, 59);\n            whereClauses.add(\"s.startTime <= :startTimeTo\");\n            parameters.put(\"startTimeTo\", endOfDay);\n        }\n\n        String search = request.getSearch();\n        if (StringUtils.hasText(search)) {\n            // Added exam subject name/code to the search\n            whereClauses.add(\"(LOWER(s.title) LIKE :search OR LOWER(s.description) LIKE :search OR \" +\n                    \"LOWER(r.name) LIKE :search OR LOWER(u.fullName) LIKE :search OR \" +\n                    \"LOWER(c.code) LIKE :search OR LOWER(sub.name) LIKE :search OR \" +\n                    \"LOWER(sub.code) LIKE :search OR LOWER(ess.subject.name) LIKE :search OR \" +\n                    \"LOWER(ess.subject.code) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", whereClauses);\n    }\n\n    static boolean shouldApplyClassFilter(SlotSearchRequest request) {\n        if (request.getClassId() == null) {\n            return false;\n        }\n        List<SlotCategory> cats = request.getSlotCategory();\n        return cats == null || cats.isEmpty() || cats.stream()\n                .anyMatch(c -> c == SlotCategory.LECTURE || c == SlotCategory.LECTURE_WITH_PT);\n    }\n\n    // This filter is now redundant because the main semesterId filter handles it\n    // But we can keep it for clarity if you want.\n    static boolean shouldApplySemesterFilter(SlotSearchRequest request) {\n        return request.getSemesterId() != null;\n    }\n\n    @Override\n    public List<com.fuacs.backend.dto.response.SlotRosterItemDTO> getSlotRoster(Integer slotId) {\n        // First, get slot info to determine category\n        TypedQuery<SlotCategory> categoryQuery = em.createQuery(\n                \"SELECT s.slotCategory FROM Slot s WHERE s.id = :slotId\", SlotCategory.class);\n        categoryQuery.setParameter(\"slotId\", slotId);\n        SlotCategory slotCategory = categoryQuery.getSingleResult();\n\n        if (slotCategory == SlotCategory.FINAL_EXAM) {\n            return getRosterForFinalExam(slotId);\n        } else {\n            return getRosterForLectureSlots(slotId, slotCategory);\n        }\n    }\n\n    private List<com.fuacs.backend.dto.response.SlotRosterItemDTO> getRosterForLectureSlots(Integer slotId, SlotCategory slotCategory) {\n        // Get class_id from slot\n        TypedQuery<Short> classIdQuery = em.createQuery(\n                \"SELECT s.academicClass.id FROM Slot s WHERE s.id = :slotId\", Short.class);\n        classIdQuery.setParameter(\"slotId\", slotId);\n        Short classId = classIdQuery.getSingleResult();\n\n        String jpql = \"\"\"\n                SELECT\n                    u.id AS studentUserId,\n                    u.fullName AS studentFullName,\n                    u.email AS email,\n                    sp.rollNumber AS rollNumber,\n                    sp.baseUrl AS avatarUrl,\n                    sub.id AS subjectId,\n                    sub.name AS subjectName,\n                    sub.code AS subjectCode,\n                    ar.id AS regularRecordId,\n                    ar.status AS regularStatus,\n                    ar.method AS regularMethod,\n                    rae.imageUrl AS regularEvidenceUrl,\n                    ar.remark AS regularRemark,\n                    ar.needsReview AS regularNeedsReview,\n                    ea.id AS examRecordId,\n                    ea.status AS examStatus,\n                    ea.method AS examMethod,\n                    eae.imageUrl AS examEvidenceUrl,\n                    ea.remark AS examRemark,\n                    ea.needsReview AS examNeedsReview\n                FROM Enrollment e\n                JOIN e.student u\n                JOIN e.academicClass c\n                JOIN c.subject sub\n                LEFT JOIN StudentProfile sp ON sp.user.id = u.id\n                LEFT JOIN AttendanceRecord ar ON ar.slot.id = :slotId AND ar.student.id = u.id\n                LEFT JOIN RegularAttendanceEvidence rae ON rae.attendanceRecord.id = ar.id\n                LEFT JOIN ExamAttendance ea ON ea.slot.id = :slotId AND ea.student.id = u.id\n                LEFT JOIN ExamAttendanceEvidence eae ON eae.examAttendance.id = ea.id\n                WHERE e.academicClass.id = :classId\n                  AND e.isEnrolled = true\n                  AND u.isActive = true\n                ORDER BY sp.rollNumber ASC\n                \"\"\";\n\n        TypedQuery<Tuple> query = em.createQuery(jpql, Tuple.class);\n        query.setParameter(\"slotId\", slotId);\n        query.setParameter(\"classId\", classId);\n        List<Tuple> tuples = query.getResultList();\n\n        List<com.fuacs.backend.dto.response.SlotRosterItemDTO> results = new ArrayList<>();\n        for (Tuple t : tuples) {\n            // Student\n            com.fuacs.backend.dto.response.SlotRosterStudentDTO student = new com.fuacs.backend.dto.response.SlotRosterStudentDTO(\n                    t.get(\"studentUserId\", Integer.class),\n                    t.get(\"studentFullName\", String.class),\n                    t.get(\"rollNumber\", String.class),\n                    t.get(\"email\", String.class),\n                    t.get(\"avatarUrl\", String.class)\n            );\n\n            // Subject (from class)\n            com.fuacs.backend.dto.response.SlotRosterSubjectDTO subject = null;\n            if (slotCategory == SlotCategory.FINAL_EXAM) {\n                // For FINAL_EXAM, subject should be null (handled in other method)\n                subject = null;\n            } else {\n                subject = new com.fuacs.backend.dto.response.SlotRosterSubjectDTO(\n                        t.get(\"subjectId\", Short.class),\n                        t.get(\"subjectName\", String.class),\n                        t.get(\"subjectCode\", String.class)\n                );\n            }\n\n            // Regular Attendance\n            com.fuacs.backend.dto.response.SlotRosterAttendanceDTO regularAttendance = null;\n            if (slotCategory != SlotCategory.FINAL_EXAM && t.get(\"regularRecordId\") != null) {\n                regularAttendance = new com.fuacs.backend.dto.response.SlotRosterAttendanceDTO(\n                        t.get(\"regularRecordId\", Long.class),\n                        t.get(\"regularStatus\") != null ? t.get(\"regularStatus\").toString().toLowerCase() : null,\n                        t.get(\"regularMethod\") != null ? t.get(\"regularMethod\").toString().toLowerCase() : null,\n                        t.get(\"regularEvidenceUrl\", String.class),\n                        t.get(\"regularRemark\", String.class),\n                        t.get(\"regularNeedsReview\", Boolean.class)\n                );\n            }\n\n            // Exam Attendance\n            com.fuacs.backend.dto.response.SlotRosterAttendanceDTO examAttendance = null;\n            if (slotCategory != SlotCategory.LECTURE && t.get(\"examRecordId\") != null) {\n                examAttendance = new com.fuacs.backend.dto.response.SlotRosterAttendanceDTO(\n                        t.get(\"examRecordId\", Long.class),\n                        t.get(\"examStatus\") != null ? t.get(\"examStatus\").toString().toLowerCase() : null,\n                        t.get(\"examMethod\") != null ? t.get(\"examMethod\").toString().toLowerCase() : null,\n                        t.get(\"examEvidenceUrl\", String.class),\n                        t.get(\"examRemark\", String.class),\n                        t.get(\"examNeedsReview\", Boolean.class)\n                );\n            }\n\n            com.fuacs.backend.dto.response.SlotRosterItemDTO item = new com.fuacs.backend.dto.response.SlotRosterItemDTO(\n                    student, subject, regularAttendance, examAttendance\n            );\n            results.add(item);\n        }\n\n        return results;\n    }\n\n    private List<com.fuacs.backend.dto.response.SlotRosterItemDTO> getRosterForFinalExam(Integer slotId) {\n        String jpql = \"\"\"\n                SELECT\n                    u.id AS studentUserId,\n                    u.fullName AS studentFullName,\n                    u.email AS email,\n                    sp.rollNumber AS rollNumber,\n                    sp.baseUrl AS avatarUrl,\n                    sub.id AS subjectId,\n                    sub.name AS subjectName,\n                    sub.code AS subjectCode,\n                    ea.id AS examRecordId,\n                    ea.status AS examStatus,\n                    ea.method AS examMethod,\n                    eae.imageUrl AS examEvidenceUrl,\n                    ea.remark AS examRemark,\n                    ea.needsReview AS examNeedsReview\n                FROM ExamSlotParticipant esp\n                JOIN esp.examSlotSubject ess\n                JOIN ess.subject sub\n                JOIN esp.studentUser u\n                LEFT JOIN StudentProfile sp ON sp.user.id = u.id\n                LEFT JOIN ExamAttendance ea ON ea.slot.id = :slotId AND ea.student.id = u.id\n                LEFT JOIN ExamAttendanceEvidence eae ON eae.examAttendance.id = ea.id\n                WHERE ess.slot.id = :slotId\n                  AND esp.isEnrolled = true\n                  AND u.isActive = true\n                ORDER BY sp.rollNumber ASC, sub.code ASC\n                \"\"\";\n\n        TypedQuery<Tuple> query = em.createQuery(jpql, Tuple.class);\n        query.setParameter(\"slotId\", slotId);\n        List<Tuple> tuples = query.getResultList();\n\n        List<com.fuacs.backend.dto.response.SlotRosterItemDTO> results = new ArrayList<>();\n        for (Tuple t : tuples) {\n            // Student\n            com.fuacs.backend.dto.response.SlotRosterStudentDTO student = new com.fuacs.backend.dto.response.SlotRosterStudentDTO(\n                    t.get(\"studentUserId\", Integer.class),\n                    t.get(\"studentFullName\", String.class),\n                    t.get(\"rollNumber\", String.class),\n                    t.get(\"email\", String.class),\n                    t.get(\"avatarUrl\", String.class)\n            );\n\n            // Subject (from exam_slot_subjects)\n            com.fuacs.backend.dto.response.SlotRosterSubjectDTO subject = new com.fuacs.backend.dto.response.SlotRosterSubjectDTO(\n                    t.get(\"subjectId\", Short.class),\n                    t.get(\"subjectName\", String.class),\n                    t.get(\"subjectCode\", String.class)\n            );\n\n            // No regular attendance for FINAL_EXAM\n            com.fuacs.backend.dto.response.SlotRosterAttendanceDTO regularAttendance = null;\n\n            // Exam Attendance\n            com.fuacs.backend.dto.response.SlotRosterAttendanceDTO examAttendance = null;\n            if (t.get(\"examRecordId\") != null) {\n                examAttendance = new com.fuacs.backend.dto.response.SlotRosterAttendanceDTO(\n                        t.get(\"examRecordId\", Long.class),\n                        t.get(\"examStatus\") != null ? t.get(\"examStatus\").toString().toLowerCase() : null,\n                        t.get(\"examMethod\") != null ? t.get(\"examMethod\").toString().toLowerCase() : null,\n                        t.get(\"examEvidenceUrl\", String.class),\n                        t.get(\"examRemark\", String.class),\n                        t.get(\"examNeedsReview\", Boolean.class)\n                );\n            }\n\n            com.fuacs.backend.dto.response.SlotRosterItemDTO item = new com.fuacs.backend.dto.response.SlotRosterItemDTO(\n                    student, subject, regularAttendance, examAttendance\n            );\n            results.add(item);\n        }\n\n        return results;\n    }\n\n    @Override\n    public List<SlotDTO> searchByStudentId(SlotSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        String jpql;\n        List<SlotCategory> categories = request.getSlotCategory();\n\n        boolean onlyRegularCategories = categories != null && !categories.isEmpty()\n                && categories.stream().allMatch(c -> c == SlotCategory.LECTURE || c == SlotCategory.LECTURE_WITH_PT)\n                && request.getSubjectId() == null\n                && !StringUtils.hasText(request.getSearch());\n\n        if (onlyRegularCategories) {\n            // Optimized query for LECTURE/LECTURE_WITH_PT only.\n            // No need to join ExamSlotSubject.\n            jpql = \"\"\"\n                    SELECT\n                        s.id AS id,\n                        s.title AS title,\n                        s.description AS description,\n                        s.startTime AS startTime,\n                        s.endTime AS endTime,\n                        s.slotCategory AS slotCategory,\n                        r.id AS roomId,\n                        r.name AS roomName,\n                        r.location AS roomLocation,\n                        u.id AS staffId,\n                        u.username AS staffUsername,\n                        u.fullName AS staffFullName,\n                        c.id AS classId,\n                        c.code AS classCode,\n                        sub.id AS subjectId,\n                        sub.name AS subjectName,\n                        sub.code AS subjectCode,\n                        COALESCE(classSem.id, independentSem.id) AS semesterId,\n                        COALESCE(classSem.name, independentSem.name) AS semesterName,\n                        COALESCE(classSem.code, independentSem.code) AS semesterCode,\n                        COUNT(DISTINCT e.id) AS totalStudent,\n                        COUNT(DISTINCT CASE WHEN ar.status = 'present' THEN ar.id END) AS totalPresentStudent,\n                        COUNT(DISTINCT CASE WHEN ar.status = 'absent' THEN ar.id END) AS totalAbsentStudent,\n                        COUNT(DISTINCT CASE WHEN ar.status = 'not_yet' THEN ar.id END) AS totalNotYetStudent,\n                        s.isActive AS isActive,\n                        s.createdAt AS createdAt,\n                        s.updatedAt AS updatedAt,\n                        CAST(null AS string) AS examSubjectName,\n                        CAST(null AS string) AS examSubjectCode,\n                        CAST(null AS short) AS examSubjectId\n                    FROM Slot s\n                    LEFT JOIN s.room r\n                    LEFT JOIN s.staff u\n                    LEFT JOIN s.academicClass c\n                    LEFT JOIN c.subject sub\n                    LEFT JOIN c.semester classSem\n                    LEFT JOIN s.semester independentSem ON s.semester = independentSem\n                    LEFT JOIN c.enrollments e\n                    LEFT JOIN s.attendanceRecords ar\n                    \"\"\"\n                    // Intentionally no LEFT JOIN for ExamSlotSubject\n                    + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause) + \"\"\"\n                         GROUP BY\n                            s.id, s.title, s.description, s.startTime, s.endTime, s.slotCategory,\n                            r.id, r.name, r.location,\n                            u.id, u.username, u.fullName,\n                            c.id, c.code,\n                            sub.id, sub.name, sub.code,\n                            COALESCE(classSem.id, independentSem.id),\n                            COALESCE(classSem.name, independentSem.name),\n                            COALESCE(classSem.code, independentSem.code),\n                            s.isActive, s.createdAt, s.updatedAt\n                    \"\"\";\n        } else {\n            // This handles FINAL_EXAM, mixed categories, or null (all types).\n            // Requires joining both ExamSlotSubject AND class enrollments for universal support\n            jpql = \"SELECT s.id AS id,\\n\" +\n                    \"                     s.title AS title,\\n\" +\n                    \"                     s.description AS description,\\n\" +\n                    \"                     s.startTime AS startTime,\\n\" +\n                    \"                     s.endTime AS endTime,\\n\" +\n                    \"                     s.slotCategory AS slotCategory,\\n\" +\n                    \"                     r.id AS roomId,\\n\" +\n                    \"                     r.name AS roomName,\\n\" +\n                    \"                     r.location AS roomLocation,\\n\" +\n                    \"                     u.id AS staffId,\\n\" +\n                    \"                     u.username AS staffUsername,\\n\" +\n                    \"                     u.fullName AS staffFullName,\\n\" +\n                    \"                     COALESCE(sub.id, classSub.id) AS subjectId,\\n\" +\n                    \"                     COALESCE(sub.name, classSub.name) AS subjectName,\\n\" +\n                    \"                     COALESCE(sub.code, classSub.code) AS subjectCode,\\n\" +\n                    \"                     COALESCE(classSem.id, independentSem.id) AS semesterId,\\n\" +\n                    \"                     COALESCE(classSem.name, independentSem.name) AS semesterName,\\n\" +\n                    \"                     COALESCE(classSem.code, independentSem.code) AS semesterCode,\\n\" +\n                    \"                     s.isActive AS isActive,\\n\" +\n                    \"                     s.createdAt AS createdAt,\\n\" +\n                    \"                     s.updatedAt AS updatedAt,\\n\" +\n                    \"                     ess.subject.name AS examSubjectName,\\n\" +\n                    \"                     ess.subject.code AS examSubjectCode,\\n\" +\n                    \"                     ess.subject.id AS examSubjectId\\n\" +\n                    \"                 FROM Slot s\\n\" +\n                    \"                 LEFT JOIN s.room r\\n\" +\n                    \"                 LEFT JOIN s.staff u\\n\" +\n                    \"                 LEFT JOIN s.academicClass c\\n\" +\n                    \"                 LEFT JOIN c.subject classSub\\n\" +\n                    \"                 LEFT JOIN c.semester classSem\\n\" +\n                    \"                 LEFT JOIN s.semester independentSem ON s.semester = independentSem\\n\" +\n                    \"                 LEFT JOIN c.enrollments e\\n\" +\n                    \"                 LEFT JOIN ExamSlotSubject ess ON ess.slot = s\\n\" +\n                    \"                 LEFT JOIN ExamSlotParticipant esp on esp.examSlotSubject = ess\\n\" +\n                    \"                 LEFT JOIN Subject sub ON ess.subject.id = sub.id\\n\" + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause) + \"\"\"\n                     GROUP BY\n                        s.id, s.title, s.description, s.startTime, s.endTime, s.slotCategory,\n                        r.id, r.name, r.location,\n                        u.id, u.username, u.fullName,\n                        COALESCE(sub.id, classSub.id),\n                        COALESCE(sub.name, classSub.name),\n                        COALESCE(sub.code, classSub.code),\n                        COALESCE(classSem.id, independentSem.id),\n                        COALESCE(classSem.name, independentSem.name),\n                        COALESCE(classSem.code, independentSem.code),\n                        s.isActive, s.createdAt, s.updatedAt,\n                        ess.subject.name, ess.subject.code, ess.subject.id\n                    \"\"\";\n        }\n\n        // Add ORDER BY clause for consistent ordering\n        String sortBy = request.getSortBy() != null ? request.getSortBy() : \"startTime\";\n        String sortField = SORTABLE_FIELDS.getOrDefault(sortBy, \"s.startTime\");\n        String sortDirection = \"desc\".equalsIgnoreCase(request.getSort()) ? \"DESC\" : \"ASC\";\n        jpql += \" ORDER BY \" + sortField + \" \" + sortDirection;\n\n        var tupleQuery = em.createQuery(jpql, Tuple.class);\n        parameters.forEach(tupleQuery::setParameter);\n\n        // CRITICAL FIX: Do NOT apply pagination here - fetch all matching rows first\n        // tupleQuery.setFirstResult(request.getPage() * request.getPageSize());\n        // tupleQuery.setMaxResults(request.getPageSize());\n\n        List<Tuple> tuples = tupleQuery.getResultList();\n        Map<Integer, SlotDTO> slotMap = new LinkedHashMap<>();\n\n        if (onlyRegularCategories) {\n            // --------------------------------------------\n            // 1️⃣ Regular slots (LECTURE / LECTURE_WITH_PT)\n            // --------------------------------------------\n            for (Tuple t : tuples) {\n                Integer id = t.get(\"id\", Integer.class);\n                SlotDTO dto = slotMap.get(id);\n                if (dto == null) {\n\n                    SlotCategory slotCategory = t.get(\"slotCategory\", SlotCategory.class);\n\n                    // --- Semester (COALESCE từ classSem hoặc independentSem) ---\n                    SemesterDTO semester = null;\n                    if (t.get(\"semesterId\") != null) {\n                        semester = new SemesterDTO(\n                                t.get(\"semesterId\", Short.class),\n                                t.get(\"semesterName\", String.class),\n                                t.get(\"semesterCode\", String.class));\n                    }\n\n                    // --- Subject (của lớp học) ---\n                    SubjectDTO subject = null;\n                    if (t.get(\"subjectId\") != null) {\n                        subject = new SubjectDTO(\n                                t.get(\"subjectId\", Short.class),\n                                t.get(\"subjectName\", String.class),\n                                t.get(\"subjectCode\", String.class));\n                    }\n\n                    // --- Class ---\n                    ClassDTO classObj = null;\n                    if (t.get(\"classId\") != null) {\n                        classObj = new ClassDTO(\n                                t.get(\"classId\", Short.class),\n                                t.get(\"classCode\", String.class),\n                                subject,\n                                semester);\n                    }\n\n                    // --- Staff (UserDTO) ---\n                    UserDTO staffUser = null;\n                    if (t.get(\"staffId\") != null) {\n                        staffUser = new UserDTO(\n                                t.get(\"staffId\", Integer.class),\n                                t.get(\"staffUsername\", String.class),\n                                t.get(\"staffFullName\", String.class));\n                    }\n\n                    // --- Room ---\n                    RoomDTO room = null;\n                    if (t.get(\"roomId\") != null) {\n                        room = new RoomDTO(\n                                t.get(\"roomId\", Short.class),\n                                t.get(\"roomName\", String.class),\n                                t.get(\"roomLocation\", String.class));\n                    }\n\n                    // --- Attendance counts ---\n                    int totalStudent = Optional.ofNullable(t.get(\"totalStudent\", Long.class)).orElse(0L).intValue();\n                    int totalPresent = Optional.ofNullable(t.get(\"totalPresentStudent\", Long.class)).orElse(0L).intValue();\n                    int totalAbsent = Optional.ofNullable(t.get(\"totalAbsentStudent\", Long.class)).orElse(0L).intValue();\n                    int totalNotYet = Optional.ofNullable(t.get(\"totalNotYetStudent\", Long.class)).orElse(0L).intValue();\n\n                    dto = new SlotDTO(\n                            t.get(\"isActive\", Boolean.class),\n                            t.get(\"createdAt\", Instant.class),\n                            t.get(\"updatedAt\", Instant.class),\n                            id,\n                            t.get(\"title\", String.class),\n                            t.get(\"description\", String.class),\n                            t.get(\"startTime\", LocalDateTime.class),\n                            t.get(\"endTime\", LocalDateTime.class),\n                            slotCategory,\n                            totalNotYet,\n                            totalAbsent,\n                            totalPresent,\n                            totalStudent,\n                            classObj,\n                            staffUser,\n                            room);\n\n                    // Regular slots: subjects từ class subject\n                    dto.setExamSubjects(subject != null ? List.of(subject) : List.of());\n                    slotMap.put(id, dto);\n                }\n            }\n\n        } else {\n            // -----------------------------\n            // 2️⃣ Exam slots (FINAL_EXAM)\n            // -----------------------------\n            for (Tuple t : tuples) {\n                Integer id = t.get(\"id\", Integer.class);\n                SlotDTO dto = slotMap.get(id);\n\n                if (dto == null) {\n                    SlotCategory slotCategory = t.get(\"slotCategory\", SlotCategory.class);\n\n                    // --- Semester ---\n                    SemesterDTO semester = null;\n                    if (t.get(\"semesterId\") != null) {\n                        semester = new SemesterDTO(\n                                t.get(\"semesterId\", Short.class),\n                                t.get(\"semesterName\", String.class),\n                                t.get(\"semesterCode\", String.class));\n                    }\n\n                    // --- Room ---\n                    RoomDTO room = null;\n                    if (t.get(\"roomId\") != null) {\n                        room = new RoomDTO(\n                                t.get(\"roomId\", Short.class),\n                                t.get(\"roomName\", String.class),\n                                t.get(\"roomLocation\", String.class));\n                    }\n\n                    // --- Staff --- (now included in query for student schedule)\n                    UserDTO staffUser = null;\n                    if (t.get(\"staffId\") != null) {\n                        staffUser = new UserDTO(\n                                t.get(\"staffId\", Integer.class),\n                                t.get(\"staffUsername\", String.class),\n                                t.get(\"staffFullName\", String.class));\n                    }\n\n                    dto = new SlotDTO(\n                            t.get(\"isActive\", Boolean.class),\n                            t.get(\"createdAt\", Instant.class),\n                            t.get(\"updatedAt\", Instant.class),\n                            id,\n                            t.get(\"title\", String.class),\n                            t.get(\"description\", String.class),\n                            t.get(\"startTime\", LocalDateTime.class),\n                            t.get(\"endTime\", LocalDateTime.class),\n                            slotCategory,\n                            0, 0, 0, 0, // không có thống kê điểm danh\n                            null, // class\n                            staffUser,\n                            room);\n\n                    dto.setSemester(semester);\n                    dto.setExamSubjects(new ArrayList<>());\n                    slotMap.put(id, dto);\n\n                    // --- For LECTURE/LECTURE_WITH_PT: add class subject ---\n                    if (slotCategory == SlotCategory.LECTURE || slotCategory == SlotCategory.LECTURE_WITH_PT) {\n                        Short classSubjectId = t.get(\"subjectId\", Short.class);\n                        if (classSubjectId != null) {\n                            SubjectDTO classSubject = new SubjectDTO(\n                                    classSubjectId,\n                                    t.get(\"subjectName\", String.class),\n                                    t.get(\"subjectCode\", String.class));\n                            dto.getExamSubjects().add(classSubject);\n                        }\n                    }\n                }\n\n                // --- For FINAL_EXAM: add exam subjects ---\n                if (dto.getSlotCategory() == SlotCategory.FINAL_EXAM) {\n                    Short examSubjectId = t.get(\"examSubjectId\", Short.class);\n                    if (examSubjectId != null) {\n                        SubjectDTO examSubject = new SubjectDTO(\n                                examSubjectId,\n                                t.get(\"examSubjectName\", String.class),\n                                t.get(\"examSubjectCode\", String.class));\n\n                        if (dto.getExamSubjects().stream().noneMatch(s -> s.getId().equals(examSubject.getId()))) {\n                            dto.getExamSubjects().add(examSubject);\n                        }\n                    }\n                }\n            }\n        }\n\n        // CRITICAL FIX: Apply pagination AFTER consolidation\n        List<SlotDTO> allSlots = new ArrayList<>(slotMap.values());\n\n        // Calculate pagination boundaries\n        int fromIndex = request.getPage() * request.getPageSize();\n        int toIndex = Math.min(fromIndex + request.getPageSize(), allSlots.size());\n\n        // Return paginated sublist\n        if (fromIndex >= allSlots.size()) {\n            return new ArrayList<>();\n        }\n\n        return allSlots.subList(fromIndex, toIndex);\n    }\n\n\n    @Override\n    public Long countByStudentId(SlotSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        List<SlotCategory> categories = request.getSlotCategory();\n\n        boolean onlyRegularCategories = categories != null && !categories.isEmpty()\n                && categories.stream().allMatch(c -> c == SlotCategory.LECTURE || c == SlotCategory.LECTURE_WITH_PT)\n                && request.getSubjectId() == null\n                && !StringUtils.hasText(request.getSearch());\n\n        String jpql;\n\n        if (onlyRegularCategories) {\n            jpql = \"\"\"\n                    SELECT COUNT(DISTINCT s.id)\n                    FROM Slot s\n                    LEFT JOIN s.room r\n                    LEFT JOIN s.staff u\n                    LEFT JOIN s.academicClass c\n                    LEFT JOIN c.subject sub\n                    LEFT JOIN c.semester classSem\n                    LEFT JOIN s.semester independentSem ON s.semester = independentSem\n                    LEFT JOIN c.enrollments e\n                    LEFT JOIN s.attendanceRecords ar\n                    \"\"\"\n                    + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause);\n\n        } else {\n            jpql = \"\"\"\n                    SELECT COUNT(DISTINCT s.id)\n                    FROM Slot s\n                    LEFT JOIN s.room r\n                    LEFT JOIN s.academicClass c\n                    LEFT JOIN c.subject classSub\n                    LEFT JOIN c.semester classSem\n                    LEFT JOIN s.semester independentSem ON s.semester = independentSem\n                    LEFT JOIN c.enrollments e\n                    LEFT JOIN ExamSlotSubject ess ON ess.slot = s\n                    LEFT JOIN ExamSlotParticipant esp on esp.examSlotSubject = ess\n                    LEFT JOIN Subject sub ON ess.subject.id = sub.id\n                    \"\"\"\n                    + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public List<com.fuacs.backend.entity.Slot> findByClassAndSemesterAndCategory(Short classId, Short semesterId) {\n        String jpql = \"\"\"\n                SELECT s\n                FROM Slot s\n                WHERE s.academicClass.id = :classId\n                  AND s.academicClass.semester.id = :semesterId\n                  AND s.slotCategory IN (com.fuacs.backend.constant.enums.SlotCategory.LECTURE, \n                                        com.fuacs.backend.constant.enums.SlotCategory.LECTURE_WITH_PT)\n                ORDER BY s.startTime ASC\n                \"\"\";\n\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"classId\", classId);\n        query.setParameter(\"semesterId\", semesterId);\n        return query.getResultList();\n    }\n\n    @Override\n    public com.fuacs.backend.entity.Slot findByIdWithRoomAndStaff(Integer slotId) {\n        String jpql = \"\"\"\n            SELECT s FROM Slot s\n            LEFT JOIN FETCH s.room\n            LEFT JOIN FETCH s.staff\n            WHERE s.id = :slotId\n            \"\"\";\n\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"slotId\", slotId);\n\n        List<com.fuacs.backend.entity.Slot> results = query.getResultList();\n        return results.isEmpty() ? null : results.get(0);\n    }\n\n    // Supervisor dashboard methods implementation\n    @Override\n    public com.fuacs.backend.dto.response.SupervisorStatsDTO calculateSupervisorStats(Integer supervisorId, Short semesterId) {\n        // Calculate total exam slots supervised (FINAL_EXAM only)\n        String totalSlotsJpql = \"\"\"\n                SELECT COUNT(s.id)\n                FROM Slot s\n                LEFT JOIN s.academicClass ac\n                LEFT JOIN ac.semester classSem\n                LEFT JOIN s.semester independentSem\n                WHERE s.staff.id = :supervisorId\n                  AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                \"\"\";\n        TypedQuery<Long> totalSlotsQuery = em.createQuery(totalSlotsJpql, Long.class);\n        totalSlotsQuery.setParameter(\"supervisorId\", supervisorId);\n        totalSlotsQuery.setParameter(\"semesterId\", semesterId);\n        Long totalSlotsSupervised = totalSlotsQuery.getSingleResult();\n\n        // Calculate completed exam slots (ended and have exam attendance records)\n        String completedSlotsJpql = \"\"\"\n                SELECT COUNT(s)\n                FROM Slot s\n                LEFT JOIN s.academicClass ac\n                LEFT JOIN s.semester classSem\n                LEFT JOIN s.semester independentSem\n                WHERE s.staff.id = :supervisorId\n                  AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND s.endTime < :now\n                  AND (SELECT COUNT(ea) FROM ExamAttendance ea WHERE ea.slot = s) > 0\n                \"\"\";\n        TypedQuery<Long> completedSlotsQuery = em.createQuery(completedSlotsJpql, Long.class);\n        completedSlotsQuery.setParameter(\"supervisorId\", supervisorId);\n        completedSlotsQuery.setParameter(\"semesterId\", semesterId);\n        completedSlotsQuery.setParameter(\"now\", LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\")));\n        Long completedSlots = completedSlotsQuery.getSingleResult();\n\n        // Calculate upcoming exam slots\n        String upcomingSlotsJpql = \"\"\"\n                SELECT COUNT(s.id)\n                FROM Slot s\n                LEFT JOIN s.academicClass ac\n                LEFT JOIN ac.semester classSem\n                LEFT JOIN s.semester independentSem\n                WHERE s.staff.id = :supervisorId\n                  AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND s.startTime > :now\n                \"\"\";\n        TypedQuery<Long> upcomingSlotsQuery = em.createQuery(upcomingSlotsJpql, Long.class);\n        upcomingSlotsQuery.setParameter(\"supervisorId\", supervisorId);\n        upcomingSlotsQuery.setParameter(\"semesterId\", semesterId);\n        upcomingSlotsQuery.setParameter(\"now\", LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\")));\n        Long upcomingSlots = upcomingSlotsQuery.getSingleResult();\n\n        // Calculate total exam slots (same as totalSlotsSupervised for supervisors)\n        // Keeping this field for backward compatibility, but it's redundant\n        Long totalExamSlots = totalSlotsSupervised;\n\n        // Calculate total exam participants (students taking exams in supervised slots)\n        String studentsJpql = \"\"\"\n                SELECT COUNT(DISTINCT esp.studentUser.id)\n                FROM ExamSlotParticipant esp\n                JOIN esp.examSlotSubject ess\n                JOIN ess.slot s\n                WHERE s.staff.id = :supervisorId\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND s.semester.id = :semesterId\n                  AND esp.isEnrolled = true\n                \"\"\";\n        TypedQuery<Long> studentsQuery = em.createQuery(studentsJpql, Long.class);\n        studentsQuery.setParameter(\"supervisorId\", supervisorId);\n        studentsQuery.setParameter(\"semesterId\", semesterId);\n        Long totalStudentsSupervised = studentsQuery.getSingleResult();\n\n        // Calculate exam attendance rate for supervised exam slots\n        Double examAttendanceRate = calculateSupervisorAverageAttendanceRate(supervisorId, semesterId);\n\n        return new com.fuacs.backend.dto.response.SupervisorStatsDTO(\n                totalExamSlots != null ? totalExamSlots.intValue() : 0,\n                completedSlots != null ? completedSlots.intValue() : 0,\n                upcomingSlots != null ? upcomingSlots.intValue() : 0,\n                examAttendanceRate,\n                totalStudentsSupervised != null ? totalStudentsSupervised.intValue() : 0\n        );\n    }\n\n    private Double calculateSupervisorAverageAttendanceRate(Integer supervisorId, Short semesterId) {\n        // For exam supervisors, calculate attendance rate from ExamAttendance records only\n        String jpql = \"\"\"\n                SELECT\n                    COUNT(ea.id) as totalRecords,\n                    SUM(CASE WHEN ea.status = 'present' THEN 1 ELSE 0 END) as presentCount\n                FROM ExamAttendance ea\n                JOIN ea.slot s\n                WHERE s.staff.id = :supervisorId\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND s.semester.id = :semesterId\n                \"\"\";\n        TypedQuery<Tuple> query = em.createQuery(jpql, Tuple.class);\n        query.setParameter(\"supervisorId\", supervisorId);\n        query.setParameter(\"semesterId\", semesterId);\n        Tuple result = query.getSingleResult();\n\n        long total = result.get(0) == null ? 0L : ((Number) result.get(0)).longValue();\n        long present = result.get(1) == null ? 0L : ((Number) result.get(1)).longValue();\n\n        if (total == 0L) return 0.0;\n        return Math.round((present * 100.0 / total) * 10.0) / 10.0;\n    }\n\n    @Override\n    public com.fuacs.backend.dto.response.SupervisorStatsDTO calculateSupervisorStatsAllSemesters(Integer supervisorId) {\n        // Calculate stats across ALL semesters (FINAL_EXAM only)\n\n        // Calculate total exam slots supervised (all semesters)\n        String totalSlotsJpql = \"\"\"\n                SELECT COUNT(s.id)\n                FROM Slot s\n                WHERE s.staff.id = :supervisorId\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                \"\"\";\n        TypedQuery<Long> totalSlotsQuery = em.createQuery(totalSlotsJpql, Long.class);\n        totalSlotsQuery.setParameter(\"supervisorId\", supervisorId);\n        Long totalSlotsSupervised = totalSlotsQuery.getSingleResult();\n\n        // Calculate completed exam slots (all semesters)\n        String completedSlotsJpql = \"\"\"\n                SELECT COUNT(s)\n                FROM Slot s\n                WHERE s.staff.id = :supervisorId\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND s.endTime < :now\n                  AND (SELECT COUNT(ea) FROM ExamAttendance ea WHERE ea.slot = s) > 0\n                \"\"\";\n        TypedQuery<Long> completedSlotsQuery = em.createQuery(completedSlotsJpql, Long.class);\n        completedSlotsQuery.setParameter(\"supervisorId\", supervisorId);\n        completedSlotsQuery.setParameter(\"now\", LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\")));\n        Long completedSlots = completedSlotsQuery.getSingleResult();\n\n        // Calculate upcoming exam slots (all semesters)\n        String upcomingSlotsJpql = \"\"\"\n                SELECT COUNT(s.id)\n                FROM Slot s\n                WHERE s.staff.id = :supervisorId\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND s.startTime > :now\n                \"\"\";\n        TypedQuery<Long> upcomingSlotsQuery = em.createQuery(upcomingSlotsJpql, Long.class);\n        upcomingSlotsQuery.setParameter(\"supervisorId\", supervisorId);\n        upcomingSlotsQuery.setParameter(\"now\", LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\")));\n        Long upcomingSlots = upcomingSlotsQuery.getSingleResult();\n\n        // Total exam slots (same as totalSlotsSupervised for supervisors)\n        Long totalExamSlots = totalSlotsSupervised;\n\n        // Calculate total exam participants (all semesters)\n        String studentsJpql = \"\"\"\n                SELECT COUNT(DISTINCT esp.studentUser.id)\n                FROM ExamSlotParticipant esp\n                JOIN esp.examSlotSubject ess\n                JOIN ess.slot s\n                WHERE s.staff.id = :supervisorId\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND esp.isEnrolled = true\n                \"\"\";\n        TypedQuery<Long> studentsQuery = em.createQuery(studentsJpql, Long.class);\n        studentsQuery.setParameter(\"supervisorId\", supervisorId);\n        Long totalStudentsSupervised = studentsQuery.getSingleResult();\n\n        // Calculate exam attendance rate (all semesters)\n        Double examAttendanceRate = calculateSupervisorAverageAttendanceRateAllSemesters(supervisorId);\n\n        return new com.fuacs.backend.dto.response.SupervisorStatsDTO(\n                totalExamSlots != null ? totalExamSlots.intValue() : 0,\n                completedSlots != null ? completedSlots.intValue() : 0,\n                upcomingSlots != null ? upcomingSlots.intValue() : 0,\n                examAttendanceRate,\n                totalStudentsSupervised != null ? totalStudentsSupervised.intValue() : 0\n        );\n    }\n\n    private Double calculateSupervisorAverageAttendanceRateAllSemesters(Integer supervisorId) {\n        // For exam supervisors, calculate attendance rate from ExamAttendance records only\n        String jpql = \"\"\"\n                SELECT\n                    COUNT(ea.id) as totalRecords,\n                    SUM(CASE WHEN ea.status = 'present' THEN 1 ELSE 0 END) as presentCount\n                FROM ExamAttendance ea\n                JOIN ea.slot s\n                WHERE s.staff.id = :supervisorId\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                \"\"\";\n        TypedQuery<Tuple> query = em.createQuery(jpql, Tuple.class);\n        query.setParameter(\"supervisorId\", supervisorId);\n        Tuple result = query.getSingleResult();\n\n        long total = result.get(0) == null ? 0L : ((Number) result.get(0)).longValue();\n        long present = result.get(1) == null ? 0L : ((Number) result.get(1)).longValue();\n\n        if (total == 0L) return 0.0;\n        return Math.round((present * 100.0 / total) * 10.0) / 10.0;\n    }\n\n    @Override\n    public List<TodaySlotDTO> findTodaySupervisionSlots(Integer supervisorId, Short semesterId, LocalDateTime startOfDay, LocalDateTime endOfDay) {\n        String jpql = \"\"\"\n                SELECT s\n                FROM Slot s\n                LEFT JOIN FETCH s.room r\n                LEFT JOIN FETCH s.academicClass c\n                LEFT JOIN FETCH c.subject sub\n                LEFT JOIN FETCH c.semester classSem\n                LEFT JOIN FETCH s.semester independentSem\n                WHERE s.staff.id = :supervisorId\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND s.startTime >= :startOfDay\n                  AND s.startTime <= :endOfDay\n                  AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                ORDER BY s.startTime ASC\n                \"\"\";\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"supervisorId\", supervisorId);\n        query.setParameter(\"semesterId\", semesterId);\n        query.setParameter(\"startOfDay\", startOfDay);\n        query.setParameter(\"endOfDay\", endOfDay);\n        List<com.fuacs.backend.entity.Slot> slots = query.getResultList();\n        List<TodaySlotDTO> res = new ArrayList<>();\n        for (var s : slots) {\n            TodaySlotDTO dto = new TodaySlotDTO();\n            dto.setId(s.getId());\n            dto.setTitle(s.getTitle());\n            dto.setStartTime(s.getStartTime());\n            dto.setEndTime(s.getEndTime());\n            if (s.getRoom() != null) {\n                dto.setRoom(new com.fuacs.backend.dto.response.RoomDTO(s.getRoom().getId(), s.getRoom().getName(), s.getRoom().getLocation()));\n            }\n\n            // For FINAL_EXAM slots, get subjects from ExamSlotSubject\n            if (s.getSlotCategory() == SlotCategory.FINAL_EXAM) {\n                String subjectQuery = \"SELECT ess.subject FROM ExamSlotSubject ess WHERE ess.slot.id = :slotId AND ess.isActive = true\";\n                List<com.fuacs.backend.entity.Subject> examSubjects = em.createQuery(subjectQuery, com.fuacs.backend.entity.Subject.class)\n                    .setParameter(\"slotId\", s.getId())\n                    .getResultList();\n\n                if (!examSubjects.isEmpty()) {\n                    List<com.fuacs.backend.dto.response.SubjectDTO> subjects = examSubjects.stream()\n                        .map(subj -> new com.fuacs.backend.dto.response.SubjectDTO(subj.getId(), subj.getName(), subj.getCode()))\n                        .collect(java.util.stream.Collectors.toList());\n                    dto.setSubjects(subjects);\n                }\n            } else if (s.getAcademicClass() != null) {\n                // Fallback for non-FINAL_EXAM slots (if any)\n                var c = s.getAcademicClass();\n                dto.setClassObj(new com.fuacs.backend.dto.response.ClassDTO(c.getId(), c.getCode()));\n                if (c.getSubject() != null) {\n                    var sub = c.getSubject();\n                    dto.setSubject(new com.fuacs.backend.dto.response.SubjectDTO(sub.getId(), sub.getName(), sub.getCode()));\n                }\n            }\n            res.add(dto);\n        }\n        return res;\n    }\n\n    @Override\n    public List<RecentActivitySlotDTO> findRecentSupervisionActivity(Integer supervisorId, Short semesterId, LocalDateTime startDate, LocalDateTime endDate) {\n        String jpql = \"\"\"\n                SELECT s\n                FROM Slot s\n                LEFT JOIN FETCH s.room r\n                LEFT JOIN FETCH s.academicClass c\n                LEFT JOIN FETCH c.subject sub\n                LEFT JOIN FETCH c.semester classSem\n                LEFT JOIN FETCH s.semester independentSem\n                WHERE s.staff.id = :supervisorId\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND s.startTime >= :startDate\n                  AND s.startTime <= :endDate\n                  AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                ORDER BY s.startTime DESC\n                \"\"\";\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"supervisorId\", supervisorId);\n        query.setParameter(\"semesterId\", semesterId);\n        query.setParameter(\"startDate\", startDate);\n        query.setParameter(\"endDate\", endDate);\n        query.setMaxResults(10); // Limit to 10 recent activities\n        List<com.fuacs.backend.entity.Slot> slots = query.getResultList();\n        List<RecentActivitySlotDTO> res = new ArrayList<>();\n        for (var s : slots) {\n            RecentActivitySlotDTO dto = new RecentActivitySlotDTO();\n            dto.setId(s.getId());\n            dto.setTitle(s.getTitle());\n            dto.setStartTime(s.getStartTime());\n            dto.setEndTime(s.getEndTime());\n\n            // Set room info\n            if (s.getRoom() != null) {\n                dto.setRoom(new com.fuacs.backend.dto.response.RoomDTO(s.getRoom().getId(), s.getRoom().getName(), s.getRoom().getLocation()));\n            }\n\n            // Set activity type based on whether slot has ended and has exam attendance records\n            // For FINAL_EXAM slots, check ExamAttendance instead of AttendanceRecord\n            boolean hasExamAttendanceRecords = !s.getExamAttendances().isEmpty();\n            boolean hasEnded = s.getEndTime().isBefore(LocalDateTime.now(ZoneId.of(\"Asia/Ho_Chi_Minh\")));\n            dto.setActivityType(hasEnded && hasExamAttendanceRecords ? \"finalized\" : \"pending\");\n\n            // For FINAL_EXAM slots, get subjects from ExamSlotSubject\n            if (s.getSlotCategory() == SlotCategory.FINAL_EXAM) {\n                String subjectQuery = \"SELECT ess.subject FROM ExamSlotSubject ess WHERE ess.slot.id = :slotId AND ess.isActive = true\";\n                List<com.fuacs.backend.entity.Subject> examSubjects = em.createQuery(subjectQuery, com.fuacs.backend.entity.Subject.class)\n                    .setParameter(\"slotId\", s.getId())\n                    .getResultList();\n\n                if (!examSubjects.isEmpty()) {\n                    List<com.fuacs.backend.dto.response.SubjectDTO> subjects = examSubjects.stream()\n                        .map(subj -> new com.fuacs.backend.dto.response.SubjectDTO(subj.getId(), subj.getName(), subj.getCode()))\n                        .collect(java.util.stream.Collectors.toList());\n                    dto.setSubjects(subjects);\n                }\n            } else if (s.getAcademicClass() != null) {\n                // Fallback for non-FINAL_EXAM slots (if any)\n                var c = s.getAcademicClass();\n                dto.setClassObj(new com.fuacs.backend.dto.response.ClassDTO(c.getId(), c.getCode()));\n                if (c.getSubject() != null) {\n                    var sub = c.getSubject();\n                    dto.setSubject(new com.fuacs.backend.dto.response.SubjectDTO(sub.getId(), sub.getName(), sub.getCode()));\n                }\n            }\n            res.add(dto);\n        }\n        return res;\n    }\n\n    @Override\n    public List<TodaySlotDTO> findUpcomingExamSlots(Integer supervisorId, Short semesterId, LocalDateTime fromTime, int maxResults) {\n        String jpql = \"\"\"\n                SELECT s\n                FROM Slot s\n                LEFT JOIN FETCH s.room r\n                LEFT JOIN FETCH s.academicClass c\n                LEFT JOIN FETCH c.subject sub\n                LEFT JOIN FETCH c.semester classSem\n                LEFT JOIN FETCH s.semester independentSem\n                WHERE s.staff.id = :supervisorId\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND s.startTime > :fromTime\n                  AND (classSem.id = :semesterId OR independentSem.id = :semesterId)\n                ORDER BY s.startTime ASC\n                \"\"\";\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"supervisorId\", supervisorId);\n        query.setParameter(\"semesterId\", semesterId);\n        query.setParameter(\"fromTime\", fromTime);\n        query.setMaxResults(maxResults);\n        List<com.fuacs.backend.entity.Slot> slots = query.getResultList();\n        List<TodaySlotDTO> res = new ArrayList<>();\n        for (var s : slots) {\n            TodaySlotDTO dto = new TodaySlotDTO();\n            dto.setId(s.getId());\n            dto.setTitle(s.getTitle());\n            dto.setStartTime(s.getStartTime());\n            dto.setEndTime(s.getEndTime());\n            if (s.getRoom() != null) {\n                dto.setRoom(new com.fuacs.backend.dto.response.RoomDTO(s.getRoom().getId(), s.getRoom().getName(), s.getRoom().getLocation()));\n            }\n\n            // For FINAL_EXAM slots, get subjects from ExamSlotSubject\n            if (s.getSlotCategory() == SlotCategory.FINAL_EXAM) {\n                String subjectQuery = \"SELECT ess.subject FROM ExamSlotSubject ess WHERE ess.slot.id = :slotId AND ess.isActive = true\";\n                List<com.fuacs.backend.entity.Subject> examSubjects = em.createQuery(subjectQuery, com.fuacs.backend.entity.Subject.class)\n                    .setParameter(\"slotId\", s.getId())\n                    .getResultList();\n\n                if (!examSubjects.isEmpty()) {\n                    List<com.fuacs.backend.dto.response.SubjectDTO> subjects = examSubjects.stream()\n                        .map(subj -> new com.fuacs.backend.dto.response.SubjectDTO(subj.getId(), subj.getName(), subj.getCode()))\n                        .collect(java.util.stream.Collectors.toList());\n                    dto.setSubjects(subjects);\n                }\n            } else if (s.getAcademicClass() != null) {\n                // Fallback for non-FINAL_EXAM slots (if any)\n                var c = s.getAcademicClass();\n                dto.setClassObj(new com.fuacs.backend.dto.response.ClassDTO(c.getId(), c.getCode()));\n                if (c.getSubject() != null) {\n                    var sub = c.getSubject();\n                    dto.setSubject(new com.fuacs.backend.dto.response.SubjectDTO(sub.getId(), sub.getName(), sub.getCode()));\n                }\n            }\n            res.add(dto);\n        }\n        return res;\n    }\n\n    // Student Dashboard queries implementation\n    @Override\n    public List<com.fuacs.backend.dto.response.StudentSlotDTO> findUpcomingLearningSlotsByStudentId(Integer studentUserId, LocalDateTime currentTime) {\n        String jpql = \"\"\"\n                SELECT \n                    s.id,\n                    s.title,\n                    s.description,\n                    s.slotCategory,\n                    s.startTime,\n                    s.endTime,\n                    sub.name,\n                    sub.code,\n                    c.code,\n                    r.name,\n                    u.fullName,\n                    s.sessionStatus\n                FROM Slot s\n                JOIN s.academicClass c\n                JOIN c.subject sub\n                JOIN s.room r\n                JOIN s.staff u\n                JOIN c.enrollments e\n                WHERE e.student.id = :studentUserId\n                  AND e.isEnrolled = true\n                  AND s.startTime > :currentTime\n                  AND (s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.LECTURE \n                       OR s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.LECTURE_WITH_PT)\n                ORDER BY s.startTime ASC\n                \"\"\";\n\n        TypedQuery<Object[]> query = em.createQuery(jpql, Object[].class);\n        query.setParameter(\"studentUserId\", studentUserId);\n        query.setParameter(\"currentTime\", currentTime);\n\n        List<Object[]> results = query.getResultList();\n        List<com.fuacs.backend.dto.response.StudentSlotDTO> slots = new ArrayList<>();\n\n        for (Object[] row : results) {\n            com.fuacs.backend.dto.response.StudentSlotDTO dto = new com.fuacs.backend.dto.response.StudentSlotDTO();\n            dto.setId((Integer) row[0]);\n            dto.setTitle((String) row[1]);\n            dto.setDescription((String) row[2]);\n            dto.setSlotCategory((SlotCategory) row[3]);\n            dto.setStartTime((LocalDateTime) row[4]);\n            dto.setEndTime((LocalDateTime) row[5]);\n            dto.setSubjectName((String) row[6]);\n            dto.setSubjectCode((String) row[7]);\n            dto.setClassCode((String) row[8]);\n            dto.setRoomName((String) row[9]);\n            dto.setStaffName((String) row[10]);\n            dto.setSessionStatus((com.fuacs.backend.constant.enums.SessionStatus) row[11]);\n            slots.add(dto);\n        }\n\n        return slots;\n    }\n\n    @Override\n    public List<com.fuacs.backend.dto.response.StudentSlotDTO> findUpcomingExamSlotsByStudentId(Integer studentUserId, LocalDateTime currentTime) {\n        String jpql = \"\"\"\n                SELECT \n                    s.id,\n                    s.title,\n                    s.description,\n                    s.slotCategory,\n                    s.startTime,\n                    s.endTime,\n                    sub.name,\n                    sub.code,\n                    CAST(null AS string),\n                    r.name,\n                    u.fullName,\n                    s.sessionStatus\n                FROM Slot s\n                JOIN s.room r\n                JOIN s.staff u\n                JOIN ExamSlotSubject ess ON ess.slot = s\n                JOIN ess.subject sub\n                JOIN ExamSlotParticipant esp ON esp.examSlotSubject = ess\n                WHERE esp.studentUser.id = :studentUserId\n                  AND s.startTime > :currentTime\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                ORDER BY s.startTime ASC\n                \"\"\";\n\n        TypedQuery<Object[]> query = em.createQuery(jpql, Object[].class);\n        query.setParameter(\"studentUserId\", studentUserId);\n        query.setParameter(\"currentTime\", currentTime);\n\n        List<Object[]> results = query.getResultList();\n        List<com.fuacs.backend.dto.response.StudentSlotDTO> slots = new ArrayList<>();\n\n        for (Object[] row : results) {\n            com.fuacs.backend.dto.response.StudentSlotDTO dto = new com.fuacs.backend.dto.response.StudentSlotDTO();\n            dto.setId((Integer) row[0]);\n            dto.setTitle((String) row[1]);\n            dto.setDescription((String) row[2]);\n            dto.setSlotCategory((SlotCategory) row[3]);\n            dto.setStartTime((LocalDateTime) row[4]);\n            dto.setEndTime((LocalDateTime) row[5]);\n            dto.setSubjectName((String) row[6]);\n            dto.setSubjectCode((String) row[7]);\n            dto.setClassCode((String) row[8]); // null for exam slots\n            dto.setRoomName((String) row[9]);\n            dto.setStaffName((String) row[10]);\n            dto.setSessionStatus((com.fuacs.backend.constant.enums.SessionStatus) row[11]);\n            slots.add(dto);\n        }\n\n        return slots;\n    }\n\n    @Override\n    public List<com.fuacs.backend.dto.response.StudentSlotDTO> findNextDaySlotsByStudentId(\n            Integer studentUserId,\n            Short semesterId,\n            LocalDateTime currentTime) {\n\n        // Step 1: Find the earliest date that has any slots for this student\n        // We need to check both learning slots and exam slots\n        String findEarliestDateJpql = \"\"\"\n                SELECT MIN(FUNCTION('DATE', s.startTime))\n                FROM Slot s\n                LEFT JOIN s.academicClass c\n                LEFT JOIN c.semester semester\n                LEFT JOIN c.enrollments e ON e.student.id = :studentUserId AND e.isEnrolled = true\n                LEFT JOIN ExamSlotSubject ess ON ess.slot = s\n                LEFT JOIN ExamSlotParticipant esp ON esp.examSlotSubject = ess AND esp.studentUser.id = :studentUserId\n                WHERE s.startTime >= :currentTime\n                  AND (e.id IS NOT NULL OR esp.id IS NOT NULL)\n                  AND (:semesterId IS NULL OR semester.id = :semesterId)\n                \"\"\";\n\n        TypedQuery<java.sql.Date> earliestDateQuery = em.createQuery(findEarliestDateJpql, java.sql.Date.class);\n        earliestDateQuery.setParameter(\"studentUserId\", studentUserId);\n        earliestDateQuery.setParameter(\"semesterId\", semesterId);\n        earliestDateQuery.setParameter(\"currentTime\", currentTime);\n\n        java.sql.Date earliestDate = earliestDateQuery.getSingleResult();\n\n        // If no slots found, return empty list\n        if (earliestDate == null) {\n            return new ArrayList<>();\n        }\n\n        // Step 2: Calculate start and end of that date\n        LocalDate nextDate = earliestDate.toLocalDate();\n        LocalDateTime startOfDay = nextDate.atStartOfDay();\n        LocalDateTime endOfDay = nextDate.atTime(23, 59, 59);\n\n        // Step 3: Query all slots on that date\n        List<com.fuacs.backend.dto.response.StudentSlotDTO> allSlots = new ArrayList<>();\n\n        // Query learning slots\n        String learningJpql = \"\"\"\n                SELECT\n                    s.id,\n                    s.title,\n                    s.description,\n                    s.slotCategory,\n                    s.startTime,\n                    s.endTime,\n                    sub.name,\n                    sub.code,\n                    c.code,\n                    r.name,\n                    u.fullName,\n                    s.sessionStatus\n                FROM Slot s\n                JOIN s.academicClass c\n                JOIN c.subject sub\n                JOIN c.semester semester\n                JOIN s.room r\n                JOIN s.staff u\n                JOIN c.enrollments e\n                WHERE e.student.id = :studentUserId\n                  AND e.isEnrolled = true\n                  AND s.startTime BETWEEN :startTime AND :endTime\n                  AND (s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.LECTURE\n                       OR s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.LECTURE_WITH_PT)\n                  AND (:semesterId IS NULL OR semester.id = :semesterId)\n                ORDER BY s.startTime ASC\n                \"\"\";\n\n        TypedQuery<Object[]> learningQuery = em.createQuery(learningJpql, Object[].class);\n        learningQuery.setParameter(\"studentUserId\", studentUserId);\n        learningQuery.setParameter(\"semesterId\", semesterId);\n        learningQuery.setParameter(\"startTime\", startOfDay);\n        learningQuery.setParameter(\"endTime\", endOfDay);\n\n        List<Object[]> learningResults = learningQuery.getResultList();\n        for (Object[] row : learningResults) {\n            com.fuacs.backend.dto.response.StudentSlotDTO dto = new com.fuacs.backend.dto.response.StudentSlotDTO();\n            dto.setId((Integer) row[0]);\n            dto.setTitle((String) row[1]);\n            dto.setDescription((String) row[2]);\n            dto.setSlotCategory((SlotCategory) row[3]);\n            dto.setStartTime((LocalDateTime) row[4]);\n            dto.setEndTime((LocalDateTime) row[5]);\n            dto.setSubjectName((String) row[6]);\n            dto.setSubjectCode((String) row[7]);\n            dto.setClassCode((String) row[8]);\n            dto.setRoomName((String) row[9]);\n            dto.setStaffName((String) row[10]);\n            dto.setSessionStatus((com.fuacs.backend.constant.enums.SessionStatus) row[11]);\n            allSlots.add(dto);\n        }\n\n        // Query exam slots\n        String examJpql = \"\"\"\n                SELECT\n                    s.id,\n                    s.title,\n                    s.description,\n                    s.slotCategory,\n                    s.startTime,\n                    s.endTime,\n                    sub.name,\n                    sub.code,\n                    CAST(null AS string),\n                    r.name,\n                    u.fullName,\n                    s.sessionStatus\n                FROM Slot s\n                JOIN s.room r\n                JOIN s.staff u\n                JOIN s.semester semester\n                JOIN ExamSlotSubject ess ON ess.slot = s\n                JOIN ess.subject sub\n                JOIN ExamSlotParticipant esp ON esp.examSlotSubject = ess\n                WHERE esp.studentUser.id = :studentUserId\n                  AND s.startTime BETWEEN :startTime AND :endTime\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND (:semesterId IS NULL OR semester.id = :semesterId)\n                ORDER BY s.startTime ASC\n                \"\"\";\n\n        TypedQuery<Object[]> examQuery = em.createQuery(examJpql, Object[].class);\n        examQuery.setParameter(\"studentUserId\", studentUserId);\n        examQuery.setParameter(\"semesterId\", semesterId);\n        examQuery.setParameter(\"startTime\", startOfDay);\n        examQuery.setParameter(\"endTime\", endOfDay);\n\n        List<Object[]> examResults = examQuery.getResultList();\n        for (Object[] row : examResults) {\n            com.fuacs.backend.dto.response.StudentSlotDTO dto = new com.fuacs.backend.dto.response.StudentSlotDTO();\n            dto.setId((Integer) row[0]);\n            dto.setTitle((String) row[1]);\n            dto.setDescription((String) row[2]);\n            dto.setSlotCategory((SlotCategory) row[3]);\n            dto.setStartTime((LocalDateTime) row[4]);\n            dto.setEndTime((LocalDateTime) row[5]);\n            dto.setSubjectName((String) row[6]);\n            dto.setSubjectCode((String) row[7]);\n            dto.setClassCode((String) row[8]); // null for exam slots\n            dto.setRoomName((String) row[9]);\n            dto.setStaffName((String) row[10]);\n            dto.setSessionStatus((com.fuacs.backend.constant.enums.SessionStatus) row[11]);\n            allSlots.add(dto);\n        }\n\n        // Sort combined list by start time\n        allSlots.sort((a, b) -> a.getStartTime().compareTo(b.getStartTime()));\n\n        return allSlots;\n    }\n\n    @Override\n    public List<com.fuacs.backend.dto.response.StudentSlotDTO> findUpcomingLearningSlotsBySemester(\n            Integer studentUserId,\n            Short semesterId,\n            LocalDateTime currentTime) {\n\n        String jpql = \"\"\"\n                SELECT\n                    s.id,\n                    s.title,\n                    s.description,\n                    s.slotCategory,\n                    s.startTime,\n                    s.endTime,\n                    sub.name,\n                    sub.code,\n                    c.code,\n                    r.name,\n                    u.fullName,\n                    s.sessionStatus\n                FROM Slot s\n                JOIN s.academicClass c\n                JOIN c.subject sub\n                JOIN c.semester semester\n                JOIN s.room r\n                JOIN s.staff u\n                JOIN c.enrollments e\n                WHERE e.student.id = :studentUserId\n                  AND e.isEnrolled = true\n                  AND s.startTime > :currentTime\n                  AND (s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.LECTURE\n                       OR s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.LECTURE_WITH_PT)\n                  AND (:semesterId IS NULL OR semester.id = :semesterId)\n                ORDER BY s.startTime ASC\n                \"\"\";\n\n        TypedQuery<Object[]> query = em.createQuery(jpql, Object[].class);\n        query.setParameter(\"studentUserId\", studentUserId);\n        query.setParameter(\"semesterId\", semesterId);\n        query.setParameter(\"currentTime\", currentTime);\n\n        List<Object[]> results = query.getResultList();\n        List<com.fuacs.backend.dto.response.StudentSlotDTO> slots = new ArrayList<>();\n\n        for (Object[] row : results) {\n            com.fuacs.backend.dto.response.StudentSlotDTO dto = new com.fuacs.backend.dto.response.StudentSlotDTO();\n            dto.setId((Integer) row[0]);\n            dto.setTitle((String) row[1]);\n            dto.setDescription((String) row[2]);\n            dto.setSlotCategory((SlotCategory) row[3]);\n            dto.setStartTime((LocalDateTime) row[4]);\n            dto.setEndTime((LocalDateTime) row[5]);\n            dto.setSubjectName((String) row[6]);\n            dto.setSubjectCode((String) row[7]);\n            dto.setClassCode((String) row[8]);\n            dto.setRoomName((String) row[9]);\n            dto.setStaffName((String) row[10]);\n            dto.setSessionStatus((com.fuacs.backend.constant.enums.SessionStatus) row[11]);\n            slots.add(dto);\n        }\n\n        return slots;\n    }\n\n    @Override\n    public List<com.fuacs.backend.dto.response.StudentSlotDTO> findUpcomingExamSlotsBySemester(\n            Integer studentUserId,\n            Short semesterId,\n            LocalDateTime currentTime) {\n\n        String jpql = \"\"\"\n                SELECT\n                    s.id,\n                    s.title,\n                    s.description,\n                    s.slotCategory,\n                    s.startTime,\n                    s.endTime,\n                    sub.name,\n                    sub.code,\n                    CAST(null AS string),\n                    r.name,\n                    u.fullName,\n                    s.sessionStatus\n                FROM Slot s\n                JOIN s.room r\n                JOIN s.staff u\n                JOIN s.semester semester\n                JOIN ExamSlotSubject ess ON ess.slot = s\n                JOIN ess.subject sub\n                JOIN ExamSlotParticipant esp ON esp.examSlotSubject = ess\n                WHERE esp.studentUser.id = :studentUserId\n                  AND s.startTime > :currentTime\n                  AND s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                  AND (:semesterId IS NULL OR semester.id = :semesterId)\n                ORDER BY s.startTime ASC\n                \"\"\";\n\n        TypedQuery<Object[]> query = em.createQuery(jpql, Object[].class);\n        query.setParameter(\"studentUserId\", studentUserId);\n        query.setParameter(\"semesterId\", semesterId);\n        query.setParameter(\"currentTime\", currentTime);\n\n        List<Object[]> results = query.getResultList();\n        List<com.fuacs.backend.dto.response.StudentSlotDTO> slots = new ArrayList<>();\n\n        for (Object[] row : results) {\n            com.fuacs.backend.dto.response.StudentSlotDTO dto = new com.fuacs.backend.dto.response.StudentSlotDTO();\n            dto.setId((Integer) row[0]);\n            dto.setTitle((String) row[1]);\n            dto.setDescription((String) row[2]);\n            dto.setSlotCategory((SlotCategory) row[3]);\n            dto.setStartTime((LocalDateTime) row[4]);\n            dto.setEndTime((LocalDateTime) row[5]);\n            dto.setSubjectName((String) row[6]);\n            dto.setSubjectCode((String) row[7]);\n            dto.setClassCode((String) row[8]); // null for exam slots\n            dto.setRoomName((String) row[9]);\n            dto.setStaffName((String) row[10]);\n            dto.setSessionStatus((com.fuacs.backend.constant.enums.SessionStatus) row[11]);\n            slots.add(dto);\n        }\n\n        return slots;\n    }\n\n    @Override\n    public List<TodaySlotDTO> findUpcomingSlotsForNextDay(Integer lecturerId, Short semesterId, LocalDateTime startTime, LocalDateTime endTime) {\n        String jpql = \"\"\"\n            SELECT s\n            FROM Slot s\n            LEFT JOIN FETCH s.room r\n            LEFT JOIN FETCH s.academicClass c\n            WHERE s.staff.id = :lecturerId\n              AND c.semester.id = :semesterId\n              AND s.startTime >= :startTime\n              AND s.startTime <= :endTime\n              AND (s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.LECTURE\n                   OR s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.LECTURE_WITH_PT)\n            ORDER BY s.startTime ASC\n            \"\"\";\n\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"semesterId\", semesterId);\n        query.setParameter(\"startTime\", startTime);\n        query.setParameter(\"endTime\", endTime);\n\n        List<com.fuacs.backend.entity.Slot> slots = query.getResultList();\n        List<TodaySlotDTO> result = new ArrayList<>();\n\n        for (com.fuacs.backend.entity.Slot s : slots) {\n            TodaySlotDTO dto = new TodaySlotDTO();\n            dto.setId(s.getId());\n            dto.setTitle(s.getTitle());\n            dto.setStartTime(s.getStartTime());\n            dto.setEndTime(s.getEndTime());\n\n            if (s.getRoom() != null) {\n                dto.setRoom(new RoomDTO(\n                    s.getRoom().getId(),\n                    s.getRoom().getName(),\n                    s.getRoom().getLocation()\n                ));\n            }\n\n            if (s.getAcademicClass() != null) {\n                ClassDTO classDTO = new ClassDTO();\n                classDTO.setId(s.getAcademicClass().getId());\n                classDTO.setCode(s.getAcademicClass().getCode());\n\n                if (s.getAcademicClass().getSubject() != null) {\n                    SubjectDTO subjectDTO = new SubjectDTO();\n                    subjectDTO.setId(s.getAcademicClass().getSubject().getId());\n                    subjectDTO.setCode(s.getAcademicClass().getSubject().getCode());\n                    subjectDTO.setName(s.getAcademicClass().getSubject().getName());\n                    classDTO.setSubject(subjectDTO);\n                }\n\n                dto.setClassObj(classDTO);\n            }\n\n            result.add(dto);\n        }\n\n        return result;\n    }\n\n    @Override\n    public List<TodaySlotDTO> findUpcomingSlotsForNextDayAllSemesters(Integer lecturerId, LocalDateTime startTime, LocalDateTime endTime) {\n        String jpql = \"\"\"\n            SELECT s\n            FROM Slot s\n            LEFT JOIN FETCH s.room r\n            LEFT JOIN FETCH s.academicClass c\n            WHERE s.staff.id = :lecturerId\n              AND s.startTime >= :startTime\n              AND s.startTime <= :endTime\n              AND (s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.LECTURE\n                   OR s.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.LECTURE_WITH_PT)\n            ORDER BY s.startTime ASC\n            \"\"\";\n\n        TypedQuery<com.fuacs.backend.entity.Slot> query = em.createQuery(jpql, com.fuacs.backend.entity.Slot.class);\n        query.setParameter(\"lecturerId\", lecturerId);\n        query.setParameter(\"startTime\", startTime);\n        query.setParameter(\"endTime\", endTime);\n\n        List<com.fuacs.backend.entity.Slot> slots = query.getResultList();\n        List<TodaySlotDTO> result = new ArrayList<>();\n\n        for (com.fuacs.backend.entity.Slot s : slots) {\n            TodaySlotDTO dto = new TodaySlotDTO();\n            dto.setId(s.getId());\n            dto.setTitle(s.getTitle());\n            dto.setStartTime(s.getStartTime());\n            dto.setEndTime(s.getEndTime());\n\n            if (s.getRoom() != null) {\n                dto.setRoom(new RoomDTO(\n                    s.getRoom().getId(),\n                    s.getRoom().getName(),\n                    s.getRoom().getLocation()\n                ));\n            }\n\n            if (s.getAcademicClass() != null) {\n                ClassDTO classDTO = new ClassDTO();\n                classDTO.setId(s.getAcademicClass().getId());\n                classDTO.setCode(s.getAcademicClass().getCode());\n\n                if (s.getAcademicClass().getSubject() != null) {\n                    SubjectDTO subjectDTO = new SubjectDTO();\n                    subjectDTO.setId(s.getAcademicClass().getSubject().getId());\n                    subjectDTO.setCode(s.getAcademicClass().getSubject().getCode());\n                    subjectDTO.setName(s.getAcademicClass().getSubject().getName());\n                    classDTO.setSubject(subjectDTO);\n                }\n\n                dto.setClassObj(classDTO);\n            }\n\n            result.add(dto);\n        }\n\n        return result;\n    }\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\StaffProfileRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/StaffProfileRepositoryImpl.java",
      "filename": "StaffProfileRepositoryImpl.java",
      "size_bytes": 5555,
      "lines": 133,
      "last_modified": "2025-11-28T08:56:33.018550",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.StaffProfileSearchRequest;\nimport com.fuacs.backend.dto.response.StaffProfileDTO;\nimport com.fuacs.backend.entity.Role;\nimport com.fuacs.backend.entity.StaffProfile;\nimport com.fuacs.backend.repository.custom.CustomStaffProfileRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@Repository\npublic class StaffProfileRepositoryImpl implements CustomStaffProfileRepository {\n\n    private static final Map<String, String> SORTABLE_FIELDS = Map.of(\n            \"fullName\", \"u.fullName\",\n            \"staffCode\", \"sp.staffCode\",\n            \"email\", \"u.email\");\n\n    @PersistenceContext\n    private EntityManager em;\n\n    @Override\n    public List<StaffProfileDTO> search(StaffProfileSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        // Lưu ý: dùng DISTINCT để tránh duplicate khi user có nhiều roles\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT DISTINCT sp FROM StaffProfile sp \" +\n                        \"JOIN FETCH sp.user u \" +\n                        \"LEFT JOIN FETCH u.roles r\");\n\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        // Sort\n        String sortBy = request.getSortBy();\n        if (StringUtils.hasText(sortBy)) {\n            if (!SORTABLE_FIELDS.containsKey(sortBy)) {\n                throw new com.fuacs.backend.exception.BadRequestException(\n                        \"Invalid sortBy parameter\",\n                        com.fuacs.backend.constant.ErrorCode.INVALID_SORT_BY);\n            }\n            jpql.append(\" ORDER BY \").append(SORTABLE_FIELDS.get(sortBy))\n                    .append(\" \").append(request.getSort());\n        } else {\n            // Default: do NOT sort by id; follow docs default\n            jpql.append(\" ORDER BY u.fullName ASC\");\n        }\n\n        TypedQuery<StaffProfile> query = em.createQuery(jpql.toString(), StaffProfile.class);\n        parameters.forEach(query::setParameter);\n\n        // Pagination\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n\n        List<StaffProfile> results = query.getResultList();\n\n        // Convert sang DTO\n        return results.stream()\n                .map(sp -> new StaffProfileDTO(\n                        sp.getUser().getId(),\n                        sp.getUser().getFullName(),\n                        sp.getUser().getEmail(),\n                        sp.getUser().getUsername(),\n                        sp.getStaffCode(),\n                        sp.getUser().getActive(),\n                        sp.getUser().getCreatedAt(),\n                        sp.getUser().getUpdatedAt(),\n                        sp.getUser().getRoles() == null\n                                ? List.of()\n                                : sp.getUser().getRoles().stream()\n                                        .map(Role::getName)\n                                        .collect(Collectors.toList())))\n                .toList();\n    }\n\n    @Override\n    public Long count(StaffProfileSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        // Count query không dùng JOIN FETCH\n        StringBuilder jpql = new StringBuilder(\"SELECT COUNT(DISTINCT u.id) FROM StaffProfile sp JOIN sp.user u\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    private String buildWhereClause(Map<String, Object> parameters, StaffProfileSearchRequest request) {\n        List<String> whereClauses = new ArrayList<>();\n\n        if (request.getActive() != null) {\n            whereClauses.add(\"u.isActive = :isActive\");\n            parameters.put(\"isActive\", request.getActive());\n        }\n\n        if (request.getRoleIds() != null && !request.getRoleIds().isEmpty()) {\n            whereClauses.add(\"EXISTS (SELECT 1 FROM u.roles r WHERE r.id IN :roleIds)\");\n            parameters.put(\"roleIds\", request.getRoleIds());\n        }\n\n        if (request.getExcludeRoles() != null && !request.getExcludeRoles().isEmpty()) {\n            whereClauses.add(\"NOT EXISTS (SELECT 1 FROM u.roles r2 WHERE UPPER(r2.name) IN :excludeRoles)\");\n            parameters.put(\"excludeRoles\", request.getExcludeRoles());\n        }\n\n        String search = request.getSearch();\n        if (StringUtils.hasText(search)) {\n            whereClauses.add(\"(\" +\n                    \"LOWER(u.fullName) LIKE :search OR \" +\n                    \"LOWER(sp.staffCode) LIKE :search OR \" +\n                    \"LOWER(u.email) LIKE :search OR \" +\n                    \"LOWER(u.username) LIKE :search\" +\n                    \")\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", whereClauses);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\StudentProfileRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/StudentProfileRepositoryImpl.java",
      "filename": "StudentProfileRepositoryImpl.java",
      "size_bytes": 4910,
      "lines": 117,
      "last_modified": "2025-11-28T08:56:33.019056",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.StudentProfileSearchRequest;\nimport com.fuacs.backend.dto.request.StudentSemesterSearchRequest;\nimport com.fuacs.backend.dto.response.StudentProfileDTO;\nimport com.fuacs.backend.dto.response.StudentSemesterDTO;\nimport com.fuacs.backend.repository.custom.CustomStudentProfileRepository;\nimport com.fuacs.backend.repository.custom.CustomEnrollmentRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Repository\npublic class StudentProfileRepositoryImpl implements CustomStudentProfileRepository {\n    private static final Map<String, String> SORTABLE_FIELDS = Map.of(\n            \"fullName\", \"u.fullName\",\n            \"rollNumber\", \"sp.rollNumber\",\n            \"email\", \"u.email\",\n            \"majorName\", \"m.name\");\n\n    @PersistenceContext\n    private EntityManager em;\n\n    @Autowired\n    private CustomEnrollmentRepository enrollmentRepository;\n\n    @Override\n    public List<StudentProfileDTO> search(StudentProfileSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT NEW com.fuacs.backend.dto.response.StudentProfileDTO(\" +\n                        \"u.id, u.fullName, u.email, u.username, sp.rollNumber, \" +\n                        \"m.id, m.name, m.code, m.isActive, u.isActive, u.createdAt, u.updatedAt, sp.baseUrl\" +\n                        \") \" +\n                        \"FROM StudentProfile sp \" +\n                        \"JOIN sp.user u \" +\n                        \"JOIN sp.major m\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        String sortBy = request.getSortBy();\n        String sortField;\n        if (StringUtils.hasText(sortBy) && SORTABLE_FIELDS.containsKey(sortBy)) {\n            sortField = SORTABLE_FIELDS.get(sortBy);\n        } else {\n            sortField = SORTABLE_FIELDS.get(\"fullName\");\n        }\n        jpql.append(\" ORDER BY \").append(sortField).append(\" \").append(request.getSort());\n\n        TypedQuery<StudentProfileDTO> query = em.createQuery(jpql.toString(), StudentProfileDTO.class);\n        parameters.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public Long count(StudentProfileSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        StringBuilder jpql = new StringBuilder(\n                \"SELECT COUNT(u.id) FROM StudentProfile sp JOIN sp.user u JOIN sp.major m\");\n        if (!whereClause.isEmpty()) {\n            jpql.append(\" WHERE \").append(whereClause);\n        }\n\n        TypedQuery<Long> query = em.createQuery(jpql.toString(), Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public List<StudentSemesterDTO> searchBySemesterId(Short semesterId, StudentSemesterSearchRequest request) {\n        return enrollmentRepository.searchBySemesterId(semesterId, request);\n    }\n\n    @Override\n    public Long countBySemesterId(Short semesterId, StudentSemesterSearchRequest request) {\n        return enrollmentRepository.countBySemesterId(semesterId, request);\n    }\n\n    private String buildWhereClause(Map<String, Object> parameters, StudentProfileSearchRequest request) {\n        List<String> whereClauses = new ArrayList<>();\n\n        if (request.getActive() != null) {\n            whereClauses.add(\"u.isActive = :isActive\");\n            parameters.put(\"isActive\", request.getActive());\n        }\n\n        // Support multiple majorIds filter\n        if (request.getMajorIds() != null && !request.getMajorIds().isEmpty()) {\n            whereClauses.add(\"m.id IN :majorIds\");\n            parameters.put(\"majorIds\", request.getMajorIds());\n        }\n\n        String search = request.getSearch();\n        if (StringUtils.hasText(search)) {\n            whereClauses.add(\n                    \"(LOWER(u.fullName) LIKE :search OR LOWER(sp.rollNumber) LIKE :search OR LOWER(u.email) LIKE :search)\");\n            parameters.put(\"search\", \"%\" + search.toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", whereClauses);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\impl\\SubjectRepositoryImpl.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/impl/SubjectRepositoryImpl.java",
      "filename": "SubjectRepositoryImpl.java",
      "size_bytes": 21774,
      "lines": 523,
      "last_modified": "2025-11-28T08:56:33.019056",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository.impl;\n\nimport com.fuacs.backend.dto.request.SubjectSearchRequest;\nimport com.fuacs.backend.dto.response.ClassDTO;\nimport com.fuacs.backend.dto.response.MajorDTO;\nimport com.fuacs.backend.dto.response.SubjectDTO;\nimport com.fuacs.backend.repository.custom.CustomSubjectRepository;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport jakarta.persistence.Tuple;\nimport jakarta.persistence.TypedQuery;\nimport org.springframework.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\npublic class SubjectRepositoryImpl implements CustomSubjectRepository {\n\n    private static final Map<String, String> SORTABLE_FIELDS = Map.ofEntries(\n            Map.entry(\"id\", \"s.id\"),\n            Map.entry(\"name\", \"s.name\"),\n            Map.entry(\"code\", \"s.code\"));\n\n    @PersistenceContext\n    private EntityManager em;\n\n    @Override\n    public List<SubjectDTO> search(SubjectSearchRequest request) {\n        Map<String, Object> values = new HashMap<>();\n        String whereClause = buildWhereClause(values, request);\n\n        String jpql = \"\"\"\n                    SELECT\n                        s.id AS id,\n                        s.name AS name,\n                        s.code AS code,\n                        COUNT(DISTINCT c.id) AS classCount,\n                        SUM(CASE WHEN c.isActive = true THEN 1 ELSE 0 END) AS activeClassCount,\n                        s.isActive AS isActive,\n                        s.createdAt AS createdAt,\n                        s.updatedAt AS updatedAt\n                    FROM Subject s\n                    LEFT JOIN s.academicClasses c\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause) + \"\"\"\n                    GROUP BY s.id, s.name, s.code, s.isActive, s.createdAt, s.updatedAt\n                \"\"\" + buildOrderBy(request.getSortBy(), request.getSort());\n\n        var query = em.createQuery(jpql, Tuple.class);\n        values.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n\n        List<Tuple> tuples = query.getResultList();\n        List<SubjectDTO> subjects = tuples.stream()\n                .map(this::tupleToSubjectDTO)\n                .collect(Collectors.toList());\n\n        if (subjects.isEmpty()) {\n            return subjects;\n        }\n\n        List<Short> subjectIds = subjects.stream()\n                .map(SubjectDTO::getId)\n                .filter(Objects::nonNull)\n                .distinct()\n                .collect(Collectors.toList());\n\n        if (subjectIds.isEmpty()) {\n            return subjects; // không fetch major khi list rỗng\n        }\n\n        String majorsJpql = \"\"\"\n                    SELECT s.id AS subjectId,\n                           m.id AS id,\n                           m.name AS name,\n                           m.code AS code,\n                           m.isActive AS isActive\n                    FROM Subject s\n                    JOIN s.majors m\n                    WHERE s.id IN :ids\n                    ORDER BY m.name\n                \"\"\";\n\n        List<Tuple> majorTuples = em.createQuery(majorsJpql, Tuple.class)\n                .setParameter(\"ids\", subjectIds)\n                .getResultList();\n\n        Map<Short, List<MajorDTO>> majorsBySubject = new HashMap<>();\n        for (Tuple t : majorTuples) {\n            Short subjectId = t.get(\"subjectId\", Short.class);\n            MajorDTO major = new MajorDTO(\n                    t.get(\"id\", Short.class),\n                    t.get(\"name\", String.class),\n                    t.get(\"code\", String.class),\n                    t.get(\"isActive\", Boolean.class));\n            majorsBySubject.computeIfAbsent(subjectId, k -> new ArrayList<>()).add(major);\n        }\n\n        subjects.forEach(s -> s.setMajors(majorsBySubject.getOrDefault(s.getId(), Collections.emptyList())));\n\n        return subjects;\n    }\n\n    private List<SubjectDTO> searchByMajorId(SubjectSearchRequest request) {\n        Map<String, Object> values = new HashMap<>();\n        String whereClause = buildWhereClause(values, request);\n\n        String jpql = \"\"\"\n                    SELECT\n                        s.id AS id,\n                        s.name AS name,\n                        s.code AS code,\n                        s.isActive AS isActive,\n                        s.createdAt AS createdAt,\n                        s.updatedAt AS updatedAt\n                    FROM Subject s\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause) + \"\"\"\n                \"\"\" + buildOrderBy(request.getSortBy(), request.getSort());\n\n        TypedQuery<SubjectDTO> query = em.createQuery(jpql, SubjectDTO.class);\n        values.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n        return query.getResultList();\n    }\n\n    @Override\n    public Long count(SubjectSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClause(parameters, request);\n\n        String jpql = \"SELECT COUNT(s.id) FROM Subject s\" +\n                (whereClause.isEmpty() ? \"\" : \" WHERE \" + whereClause);\n\n        TypedQuery<Long> query = em.createQuery(jpql, Long.class);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    @Override\n    public List<SubjectDTO> searchByMajorId(Short majorId, SubjectSearchRequest request) {\n        request.setMajorId(majorId);\n        return searchByMajorId(request);\n    }\n\n    @Override\n    public Long countByMajorId(Short majorId, SubjectSearchRequest request) {\n        request.setMajorId(majorId);\n        return count(request);\n    }\n\n    @Override\n    public List<SubjectDTO> searchBySemesterId(Short semesterId, SubjectSearchRequest request) {\n        Map<String, Object> values = new HashMap<>();\n        String whereClause = buildWhereClauseForSemester(values, request, semesterId);\n\n        String jpql = \"\"\"\n                    SELECT\n                        s.id AS id,\n                        s.name AS name,\n                        s.code AS code,\n                        COUNT(DISTINCT c.id) AS totalClassInSemester,\n                        SUM(CASE WHEN c.isActive = true THEN 1 ELSE 0 END) AS totalActiveClassInSemester,\n                        s.isActive AS isActive,\n                        s.createdAt AS createdAt,\n                        s.updatedAt AS updatedAt\n                    FROM Subject s\n                    JOIN s.academicClasses c\n                    WHERE c.semester.id = :semesterId AND c.isActive = true\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" AND \" + whereClause) + \"\"\"\n                    GROUP BY s.id, s.name, s.code, s.isActive, s.createdAt, s.updatedAt\n                \"\"\" + buildOrderBy(request.getSortBy(), request.getSort());\n\n        var query = em.createQuery(jpql, Tuple.class);\n        query.setParameter(\"semesterId\", semesterId);\n        values.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n\n        List<Tuple> tuples = query.getResultList();\n        List<SubjectDTO> subjects = tuples.stream()\n                .map(this::tupleToSubjectDTOForSemester)\n                .collect(Collectors.toList());\n\n        if (subjects.isEmpty()) {\n            return subjects;\n        }\n\n        List<Short> subjectIds = subjects.stream()\n                .map(SubjectDTO::getId)\n                .filter(Objects::nonNull)\n                .distinct()\n                .collect(Collectors.toList());\n\n        if (subjectIds.isEmpty()) {\n            return subjects;\n        }\n\n        String majorsJpql = \"\"\"\n                    SELECT s.id AS subjectId,\n                           m.id AS id,\n                           m.name AS name,\n                           m.code AS code,\n                           m.isActive AS isActive\n                    FROM Subject s\n                    JOIN s.majors m\n                    WHERE s.id IN :ids\n                    ORDER BY m.name\n                \"\"\";\n\n        List<Tuple> majorTuples = em.createQuery(majorsJpql, Tuple.class)\n                .setParameter(\"ids\", subjectIds)\n                .getResultList();\n\n        Map<Short, List<MajorDTO>> majorsBySubject = new HashMap<>();\n        for (Tuple t : majorTuples) {\n            Short subjectId = t.get(\"subjectId\", Short.class);\n            MajorDTO major = new MajorDTO(\n                    t.get(\"id\", Short.class),\n                    t.get(\"name\", String.class),\n                    t.get(\"code\", String.class),\n                    t.get(\"isActive\", Boolean.class));\n            majorsBySubject.computeIfAbsent(subjectId, k -> new ArrayList<>()).add(major);\n        }\n\n        subjects.forEach(s -> s.setMajors(majorsBySubject.getOrDefault(s.getId(), Collections.emptyList())));\n\n        return subjects;\n    }\n\n    @Override\n    public Long countBySemesterId(Short semesterId, SubjectSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClauseForSemester(parameters, request, semesterId);\n\n        String jpql = \"\"\"\n                SELECT COUNT(DISTINCT s.id) FROM Subject s\n                JOIN s.academicClasses c\n                WHERE c.semester.id = :semesterId AND c.isActive = true\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" AND \" + whereClause);\n\n        var query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"semesterId\", semesterId);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    private String buildWhereClause(Map<String, Object> params, SubjectSearchRequest req) {\n        List<String> clauses = new ArrayList<>();\n\n        if (req.getActive() != null) {\n            clauses.add(\"s.isActive = :isActive\");\n            params.put(\"isActive\", req.getActive());\n        }\n\n        if (req.getMajorId() != null) {\n            clauses.add(\"\"\"\n                         EXISTS (\n                             SELECT 1 FROM Major m\\s\n                             JOIN m.subjects sm\\s\n                             WHERE sm.id = s.id AND m.id = :majorId\n                         )\n                    \\s\"\"\");\n            params.put(\"majorId\", req.getMajorId());\n        }\n\n        if (StringUtils.hasText(req.getSearch())) {\n            clauses.add(\"(LOWER(s.name) LIKE :search OR LOWER(s.code) LIKE :search)\");\n            params.put(\"search\", \"%\" + req.getSearch().toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", clauses);\n    }\n\n    private String buildWhereClauseForSemester(Map<String, Object> params, SubjectSearchRequest req, Short semesterId) {\n        List<String> clauses = new ArrayList<>();\n\n        if (req.getActive() != null) {\n            clauses.add(\"s.isActive = :isActive\");\n            params.put(\"isActive\", req.getActive());\n        }\n\n        if (req.getMajorId() != null) {\n            clauses.add(\"\"\"\n                         EXISTS (\n                             SELECT 1 FROM Major m\\s\n                             JOIN m.subjects sm\\s\n                             WHERE sm.id = s.id AND m.id = :majorId\n                         )\n                    \\s\"\"\");\n            params.put(\"majorId\", req.getMajorId());\n        }\n\n        if (StringUtils.hasText(req.getSearch())) {\n            clauses.add(\"(LOWER(s.name) LIKE :search OR LOWER(s.code) LIKE :search)\");\n            params.put(\"search\", \"%\" + req.getSearch().toLowerCase() + \"%\");\n        }\n\n        clauses.add(\"c.semester.id = :semesterId\");\n        params.put(\"semesterId\", semesterId);\n\n        return String.join(\" AND \", clauses);\n    }\n\n    private String buildOrderBy(String sortBy, String direction) {\n        if (!StringUtils.hasText(sortBy)) {\n            sortBy = \"id\"; // fallback mặc định\n        }\n\n        String dir = (StringUtils.hasText(direction) && direction.equalsIgnoreCase(\"ASC\")) ? \"ASC\" : \"DESC\";\n        String column = SORTABLE_FIELDS.getOrDefault(sortBy, \"s.id\");\n        return \" ORDER BY \" + column + \" \" + dir;\n    }\n\n    private SubjectDTO tupleToSubjectDTO(Tuple t) {\n        SubjectDTO dto = new SubjectDTO();\n        dto.setId(t.get(\"id\", Short.class));\n        dto.setName(t.get(\"name\", String.class));\n        dto.setCode(t.get(\"code\", String.class));\n        dto.setMajors(Collections.emptyList());\n        dto.setTotalClass(\n                Optional.ofNullable(t.get(\"classCount\", Long.class)).orElse(0L).intValue());\n        dto.setTotalActiveClass(\n                Optional.ofNullable(t.get(\"activeClassCount\", Long.class)).orElse(0L).intValue());\n        dto.setActive(t.get(\"isActive\", Boolean.class));\n        dto.setCreatedAt(t.get(\"createdAt\", java.time.Instant.class));\n        dto.setUpdatedAt(t.get(\"updatedAt\", java.time.Instant.class));\n        return dto;\n    }\n\n    private SubjectDTO tupleToSubjectDTOForSemester(Tuple t) {\n        SubjectDTO dto = new SubjectDTO();\n        dto.setId(t.get(\"id\", Short.class));\n        dto.setName(t.get(\"name\", String.class));\n        dto.setCode(t.get(\"code\", String.class));\n        dto.setMajors(Collections.emptyList());\n        dto.setTotalClassInSemester(\n                Optional.ofNullable(t.get(\"totalClassInSemester\", Long.class)).orElse(0L).intValue());\n        dto.setTotalActiveClassInSemester(\n                Optional.ofNullable(t.get(\"totalActiveClassInSemester\", Long.class)).orElse(0L).intValue());\n        dto.setActive(t.get(\"isActive\", Boolean.class));\n        dto.setCreatedAt(t.get(\"createdAt\", java.time.Instant.class));\n        dto.setUpdatedAt(t.get(\"updatedAt\", java.time.Instant.class));\n        return dto;\n    }\n\n    // NEW METHODS FOR STAFF-SCOPED QUERIES\n    @Override\n    public List<SubjectDTO> searchByStaffId(Integer staffId, SubjectSearchRequest request) {\n        Map<String, Object> values = new HashMap<>();\n        String whereClause = buildWhereClauseForStaff(values, request);\n\n        String jpql = \"\"\"\n                    SELECT DISTINCT\n                        s.id AS id,\n                        s.name AS name,\n                        s.code AS code,\n                        s.isActive AS isActive,\n                        s.createdAt AS createdAt,\n                        s.updatedAt AS updatedAt,\n                        CASE WHEN EXISTS (\n                            SELECT 1 FROM Slot sl2\n                            JOIN sl2.academicClass c2\n                            WHERE c2.subject.id = s.id AND sl2.staff.id = :staffId AND sl2.slotCategory = com.fuacs.backend.constant.enums.SlotCategory.FINAL_EXAM\n                        ) THEN 'SUPERVISOR' ELSE 'LECTURER' END AS role\n                    FROM Subject s\n                    JOIN s.academicClasses c\n                    JOIN Slot sl ON sl.academicClass.id = c.id\n                    JOIN sl.staff st\n                    WHERE st.id = :staffId\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" AND \" + whereClause) + \"\"\"\n                    GROUP BY s.id, s.name, s.code, s.isActive, s.createdAt, s.updatedAt\n                \"\"\" + buildOrderBy(request.getSortBy(), request.getSort());\n\n        var query = em.createQuery(jpql, Tuple.class);\n        query.setParameter(\"staffId\", staffId);\n        values.forEach(query::setParameter);\n        query.setFirstResult(request.getPage() * request.getPageSize());\n        query.setMaxResults(request.getPageSize());\n\n        List<Tuple> tuples = query.getResultList();\n        List<SubjectDTO> subjects = tuples.stream()\n                .map(t -> {\n                    SubjectDTO dto = new SubjectDTO();\n                    dto.setId(t.get(\"id\", Short.class));\n                    dto.setName(t.get(\"name\", String.class));\n                    dto.setCode(t.get(\"code\", String.class));\n                    dto.setActive(t.get(\"isActive\", Boolean.class));\n                    dto.setCreatedAt(t.get(\"createdAt\", java.time.Instant.class));\n                    dto.setUpdatedAt(t.get(\"updatedAt\", java.time.Instant.class));\n                    dto.setRole(t.get(\"role\", String.class));\n                    dto.setMajors(Collections.emptyList());\n                    // totalClass and totalActiveClass will be populated via assignedClasses\n                    dto.setTotalClass(0);\n                    dto.setTotalActiveClass(0);\n                    return dto;\n                })\n                .collect(Collectors.toList());\n\n        if (subjects.isEmpty()) {\n            return subjects;\n        }\n\n        List<Short> subjectIds = subjects.stream()\n                .map(SubjectDTO::getId)\n                .filter(Objects::nonNull)\n                .distinct()\n                .collect(Collectors.toList());\n\n        if (subjectIds.isEmpty()) {\n            return subjects;\n        }\n\n        // Fetch majors\n        String majorsJpql = \"\"\"\n                    SELECT s.id AS subjectId,\n                           m.id AS id,\n                           m.name AS name,\n                           m.code AS code,\n                           m.isActive AS isActive\n                    FROM Subject s\n                    JOIN s.majors m\n                    WHERE s.id IN :ids\n                    ORDER BY m.name\n                \"\"\";\n\n        List<Tuple> majorTuples = em.createQuery(majorsJpql, Tuple.class)\n                .setParameter(\"ids\", subjectIds)\n                .getResultList();\n\n        Map<Short, List<MajorDTO>> majorsBySubject = new HashMap<>();\n        for (Tuple t : majorTuples) {\n            Short subjectId = t.get(\"subjectId\", Short.class);\n            MajorDTO major = new MajorDTO(\n                    t.get(\"id\", Short.class),\n                    t.get(\"name\", String.class),\n                    t.get(\"code\", String.class),\n                    t.get(\"isActive\", Boolean.class));\n            majorsBySubject.computeIfAbsent(subjectId, k -> new ArrayList<>()).add(major);\n        }\n\n        subjects.forEach(s -> s.setMajors(majorsBySubject.getOrDefault(s.getId(), Collections.emptyList())));\n\n        // Populate assigned classes per subject for this staff\n        String classesJpql = \"\"\"\n                SELECT DISTINCT s.id AS subjectId, c.id AS classId, c.code AS classCode\n                FROM Subject s\n                JOIN s.academicClasses c\n                JOIN Slot sl3 ON sl3.academicClass.id = c.id\n                JOIN sl3.staff st3\n                WHERE st3.id = :staffId AND s.id IN :ids\n                ORDER BY c.code\n            \"\"\";\n\n        List<Tuple> classTuples = em.createQuery(classesJpql, Tuple.class)\n                .setParameter(\"staffId\", staffId)\n                .setParameter(\"ids\", subjectIds)\n                .getResultList();\n\n        Map<Short, List<ClassDTO>> classesBySubject = new HashMap<>();\n        for (Tuple t : classTuples) {\n            Short sid = t.get(\"subjectId\", Short.class);\n            ClassDTO c = new ClassDTO(t.get(\"classId\", Short.class), t.get(\"classCode\", String.class));\n            classesBySubject.computeIfAbsent(sid, k -> new ArrayList<>()).add(c);\n        }\n\n        subjects.forEach(s -> s.setAssignedClasses(classesBySubject.getOrDefault(s.getId(), Collections.emptyList())));\n\n        return subjects;\n    }\n\n    @Override\n    public Long countByStaffId(Integer staffId, SubjectSearchRequest request) {\n        Map<String, Object> parameters = new HashMap<>();\n        String whereClause = buildWhereClauseForStaff(parameters, request);\n\n        String jpql = \"\"\"\n                SELECT COUNT(DISTINCT s.id) FROM Subject s\n                JOIN s.academicClasses c\n                JOIN Slot sl ON sl.academicClass.id = c.id\n                JOIN sl.staff st\n                WHERE st.id = :staffId\n                \"\"\" + (whereClause.isEmpty() ? \"\" : \" AND \" + whereClause);\n\n        var query = em.createQuery(jpql, Long.class);\n        query.setParameter(\"staffId\", staffId);\n        parameters.forEach(query::setParameter);\n        return query.getSingleResult();\n    }\n\n    private String buildWhereClauseForStaff(Map<String, Object> params, SubjectSearchRequest req) {\n        List<String> clauses = new ArrayList<>();\n\n        if (req.getActive() != null) {\n            clauses.add(\"s.isActive = :isActive\");\n            params.put(\"isActive\", req.getActive());\n        }\n\n        if (req.getMajorId() != null) {\n            clauses.add(\"\"\"\n                         EXISTS (\n                             SELECT 1 FROM Major m\\s\n                             JOIN m.subjects sm\\s\n                             WHERE sm.id = s.id AND m.id = :majorId\n                         )\n                    \\s\"\"\");\n            params.put(\"majorId\", req.getMajorId());\n        }\n\n        if (StringUtils.hasText(req.getSearch())) {\n            clauses.add(\"(LOWER(s.name) LIKE :search OR LOWER(s.code) LIKE :search)\");\n            params.put(\"search\", \"%\" + req.getSearch().toLowerCase() + \"%\");\n        }\n\n        return String.join(\" AND \", clauses);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\MajorRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/MajorRepository.java",
      "filename": "MajorRepository.java",
      "size_bytes": 2084,
      "lines": 49,
      "last_modified": "2025-11-28T08:56:33.009544",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.dto.response.MajorDTO;\nimport com.fuacs.backend.entity.Major;\nimport com.fuacs.backend.repository.custom.CustomMajorRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Optional;\n\n@Repository\npublic interface MajorRepository extends JpaRepository<Major, Short>, CustomMajorRepository {\n    boolean existsByName(String name);\n\n    boolean existsByCode(String code);\n\n    boolean existsByNameAndIdNot(String name, Short id);\n\n    boolean existsByCodeAndIdNot(String code, Short id);\n\n    @Query(\"SELECT NEW com.fuacs.backend.dto.response.MajorDTO(m.id, m.name, m.code, m.isActive, m.createdAt, m.updatedAt, COUNT(s.id)) \"\n            +\n            \"FROM Major m LEFT JOIN m.subjects s \" +\n            \"WHERE m.id = :id \" +\n            \"GROUP BY m.id, m.name, m.code, m.isActive, m.createdAt, m.updatedAt\")\n    Optional<MajorDTO> findMajorDTOById(@Param(\"id\") Short id);\n\n    // Dùng cho PUT (Rule 1: Deactivation Check)\n    @Query(\"SELECT COUNT(s) FROM Subject s JOIN s.majors m WHERE m.id = :majorId AND s.isActive = true\")\n    long countActiveSubjectsByMajorId(@Param(\"majorId\") Short majorId);\n\n    @Query(\"SELECT COUNT(sp) FROM StudentProfile sp WHERE sp.major.id = :majorId AND sp.user.isActive = true\")\n    long countActiveStudentsByMajorId(@Param(\"majorId\") Short majorId);\n\n    // Dùng cho DELETE (Note: Must not have *any*)\n    @Query(\"SELECT COUNT(s) FROM Subject s JOIN s.majors m WHERE m.id = :majorId\")\n    long countSubjectsByMajorId(@Param(\"majorId\") Short majorId);\n\n    @Query(\"SELECT COUNT(sp) FROM StudentProfile sp WHERE sp.major.id = :majorId\")\n    long countStudentsByMajorId(@Param(\"majorId\") Short majorId);\n\n    List<Major> findByIdIn(Collection<Short> ids);\n\n    Major findByCode(String code);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\NotificationDeliveryRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/NotificationDeliveryRepository.java",
      "filename": "NotificationDeliveryRepository.java",
      "size_bytes": 329,
      "lines": 9,
      "last_modified": "2025-12-01T17:52:11.032419",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.NotificationDelivery;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface NotificationDeliveryRepository extends JpaRepository<NotificationDelivery, Long> {\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\PasswordResetTokenRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/PasswordResetTokenRepository.java",
      "filename": "PasswordResetTokenRepository.java",
      "size_bytes": 1091,
      "lines": 25,
      "last_modified": "2025-11-28T08:56:33.009544",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.PasswordResetToken;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Modifying;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\n\nimport java.time.Instant;\nimport java.util.Optional;\n\npublic interface PasswordResetTokenRepository extends JpaRepository<PasswordResetToken, Integer> {\n        @Modifying\n        @Query(\"UPDATE PasswordResetToken t \" +\n                        \"SET t.tokenHash = :token, \" +\n                        \"t.createdAt = :createdAt, \" +\n                        \"t.expiresAt = :expiresAt \" +\n                        \"WHERE t.email = :email\")\n        int updateToken(@Param(\"email\") String email,\n                        @Param(\"token\") String token,\n                        @Param(\"createdAt\") Instant createdAt,\n                        @Param(\"expiresAt\") Instant expiresAt);\n\n        Optional<PasswordResetToken> findByTokenHash(String tokenHash);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\PermissionRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/PermissionRepository.java",
      "filename": "PermissionRepository.java",
      "size_bytes": 1030,
      "lines": 26,
      "last_modified": "2025-11-28T08:56:33.009544",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.Permission;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Modifying;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n@Repository\npublic interface PermissionRepository extends JpaRepository<Permission, Short> {\n    @Query(\"SELECT p FROM Permission p WHERE p.name LIKE %:search%\")\n    List<Permission> findByNameLike(@Param(\"search\") String search, Pageable pageable);\n\n    @Query(\"SELECT COUNT(p) FROM Permission p WHERE p.name LIKE %:search%\")\n    Long countAll(@Param(\"search\") String search);\n\n    @Modifying\n    @Query(\"UPDATE Permission p SET p.isActive = false WHERE p.id = :id\")\n    int deactivatePermissionById(@Param(\"id\") Short id);\n\n    boolean existsByName(String name);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\RegularAttendanceEvidenceRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/RegularAttendanceEvidenceRepository.java",
      "filename": "RegularAttendanceEvidenceRepository.java",
      "size_bytes": 678,
      "lines": 15,
      "last_modified": "2025-11-28T08:56:33.010549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.RegularAttendanceEvidence;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface RegularAttendanceEvidenceRepository extends JpaRepository<RegularAttendanceEvidence, Long> {\n\n    @Query(\"SELECT e FROM RegularAttendanceEvidence e WHERE e.attendanceRecord.id = :attendanceRecordId\")\n    RegularAttendanceEvidence findByAttendanceRecordId(@Param(\"attendanceRecordId\") Long attendanceRecordId);\n}\n\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\RoleRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/RoleRepository.java",
      "filename": "RoleRepository.java",
      "size_bytes": 1425,
      "lines": 37,
      "last_modified": "2025-11-28T08:56:33.010549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.Role;\nimport com.fuacs.backend.repository.custom.CustomRoleRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Modifying;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.Collection;\nimport java.util.Optional;\nimport java.util.Set;\n\n@Repository\npublic interface RoleRepository extends JpaRepository<Role, Short>, CustomRoleRepository {\n\n        @Modifying\n        @Query(\"UPDATE Role r SET r.isActive = false WHERE r.id = :id \" +\n                        \"AND r.name NOT IN ('STUDENT', 'LECTURER', 'DATA_OPERATOR', 'SUPERVISOR')\")\n        int deactivateById(@Param(\"id\") Short id);\n\n        boolean existsByName(String name);\n\n        @Query(\"SELECT r FROM Role r \" +\n                        \"WHERE r.id = :id \" +\n                        \"AND r.name NOT IN ('STUDENT', 'LECTURER', 'DATA_OPERATOR', 'SUPERVISOR')\")\n        Optional<Role> findUpdatableRoleById(@Param(\"id\") Short id);\n\n        Set<Role> findByIdIn(Collection<Short> ids);\n\n        Optional<Role> findByName(String name);\n\n        Set<Role> findAllByNameIn(Collection<String> names);\n\n        java.util.List<Role> findByNameIn(Collection<String> names);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\RoomRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/RoomRepository.java",
      "filename": "RoomRepository.java",
      "size_bytes": 3759,
      "lines": 91,
      "last_modified": "2025-11-28T08:56:33.010549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.Room;\nimport com.fuacs.backend.repository.custom.CustomRoomRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.time.LocalDateTime;\n\n/**\n * Repository JPA cho Room entity với các JPQL queries và custom queries.\n * Kế thừa JpaRepository để có CRUD cơ bản và CustomRoomRepository cho search phức tạp.\n *\n * @see Room\n * @see CustomRoomRepository\n */\n@Repository\npublic interface RoomRepository extends JpaRepository<Room, Short>, CustomRoomRepository {\n\n    /**\n     * Kiểm tra xem tên phòng đã tồn tại chưa.\n     * Dùng để validate uniqueness khi tạo phòng mới.\n     *\n     * @param name Tên phòng cần kiểm tra (ví dụ: \"301\", \"Lab-A1\")\n     * @return true nếu name đã tồn tại, false nếu chưa\n     */\n    boolean existsByName(String name);\n\n    /**\n     * Kiểm tra xem tên phòng đã tồn tại ở phòng khác chưa (loại trừ phòng hiện tại).\n     * Dùng để validate uniqueness khi update phòng.\n     *\n     * @param name Tên phòng cần kiểm tra\n     * @param id ID của phòng hiện tại (loại trừ khỏi check)\n     * @return true nếu name đã tồn tại ở phòng khác, false nếu chưa\n     */\n    boolean existsByNameAndIdNot(String name, Short id);\n\n    /**\n     * Đếm số camera đang active trong phòng.\n     * Dùng để validate trước khi deactivate phòng.\n     *\n     * @param roomId ID phòng cần đếm\n     * @return Số camera active (isActive = true) trong phòng\n     */\n    @Query(\"SELECT COUNT(c.id) FROM Camera c WHERE c.room.id = :roomId AND c.isActive = true\")\n    long countActiveCamerasByRoomId(@Param(\"roomId\") Short roomId);\n\n    /**\n     * Đếm số slot active đang diễn ra hoặc sắp diễn ra trong phòng.\n     * Slot được tính nếu startTime >= now và isActive = true.\n     *\n     * @param roomId ID phòng cần đếm\n     * @param now Thời điểm hiện tại\n     * @return Số slot active chưa kết thúc trong phòng\n     */\n    @Query(\"SELECT COUNT(s.id) FROM Slot s WHERE s.room.id = :roomId AND s.startTime >= :now AND s.isActive = true\")\n    long countActiveSlotsByRoomId(@Param(\"roomId\") Short roomId, @Param(\"now\") LocalDateTime now);\n\n    /**\n     * Đếm số slot sắp diễn ra trong phòng (chưa bắt đầu).\n     * Slot được tính nếu startTime > now và isActive = true.\n     *\n     * @param roomId ID phòng cần đếm\n     * @param now Thời điểm hiện tại\n     * @return Số slot tương lai trong phòng\n     */\n    @Query(\"SELECT COUNT(s.id) FROM Slot s WHERE s.room.id = :roomId AND s.startTime > :now AND s.isActive = true\")\n    long countFutureSlotsByRoomId(@Param(\"roomId\") Short roomId, @Param(\"now\") LocalDateTime now);\n\n    /**\n     * Đếm tổng số camera trong phòng (bao gồm cả active và inactive).\n     * Dùng để hiển thị thống kê tổng quan.\n     *\n     * @param roomId ID phòng cần đếm\n     * @return Tổng số camera trong phòng\n     */\n    @Query(\"SELECT COUNT(c.id) FROM Camera c WHERE c.room.id = :roomId\")\n    long countAllCamerasByRoomId(@Param(\"roomId\") Short roomId);\n\n    /**\n     * Tìm phòng theo tên chính xác.\n     * Dùng trong CSV import để check existing room.\n     *\n     * @param name Tên phòng cần tìm\n     * @return Room entity nếu tìm thấy, null nếu không tồn tại\n     */\n    Room findByName(String name);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\SemesterRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/SemesterRepository.java",
      "filename": "SemesterRepository.java",
      "size_bytes": 3590,
      "lines": 60,
      "last_modified": "2025-11-28T08:56:33.010549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.Semester;\nimport com.fuacs.backend.repository.custom.CustomSemesterRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.time.LocalDate;\nimport java.util.List;\n\n@Repository\npublic interface SemesterRepository extends JpaRepository<Semester, Short>, CustomSemesterRepository {\n\n    boolean existsByCode(String code);\n\n    boolean existsByName(String name);\n\n    @Query(\"SELECT CASE WHEN COUNT(s) > 0 THEN true ELSE false END FROM Semester s WHERE s.startDate = :startDate AND s.endDate = :endDate\")\n    boolean existsByStartDateAndEndDate(@Param(\"startDate\") LocalDate startDate, @Param(\"endDate\") LocalDate endDate);\n\n    // Check if any semester overlaps with the given date range\n    // Overlap occurs when: newStart < existingEnd AND newEnd > existingStart\n    @Query(\"SELECT CASE WHEN COUNT(s) > 0 THEN true ELSE false END FROM Semester s WHERE s.startDate < :endDate AND s.endDate > :startDate\")\n    boolean existsByDateRangeOverlap(@Param(\"startDate\") LocalDate startDate, @Param(\"endDate\") LocalDate endDate);\n\n    boolean existsByCodeAndIdNot(String code, Short id);\n\n    boolean existsByNameAndIdNot(String name, Short id);\n\n    @Query(\"SELECT CASE WHEN COUNT(s) > 0 THEN true ELSE false END FROM Semester s WHERE s.startDate = :startDate AND s.endDate = :endDate AND s.id != :id\")\n    boolean existsByStartDateAndEndDateAndIdNot(@Param(\"startDate\") LocalDate startDate, @Param(\"endDate\") LocalDate endDate, @Param(\"id\") Short id);\n\n    // Check if any semester (excluding the given ID) overlaps with the date range\n    @Query(\"SELECT CASE WHEN COUNT(s) > 0 THEN true ELSE false END FROM Semester s WHERE s.id != :id AND s.startDate < :endDate AND s.endDate > :startDate\")\n    boolean existsByDateRangeOverlapAndIdNot(@Param(\"startDate\") LocalDate startDate, @Param(\"endDate\") LocalDate endDate, @Param(\"id\") Short id);\n\n    @Query(\"SELECT COUNT(ac.id) FROM AcademicClass ac WHERE ac.semester.id = :semesterId\")\n    long countClassesBySemesterId(@Param(\"semesterId\") Short semesterId);\n\n    Semester findByCode(String code);\n\n    // Dashboard: semesters where lecturer has slots\n    @Query(\"SELECT DISTINCT s.academicClass.semester FROM Slot s WHERE s.staff.id = :lecturerId \" +\n           \"AND (s.slotCategory = 'LECTURE' OR s.slotCategory = 'LECTURE_WITH_PT') \" +\n           \"ORDER BY s.academicClass.semester.startDate DESC\")\n    java.util.List<com.fuacs.backend.entity.Semester> findSemestersWithSlotsByLecturerId(@Param(\"lecturerId\") Integer lecturerId);\n\n    // Dashboard: semesters from independent slots (Slot.semester)\n    @Query(\"SELECT DISTINCT s.semester FROM Slot s WHERE s.staff.id = :lecturerId AND s.semester IS NOT NULL \" +\n           \"AND (s.slotCategory = 'LECTURE' OR s.slotCategory = 'LECTURE_WITH_PT') \" +\n           \"ORDER BY s.semester.startDate DESC\")\n    java.util.List<com.fuacs.backend.entity.Semester> findIndependentSemestersWithSlotsByLecturerId(@Param(\"lecturerId\") Integer lecturerId);\n\n    // Dashboard: current semester by date range\n    // Returns list to handle multiple overlapping semesters (ordered by start date DESC)\n    @Query(\"SELECT sem FROM Semester sem WHERE CURRENT_DATE BETWEEN sem.startDate AND sem.endDate ORDER BY sem.startDate DESC\")\n    List<com.fuacs.backend.entity.Semester> findCurrentSemesters();\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\SlotRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/SlotRepository.java",
      "filename": "SlotRepository.java",
      "size_bytes": 11216,
      "lines": 224,
      "last_modified": "2025-12-01T19:14:26.665809",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.Slot;\nimport com.fuacs.backend.constant.enums.SlotCategory;\nimport com.fuacs.backend.repository.custom.CustomSlotRepository;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.time.LocalDateTime;\nimport java.util.List;\n\n@Repository\npublic interface SlotRepository extends JpaRepository<Slot, Integer>, CustomSlotRepository {\n\n    @Query(\"SELECT s FROM Slot s WHERE s.academicClass.id = :classId\")\n    List<Slot> findByClassId(@Param(\"classId\") Short classId);\n\n    @Query(\"SELECT s FROM Slot s WHERE s.staff.id = :staffUserId\")\n    List<Slot> findByStaffUserId(@Param(\"staffUserId\") Integer staffUserId);\n\n    @Query(\"SELECT s FROM Slot s WHERE s.room.id = :roomId\")\n    List<Slot> findByRoomId(@Param(\"roomId\") Short roomId);\n\n    @Query(\"SELECT s FROM Slot s WHERE s.academicClass.semester.id = :semesterId\")\n    List<Slot> findBySemesterId(@Param(\"semesterId\") Short semesterId);\n\n    @Query(\"SELECT s FROM Slot s WHERE s.startTime <= :now AND s.endTime >= :now\")\n    List<Slot> findActiveSlots(@Param(\"now\") LocalDateTime now);\n\n    @Query(\"SELECT s FROM Slot s WHERE s.startTime > :now\")\n    List<Slot> findUpcomingSlots(@Param(\"now\") LocalDateTime now);\n\n    @Query(\"SELECT s FROM Slot s WHERE s.endTime < :now\")\n    List<Slot> findPastSlots(@Param(\"now\") LocalDateTime now);\n\n    @Query(\"SELECT s FROM Slot s WHERE s.slotCategory = :slotCategory\")\n    List<Slot> findBySlotCategory(@Param(\"slotCategory\") com.fuacs.backend.constant.enums.SlotCategory slotCategory);\n\n    @Query(\"SELECT s FROM Slot s WHERE s.academicClass.id = :classId AND s.staff.id = :staffUserId\")\n    List<Slot> findByClassIdAndStaffUserId(@Param(\"classId\") Short classId, @Param(\"staffUserId\") Integer staffUserId);\n\n    @Query(\"SELECT s FROM Slot s WHERE s.id = :slotId AND s.staff.id = :staffUserId\")\n    Slot findByIdAndStaffUserId(@Param(\"slotId\") Integer slotId, @Param(\"staffUserId\") Integer staffUserId);\n\n    @Query(\"SELECT COUNT(s) > 0 FROM Slot s WHERE s.id = :slotId AND s.staff.id = :staffUserId\")\n    boolean isSlotAssignedToStaff(@Param(\"slotId\") Integer slotId, @Param(\"staffUserId\") Integer staffUserId);\n\n    /**\n     * Check if a slot exists and is assigned to the specified staff member.\n     * Used for ownership validation in authentication scenarios.\n     * \n     * @param slotId the ID of the slot to check\n     * @param staffId the ID of the staff member\n     * @return true if the slot exists and is assigned to the staff member, false otherwise\n     */\n    @Query(\"SELECT COUNT(s) > 0 FROM Slot s WHERE s.id = :slotId AND s.staff.id = :staffId\")\n    boolean existsByIdAndStaffId(@Param(\"slotId\") Integer slotId, @Param(\"staffId\") Integer staffId);\n\n    @Query(\"SELECT COUNT(s) > 0 FROM Slot s WHERE s.id = :slotId AND s.academicClass.id IN :classIds\")\n    boolean isSlotAssignedToClasses(@Param(\"slotId\") Integer slotId, @Param(\"classIds\") List<Short> classIds);\n\n    @Query(\"SELECT COUNT(s) > 0 FROM Slot s WHERE s.id = :slotId AND s.slotCategory = :slotCategory\")\n    boolean isSlotOfCategory(@Param(\"slotId\") Integer slotId,\n            @Param(\"slotCategory\") com.fuacs.backend.constant.enums.SlotCategory slotCategory);\n\n    @Query(\"SELECT COUNT(s) > 0 FROM Slot s WHERE s.id = :slotId AND s.startTime <= :now AND s.endTime >= :now\")\n    boolean isSlotActive(@Param(\"slotId\") Integer slotId, @Param(\"now\") LocalDateTime now);\n\n    // Upcoming slots for a staff member in a specific room, limited by Pageable (use PageRequest.of(0,3))\n    // Using @Query with JOIN FETCH to avoid lazy loading issues\n    @Query(\"SELECT s FROM Slot s \" +\n           \"LEFT JOIN FETCH s.semester \" +\n           \"LEFT JOIN FETCH s.academicClass ac \" +\n           \"LEFT JOIN FETCH ac.semester \" +\n           \"LEFT JOIN FETCH ac.subject \" +\n           \"JOIN FETCH s.room \" +\n           \"JOIN FETCH s.staff \" +\n           \"WHERE s.staff.id = :staffId \" +\n           \"AND s.room.id = :roomId \" +\n           \"AND s.startTime > :now \" +\n           \"ORDER BY s.startTime ASC\")\n    java.util.List<Slot> findByStaff_IdAndRoom_IdAndStartTimeAfterOrderByStartTimeAsc(\n            @Param(\"staffId\") Integer staffId,\n            @Param(\"roomId\") Short roomId,\n            @Param(\"now\") LocalDateTime now,\n            Pageable pageable);\n\n    /**\n     * Find slot by natural keys: semester code, start time, and room name.\n     * Used for CSV import to lookup slots without requiring technical IDs.\n     */\n    @Query(\"SELECT s FROM Slot s \" +\n           \"WHERE s.semester.code = :semesterCode \" +\n           \"AND s.startTime = :startTime \" +\n           \"AND s.room.name = :roomName\")\n    Slot findBySemesterCodeAndStartTimeAndRoomName(\n            @Param(\"semesterCode\") String semesterCode,\n            @Param(\"startTime\") LocalDateTime startTime,\n            @Param(\"roomName\") String roomName);\n\n    // Data Operator Dashboard queries - Per Semester\n    @Query(\"SELECT COUNT(s) FROM Slot s \" +\n           \"JOIN s.academicClass ac \" +\n           \"WHERE ac.semester.id = :semesterId\")\n    Integer countTotalSlotsBySemester(@Param(\"semesterId\") Short semesterId);\n\n    @Query(\"SELECT COUNT(s) FROM Slot s \" +\n           \"JOIN s.academicClass ac \" +\n           \"WHERE ac.semester.id = :semesterId \" +\n           \"AND s.endTime < CURRENT_TIMESTAMP \" +\n           \"AND EXISTS (SELECT 1 FROM AttendanceRecord ar WHERE ar.slot.id = s.id)\")\n    Integer countFinalizedSlotsBySemester(@Param(\"semesterId\") Short semesterId);\n\n    @Query(\"SELECT CASE WHEN COUNT(s) = 0 THEN 0.0 ELSE \" +\n           \"(CAST(COUNT(CASE WHEN s.endTime < CURRENT_TIMESTAMP AND EXISTS (SELECT 1 FROM AttendanceRecord ar WHERE ar.slot.id = s.id) THEN 1 END) AS DOUBLE) / COUNT(s)) * 100.0 END \" +\n           \"FROM Slot s \" +\n           \"JOIN s.academicClass ac \" +\n           \"WHERE ac.semester.id = :semesterId\")\n    Double calculateSlotsCompletionRateBySemester(@Param(\"semesterId\") Short semesterId);\n\n    // Data Operator Dashboard queries - All Semesters (no semester filter)\n    // Count all slots (class-based + independent/final exam slots)\n    @Query(\"SELECT COUNT(s) FROM Slot s\")\n    Integer countTotalSlots();\n\n    @Query(\"SELECT CASE WHEN COUNT(s) = 0 THEN 0.0 ELSE \" +\n           \"(CAST(COUNT(CASE WHEN s.endTime < CURRENT_TIMESTAMP AND \" +\n           \"(EXISTS (SELECT 1 FROM AttendanceRecord ar WHERE ar.slot.id = s.id) OR \" +\n           \"EXISTS (SELECT 1 FROM ExamAttendance ea WHERE ea.slot.id = s.id)) THEN 1 END) AS DOUBLE) / COUNT(s)) * 100.0 END \" +\n           \"FROM Slot s\")\n    Double calculateSlotsCompletionRate();\n\n    // Count PRESENT/ABSENT attendance records (actual data, not NOT_YET)\n    @Query(\"SELECT COUNT(ar) FROM AttendanceRecord ar \" +\n           \"WHERE ar.slot.id = :slotId \" +\n           \"AND ar.status IN ('PRESENT', 'ABSENT')\")\n    long countActualAttendanceRecordsBySlotId(@Param(\"slotId\") Integer slotId);\n\n    // Count PRESENT/ABSENT exam attendance records\n    @Query(\"SELECT COUNT(ea) FROM ExamAttendance ea \" +\n           \"WHERE ea.slot.id = :slotId \" +\n           \"AND ea.status IN ('PRESENT', 'ABSENT')\")\n    long countActualExamAttendanceRecordsBySlotId(@Param(\"slotId\") Integer slotId);\n\n    /**\n     * Find the earliest slot start time for a class.\n     * Returns null if no slots exist for the class.\n     */\n    @Query(\"SELECT MIN(s.startTime) FROM Slot s WHERE s.academicClass.id = :classId\")\n    LocalDateTime findFirstSlotStartTimeByClassId(@Param(\"classId\") Short classId);\n\n    // Attendance Finalization Methods\n\n    /**\n     * Find active LECTURE and LECTURE_WITH_PT slots that ended within the specified time range.\n     * Used for daily attendance finalization at 23:59.\n     */\n    @Query(\"SELECT s FROM Slot s WHERE s.isActive = true \" +\n           \"AND s.slotCategory IN :categories \" +\n           \"AND s.endTime BETWEEN :startOfDay AND :endOfDay\")\n    List<Slot> findActiveSlotsByCategoriesTodayEnded(\n        @Param(\"categories\") List<SlotCategory> categories,\n        @Param(\"startOfDay\") LocalDateTime startOfDay,\n        @Param(\"endOfDay\") LocalDateTime endOfDay\n    );\n\n    /**\n     * Find active FINAL_EXAM slots that have expired (endTime before cutoff) with pending attendance.\n     * Used for exam attendance finalization after grace period.\n     */\n    @Query(\"SELECT s FROM Slot s WHERE s.isActive = true \" +\n           \"AND s.slotCategory = :category \" +\n           \"AND s.endTime < :cutoffTime \" +\n           \"AND EXISTS (\" +\n           \"SELECT 1 FROM ExamAttendance ea WHERE ea.slot = s \" +\n           \"AND ea.status = :pendingStatus)\")\n    List<Slot> findActiveExpiredExamSlotsWithPendingAttendance(\n        @Param(\"category\") SlotCategory category,\n        @Param(\"cutoffTime\") LocalDateTime cutoffTime,\n        @Param(\"pendingStatus\") com.fuacs.backend.constant.enums.AttendanceStatus pendingStatus\n    );\n\n    /**\n     * Find active lecture slots (LECTURE, LECTURE_WITH_PT) that have expired with pending attendance.\n     * Only considers slots ending today (between startOfDay and cutoffTime).\n     * Used for lecture attendance finalization after grace period.\n     */\n    @Query(\"SELECT s FROM Slot s WHERE s.isActive = true \" +\n           \"AND s.slotCategory IN :categories \" +\n           \"AND s.endTime >= :startOfDay \" +\n           \"AND s.endTime < :cutoffTime \" +\n           \"AND EXISTS (\" +\n           \"SELECT 1 FROM AttendanceRecord ar WHERE ar.slot = s \" +\n           \"AND ar.status = :pendingStatus)\")\n    List<Slot> findActiveExpiredSlotsWithPendingAttendance(\n        @Param(\"categories\") List<SlotCategory> categories,\n        @Param(\"startOfDay\") LocalDateTime startOfDay,\n        @Param(\"cutoffTime\") LocalDateTime cutoffTime,\n        @Param(\"pendingStatus\") com.fuacs.backend.constant.enums.AttendanceStatus pendingStatus\n    );\n\n    /**\n     * Find active exam slots (LECTURE_WITH_PT, FINAL_EXAM) that have expired with pending exam attendance.\n     * Only considers slots ending today (between startOfDay and cutoffTime).\n     * Used for exam attendance finalization after grace period.\n     */\n    @Query(\"SELECT s FROM Slot s WHERE s.isActive = true \" +\n           \"AND s.slotCategory IN (:lectureWithPt, :finalExam) \" +\n           \"AND s.endTime >= :startOfDay \" +\n           \"AND s.endTime < :cutoffTime \" +\n           \"AND EXISTS (\" +\n           \"SELECT 1 FROM ExamAttendance ea WHERE ea.slot = s \" +\n           \"AND ea.status = :pendingStatus)\")\n    List<Slot> findActiveExpiredExamSlotsWithPendingAttendance(\n        @Param(\"startOfDay\") LocalDateTime startOfDay,\n        @Param(\"cutoffTime\") LocalDateTime cutoffTime,\n        @Param(\"pendingStatus\") com.fuacs.backend.constant.enums.AttendanceStatus pendingStatus,\n        @Param(\"lectureWithPt\") SlotCategory lectureWithPt,\n        @Param(\"finalExam\") SlotCategory finalExam\n    );\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\StaffProfileRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/StaffProfileRepository.java",
      "filename": "StaffProfileRepository.java",
      "size_bytes": 1187,
      "lines": 27,
      "last_modified": "2025-11-28T08:56:33.010549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.StaffProfile;\nimport com.fuacs.backend.repository.custom.CustomStaffProfileRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface StaffProfileRepository extends JpaRepository<StaffProfile, Integer>, CustomStaffProfileRepository {\n\n    boolean existsByStaffCode(String staffCode);\n\n    boolean existsByStaffCodeAndUserIdNot(String staffCode, Integer userId);\n\n    StaffProfile findByStaffCode(String staffCode);\n\n    @Query(\"SELECT COUNT(sp.id) FROM StaffProfile sp \" +\n            \"INNER JOIN sp.user u \" +\n            \"INNER JOIN u.roles r \" +\n            \"WHERE (LOWER(u.fullName) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n            \"LOWER(sp.staffCode) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n            \"LOWER(u.email) LIKE LOWER(CONCAT('%', :search, '%'))) \" +\n            \"AND r.name <> 'STUDENT'\")\n    Long countAllStaffProfiles(@Param(\"search\") String search);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\StudentProfileRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/StudentProfileRepository.java",
      "filename": "StudentProfileRepository.java",
      "size_bytes": 5229,
      "lines": 93,
      "last_modified": "2025-11-28T08:56:33.011549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.StudentProfile;\nimport com.fuacs.backend.repository.custom.CustomStudentProfileRepository;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface StudentProfileRepository\n                extends JpaRepository<StudentProfile, Integer>, CustomStudentProfileRepository {\n\n        boolean existsByRollNumber(String rollNumber);\n\n        boolean existsByRollNumberAndUserIdNot(String rollNumber, Integer userId);\n\n        StudentProfile findByRollNumber(String rollNumber);\n\n        // Eager fetch User and Major for enrollment import to avoid lazy loading issues\n        @Query(\"SELECT sp FROM StudentProfile sp JOIN FETCH sp.user JOIN FETCH sp.major WHERE sp.rollNumber = :rollNumber\")\n        StudentProfile findByRollNumberWithUserAndMajor(@Param(\"rollNumber\") String rollNumber);\n\n        @Query(value = \"SELECT sp.* FROM student_profiles sp \" +\n                        \"INNER JOIN users u ON sp.user_id = u.id \" +\n                        \"INNER JOIN majors m ON sp.major_id = m.id \" +\n                        \"INNER JOIN user_roles ur ON u.id = ur.user_id \" +\n                        \"INNER JOIN roles r ON ur.role_id = r.id \" +\n                        \"WHERE (LOWER(u.username) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"LOWER(u.full_name) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"LOWER(u.email) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"LOWER(m.name) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"LOWER(m.code) LIKE LOWER(CONCAT('%', :search, '%'))) \" +\n                        \"AND r.name = 'STUDENT'\", nativeQuery = true)\n        Page<StudentProfile> searchStudents(@Param(\"search\") String search, Pageable pageable);\n\n        @Query(value = \"SELECT COUNT(sp.user_id) FROM student_profiles sp \" +\n                        \"INNER JOIN users u ON sp.user_id = u.id \" +\n                        \"INNER JOIN majors m ON sp.major_id = m.id \" +\n                        \"INNER JOIN user_roles ur ON u.id = ur.user_id \" +\n                        \"INNER JOIN roles r ON ur.role_id = r.id \" +\n                        \"WHERE (\" +\n                        \"LOWER(u.username) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"LOWER(u.full_name) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"LOWER(u.email) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"LOWER(m.name) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"LOWER(m.code) LIKE LOWER(CONCAT('%', :search, '%'))\" +\n                        \")\" +\n                        \"AND r.name = 'STUDENT'\", nativeQuery = true)\n        Long countAllStudents(@Param(\"search\") String search);\n\n        // Data Operator Dashboard queries\n        @Query(\"SELECT COUNT(DISTINCT sp) FROM StudentProfile sp \" +\n               \"JOIN Enrollment e ON e.student.id = sp.userId \" +\n               \"JOIN e.academicClass ac \" +\n               \"WHERE ac.semester.id = :semesterId\")\n        Integer countTotalStudentsBySemester(@Param(\"semesterId\") Short semesterId);\n\n        @Query(\"SELECT COUNT(DISTINCT sp) FROM StudentProfile sp \" +\n               \"JOIN sp.user u \" +\n               \"JOIN Enrollment e ON e.student.id = sp.userId \" +\n               \"JOIN e.academicClass ac \" +\n               \"WHERE ac.semester.id = :semesterId AND u.isActive = true\")\n        Integer countActiveStudentsBySemester(@Param(\"semesterId\") Short semesterId);\n\n        @Query(\"SELECT AVG(classStudentCount) FROM (\" +\n               \"SELECT COUNT(e.student) as classStudentCount \" +\n               \"FROM AcademicClass ac \" +\n               \"LEFT JOIN ac.enrollments e \" +\n               \"WHERE ac.semester.id = :semesterId \" +\n               \"GROUP BY ac.id)\")\n        Double calculateAverageStudentsPerClassBySemester(@Param(\"semesterId\") Short semesterId);\n\n        // Data Operator Dashboard - All Semesters (no semester filter)\n        @Query(\"SELECT AVG(classStudentCount) FROM (\" +\n               \"SELECT COUNT(e.student) as classStudentCount \" +\n               \"FROM AcademicClass ac \" +\n               \"LEFT JOIN ac.enrollments e \" +\n               \"GROUP BY ac.id)\")\n        Double calculateAverageStudentsPerClass();\n\n        /**\n         * Find all student profiles by user IDs with eager loading of Major.\n         * Used for batch fetching student profiles to avoid N+1 queries.\n         *\n         * @param userIds Collection of user IDs to fetch profiles for\n         * @return List of StudentProfiles with Major eagerly loaded\n         */\n        @Query(\"SELECT sp FROM StudentProfile sp JOIN FETCH sp.major WHERE sp.userId IN :userIds\")\n        java.util.List<StudentProfile> findAllByUserIdsWithMajor(@Param(\"userIds\") java.util.Collection<Integer> userIds);\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\SubjectRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/SubjectRepository.java",
      "filename": "SubjectRepository.java",
      "size_bytes": 1212,
      "lines": 28,
      "last_modified": "2025-12-03T09:13:01.866540",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.Subject;\nimport com.fuacs.backend.repository.custom.CustomSubjectRepository;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface SubjectRepository extends JpaRepository<Subject, Short>, CustomSubjectRepository {\n\n    boolean existsByCode(String code);\n\n    boolean existsByCodeAndIdNot(String code, Short id);\n\n    @Query(\"SELECT COUNT(c.id) FROM AcademicClass c WHERE c.subject.id = :subjectId\")\n    long countAllClassesBySubjectId(@Param(\"subjectId\") Short subjectId);\n\n    @Query(\"SELECT COUNT(c.id) FROM AcademicClass c WHERE c.subject.id = :subjectId AND c.isActive = true\")\n    long countActiveClassesBySubjectId(@Param(\"subjectId\") Short subjectId);\n\n    Subject findByCode(String code);\n\n    // Data Operator Dashboard queries\n    @Query(\"SELECT COUNT(DISTINCT c.subject) FROM AcademicClass c WHERE c.semester.id = :semesterId\")\n    Integer countSubjectsBySemester(@Param(\"semesterId\") Short semesterId);\n}"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\SystemNotificationRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/SystemNotificationRepository.java",
      "filename": "SystemNotificationRepository.java",
      "size_bytes": 323,
      "lines": 9,
      "last_modified": "2025-12-01T17:52:10.041256",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.SystemNotification;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface SystemNotificationRepository extends JpaRepository<SystemNotification, Long> {\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\repository\\UserRepository.java",
      "relative_path": "src/main/java/com/fuacs/backend/repository/UserRepository.java",
      "filename": "UserRepository.java",
      "size_bytes": 2939,
      "lines": 61,
      "last_modified": "2025-11-28T08:56:33.011549",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.repository;\n\nimport com.fuacs.backend.entity.User;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Modifying;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.Optional;\nimport java.util.Set;\n\n@Repository\npublic interface UserRepository extends JpaRepository<User, Integer> {\n\n        @Query(value = \"SELECT u FROM User u JOIN u.roles r \" +\n                        \"WHERE r.name IN ('LECTURER', 'SUPERVISOR') \" +\n                        \"AND (\" +\n                        \"  LOWER(u.username) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"  LOWER(u.fullName) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"  LOWER(u.email) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"  LOWER(r.name) LIKE LOWER(CONCAT('%', :search, '%'))\" +\n                        \")\")\n        Page<User> searchStaffs(@Param(\"search\") String search, Pageable pageable);\n\n        @Query(value = \"SELECT COUNT(DISTINCT u.id) FROM users u \" +\n                        \"INNER JOIN user_roles ur ON u.id = ur.user_id \" +\n                        \"INNER JOIN roles r ON ur.role_id = r.id \" +\n                        \"WHERE r.name IN ('LECTURER', 'SUPERVISOR') \" +\n                        \"AND (\" +\n                        \"  LOWER(u.username) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"  LOWER(u.full_name) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"  LOWER(u.email) LIKE LOWER(CONCAT('%', :search, '%')) OR \" +\n                        \"  LOWER(r.name) LIKE LOWER(CONCAT('%', :search, '%'))\" +\n                        \")\", nativeQuery = true)\n        Long countAllStaffs(@Param(\"search\") String search);\n\n        Optional<User> findByUsername(String username);\n\n        @Query(\"SELECT u FROM User u LEFT JOIN FETCH u.roles WHERE u.username = :username\")\n        Optional<User> findByUsernameWithRoles(@Param(\"username\") String username);\n\n        Optional<User> findByEmail(String email);\n\n        @Modifying\n        @Query(\"UPDATE User u SET u.isActive = false WHERE u.id = :id\")\n        int deactivateUserById(@Param(\"id\") Integer id);\n\n        boolean existsByEmailOrUsername(String email, String username);\n\n        @Query(\"SELECT DISTINCT u FROM User u JOIN u.roles r WHERE u.id = :id AND r.name IN :roles\")\n        Optional<User> findUserByIdAndRoles(@Param(\"id\") Integer id, @Param(\"roles\") Set<String> roles);\n\n        boolean existsByEmail(String email);\n\n        boolean existsByUsername(String username);\n\n        boolean existsByEmailAndIdNot(String email, Integer id);\n}\n"
    }
  ]
}