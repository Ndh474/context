{
  "metadata": {
    "codebase": "backend",
    "category": "util",
    "generated_at": "2025-11-28T09:26:36.248030",
    "total_files": 2,
    "total_lines": 214,
    "total_bytes": 8464
  },
  "files": [
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\util\\SecurityUtil.java",
      "relative_path": "src/main/java/com/fuacs/backend/util/SecurityUtil.java",
      "filename": "SecurityUtil.java",
      "size_bytes": 2530,
      "lines": 61,
      "last_modified": "2025-11-28T08:56:33.029566",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.util;\n\nimport com.fuacs.backend.config.UserAuthentication;\nimport com.fuacs.backend.constant.ErrorCode;\nimport com.fuacs.backend.exception.OperationNotAllowedException;\nimport org.springframework.security.authentication.AnonymousAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Optional;\n\npublic final class SecurityUtil {\n\n    public static Optional<String> getLoginUserName() {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n\n        if (authentication == null\n                || !authentication.isAuthenticated()\n                || authentication instanceof AnonymousAuthenticationToken) {\n            return Optional.empty();\n        }\n\n        Object principal = authentication.getPrincipal();\n\n        if (principal instanceof UserDetails springUser) {\n            return Optional.of(springUser.getUsername());\n        } else if (principal instanceof String username) {\n            return Optional.of(username);\n        }\n\n        return Optional.ofNullable(authentication.getName());\n    }\n\n    public static Optional<Integer> getLoginUserId() {\n        return Optional.ofNullable(SecurityContextHolder.getContext().getAuthentication())\n                .filter(UserAuthentication.class::isInstance)\n                .map(UserAuthentication.class::cast)\n                .map(UserAuthentication::getUserId);\n    }\n\n    /**\n     * Get the current authenticated user ID with proper exception handling.\n     * This method extracts the user ID from the security context and throws\n     * an appropriate exception if the user is not authenticated.\n     * \n     * @return The current authenticated user ID\n     * @throws OperationNotAllowedException if the user is not authenticated\n     */\n    public static Integer getCurrentUserId() {\n        return getLoginUserId()\n                .orElseThrow(() -> new OperationNotAllowedException(\n                    \"User not authenticated\", ErrorCode.UN_AUTHENTICATION));\n    }\n\n    public static Optional<UserAuthentication> getUserAuthentication() {\n        return Optional.ofNullable(SecurityContextHolder.getContext().getAuthentication())\n                .filter(UserAuthentication.class::isInstance)\n                .map(UserAuthentication.class::cast);\n    }\n}\n"
    },
    {
      "path": "D:\\Work\\do_an_fall25\\fuacs\\backend\\src\\main\\java\\com\\fuacs\\backend\\util\\TokenProviderUtil.java",
      "relative_path": "src/main/java/com/fuacs/backend/util/TokenProviderUtil.java",
      "filename": "TokenProviderUtil.java",
      "size_bytes": 5934,
      "lines": 153,
      "last_modified": "2025-11-28T08:56:33.029566",
      "encoding": "utf-8",
      "language": "java",
      "content": "package com.fuacs.backend.util;\n\nimport com.fuacs.backend.constant.Constant;\nimport com.fuacs.backend.entity.PasswordResetToken;\nimport com.fuacs.backend.entity.Permission;\nimport com.fuacs.backend.entity.User;\nimport com.fuacs.backend.repository.PasswordResetTokenRepository;\nimport com.nimbusds.jose.JOSEException;\nimport com.nimbusds.jose.JOSEObjectType;\nimport com.nimbusds.jose.JWSAlgorithm;\nimport com.nimbusds.jose.JWSHeader;\nimport com.nimbusds.jose.JWSVerifier;\nimport com.nimbusds.jose.crypto.MACSigner;\nimport com.nimbusds.jose.crypto.MACVerifier;\nimport com.nimbusds.jwt.JWTClaimsSet;\nimport com.nimbusds.jwt.SignedJWT;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.text.ParseException;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Date;\nimport java.util.Set;\nimport java.util.UUID;\n\n@Component\npublic class TokenProviderUtil {\n    private static final Logger log = LoggerFactory.getLogger(TokenProviderUtil.class);\n    private static final JWSAlgorithm ALGORITHM = JWSAlgorithm.HS256;\n    private static final String KEY_ID = \"signKid\";\n    private final PasswordResetTokenRepository tokenRepository;\n\n    @Value(\"${token.expire}\")\n    private int expire;\n    @Value(\"${token.sign-key}\")\n    private String signKey;\n\n    public TokenProviderUtil(PasswordResetTokenRepository tokenRepository) {\n        this.tokenRepository = tokenRepository;\n    }\n\n    public String createAccessToken(User user,\n                                    Set<Permission> permissions) {\n        Instant now = Instant.now();\n\n        // Combine both permission names and role names in authorities\n        java.util.List<String> authorities = new java.util.ArrayList<>();\n        authorities.addAll(permissions.stream().map(Permission::getName).toList());\n        authorities.addAll(user.getRoles().stream()\n                .map(role -> role.getName())\n                .toList());\n\n        JWTClaimsSet claims = new JWTClaimsSet.Builder()\n                .subject(user.getUsername())\n                .claim(Constant.AUTH_TYPE, Constant.ACCESS_TOKEN)\n                .claim(Constant.USER_ID, user.getId())\n                .claim(Constant.EMAIL, user.getEmail())\n                .claim(Constant.AUTHORITIES, authorities)\n                .issueTime(Date.from(now))\n                .expirationTime(Date.from(now.plus(expire, ChronoUnit.MINUTES)))//3m expiry\n                .build();\n\n        return signToken(claims);\n    }\n\n    public String createRefreshToken(int userId) {\n        Instant now = Instant.now();\n        JWTClaimsSet claims = new JWTClaimsSet.Builder()\n                .claim(Constant.AUTH_TYPE, Constant.REFRESH_TOKEN)\n                .claim(Constant.USER_ID, userId)\n                .issueTime(Date.from(now))\n                .expirationTime(Date.from(now.plus(1, ChronoUnit.DAYS)))//1d expiry\n                .build();\n        return signToken(claims);\n    }\n\n    @Transactional\n    public String createResetPasswordToken(String email) {\n        String token = UUID.randomUUID().toString();\n        Instant now = Instant.now();\n        Instant expiry = now.plus(15, ChronoUnit.MINUTES);\n\n        // Nếu token đã tồn tại → update, ngược lại → insert\n        int updated = tokenRepository.updateToken(email, token, now, expiry);\n\n        if (updated == 0) { // chưa có token cho email này\n            PasswordResetToken resetToken = new PasswordResetToken();\n            resetToken.setEmail(email);\n            resetToken.setCreatedAt(now);\n            resetToken.setExpiresAt(expiry);\n            resetToken.setTokenHash(token);\n            tokenRepository.save(resetToken);\n        }\n\n        // TODO: gửi email tại đây (async)\n        return token;\n    }\n\n    private String signToken(JWTClaimsSet claims) {\n        try {\n            JWSHeader header = new JWSHeader.Builder(ALGORITHM)\n                    .keyID(KEY_ID)\n                    .type(JOSEObjectType.JWT)\n                    .build();\n\n            SignedJWT signedJWT = new SignedJWT(header, claims);\n            signedJWT.sign(new MACSigner(signKey.getBytes()));\n            return signedJWT.serialize();\n\n        } catch (JOSEException e) {\n            log.error(\"ErrorCode signing JWT: {}\", e.getMessage(), e);\n            throw new IllegalStateException(\"Failed to sign JWT\", e);\n        }\n    }\n\n    public boolean isValidRefreshToken(SignedJWT signedJWT) {\n        try {\n            if (!verifySignature(signedJWT)) return false;\n\n            JWTClaimsSet claims = signedJWT.getJWTClaimsSet();\n            if (!Constant.REFRESH_TOKEN.equals(claims.getStringClaim(Constant.AUTH_TYPE))) {\n                return false;\n            }\n\n            if (isExpired(claims.getExpirationTime())) {\n                return false;\n            }\n            return true;\n        } catch (ParseException e) {\n            log.error(\"Invalid token format: {}\", e.getMessage());\n        } catch (JOSEException e) {\n            log.error(\"Signature verification failed: {}\", e.getMessage());\n        } catch (Exception e) {\n            log.error(\"Unexpected error validating token: {}\", e.getMessage(), e);\n        }\n        return false;\n    }\n\n    private boolean verifySignature(SignedJWT signedJWT) throws JOSEException {\n        JWSVerifier verifier = new MACVerifier(signKey.getBytes());\n        boolean verified = signedJWT.verify(verifier);\n        // if not verified, just return the value (no need for continue)\n        return verified;\n    }\n\n    private boolean isExpired(Date expiry) {\n        return expiry == null || expiry.before(new Date());\n    }\n}\n"
    }
  ]
}